version: '3.45'

env:
  REGISTRY: "local"
  IMAGE_NAME: "noetl"

includes:
  tshoot:
    taskfile:   ci/taskfile/tshoot.yml
    flatten: true
  vmstack:
    taskfile: ci/taskfile/vmstack.yml
    flatten: true
  tests:
    taskfile: tests/taskfile/noetltest.yml
    flatten: true

tasks:
  default:
    silent: true
    cmds:
      - task --list

# === Kind Kubernetes Cluster ===
  kind-create-cluster:
    desc: Create noetl kind cluster
    aliases: [kcc]
    cmds:
      - kind create cluster --config=ci/kind/config.yaml

  kind-delete-cluster:
    desc: Delete noetl kind cluster
    aliases: [kdc]
    cmds:
      - kind delete cluster --name=noetl

  kind-get-clustes:
    desc: Show all kind clusters
    aliases: [kgc]
    cmds:
      - kind get clusters

  kubectl-set-context-kind:
    desc: Set kubectl context to kind-noetl cluster
    aliases: [ksck]
    cmds:
      - kubectl config use-context kind-noetl

# === Postgres ===
  deploy-postgres:
    desc: Deploy postgres to the noetl kind cluster
    aliases: [dp]
    cmds:
      - kubectl config use-context kind-noetl
      - kubectl apply -f ci/manifests/postgres/namespace/namespace.yaml
      - sleep 2
      - |
        kubectl create configmap postgres-schema-ddl --namespace postgres \
          --from-file=schema_ddl.sql.norun=noetl/database/ddl/postgres/schema_ddl.sql  
      - kubectl apply -f ci/manifests/postgres/

  remove-postgres:
    desc: Remove postgres from the noetl kind cluster
    aliases: [rp]
    cmds:
      - kubectl config use-context kind-noetl
      - kubectl delete -f ci/manifests/postgres/
      - kubectl delete configmap postgres-schema-ddl --namespace postgres

  postgres-reset-schema:
    desc: Reset NoETL schema on Postgres (DROP schema and re-run schema_ddl.sql)
    aliases: [prs]
    cmds:
      - kubectl config use-context kind-noetl
      - echo "Resetting NoETL schema on Postgres (DROP schema and re-run schema_ddl.sql)."
      - |
        set -a; [ -f .env ] && . .env; set +a
        # Override with kubectl service port for Kind cluster
        export PGHOST=localhost
        export PGPORT=54321
        export PGUSER=${POSTGRES_USER:-demo}
        export PGPASSWORD=${POSTGRES_PASSWORD:-demo}
        export PGDATABASE=${POSTGRES_DB:-demo_noetl}
        echo "Connecting to PostgreSQL at $PGHOST:$PGPORT as $PGUSER to database $PGDATABASE"
        echo "Dropping schema ${NOETL_SCHEMA:-noetl}..."
        psql -v ON_ERROR_STOP=1 -c "DROP SCHEMA IF EXISTS ${NOETL_SCHEMA:-noetl} CASCADE;"
        echo "Applying schema DDL via noetl CLI..."
        cli=".venv/bin/noetl"
        if [ ! -x "$cli" ]; then cli="noetl"; fi
        if $cli db apply-schema --ensure-role; then
          echo "Schema applied using packaged DDL."
        else
          echo "noetl CLI apply-schema failed; trying local DDL fallback..."
          if [ -f noetl/database/ddl/postgres/schema_ddl.sql ]; then
            psql -v ON_ERROR_STOP=1 -f noetl/database/ddl/postgres/schema_ddl.sql
          else
            echo "Could not apply schema (no CLI and no local DDL)."; exit 1
          fi
        fi

# === NOETL ===
  docker-build-noetl:
    desc: Build the noetl container with dynamic tag
    aliases: [dbn]
    vars:
      CACHE: '{{ if (eq .CLI_ARGS "cache")}}{{ else }}--no-cache{{ end }}'
    env:
      IMAGE_TAG:
        sh: date +%Y-%m-%d-%H-%M
    # The platform is not specified intentionally. The image platform should match the kind platform.
    cmds:
      - |
        echo $IMAGE_TAG > .noetl_last_build_tag.txt
        docker build --progress plain {{ .CACHE }} -t $REGISTRY/$IMAGE_NAME:$IMAGE_TAG -f docker/noetl/dev/Dockerfile .

  load-noetl-image:
    desc: Load noetl image to the noetl kind cluster
    aliases: [lni]
    env:
      IMAGE_TAG:
        sh: cat .noetl_last_build_tag.txt
    cmds:
      - kind load docker-image $REGISTRY/$IMAGE_NAME:$IMAGE_TAG --name noetl

  show-kind-images:
    desc: Show images inside of the noetl kind cluster
    aliases: [ski]
    cmds:
      - docker exec -it noetl-control-plane crictl images

  deploy-noetl:
    desc: Deploy noetl to the noetl kind cluster
    aliases: [dn]
    env:
      IMAGE_TAG:
        sh: cat .noetl_last_build_tag.txt
    cmds:
      - kubectl config use-context kind-noetl
      - kubectl apply -f ci/manifests/noetl/namespace/namespace.yaml
      - sleep 2
      - yq -i ".spec.template.spec.containers[0].image = \"$REGISTRY/$IMAGE_NAME:$IMAGE_TAG\"" ci/manifests/noetl/server-deployment.yaml
      - yq -i ".spec.template.spec.containers[0].image = \"$REGISTRY/$IMAGE_NAME:$IMAGE_TAG\"" ci/manifests/noetl/worker-deployment.yaml
      - kubectl apply -f ci/manifests/noetl/
      - yq -i ".spec.template.spec.containers[0].image = \"image_name:image_tag\"" ci/manifests/noetl/server-deployment.yaml
      - yq -i ".spec.template.spec.containers[0].image = \"image_name:image_tag\"" ci/manifests/noetl/worker-deployment.yaml

  remove-noetl:
    desc: Remove noetl from the noetl kind cluster
    aliases: [rn]
    cmds:
      - kubectl config use-context kind-noetl
      - kubectl delete -f ci/manifests/noetl/

  clear-docker-images:
    desc: Clear all {{ .REGISTRY }}/{{ .IMAGE_NAME }} docker images
    aliases: [cdi]
    cmds:
      - docker images "{{ .REGISTRY }}/{{ .IMAGE_NAME }}" --format "{{`{{.ID}}`}}" | xargs -r docker rmi -f

# === Clean up local file cache ===

  clear-postgres-data:
    desc: Clear postgres ci/kind/cache/pg-data folder on the host
    aliases: [cpd]
    cmds:
      - rm -rf ci/kind/cache/pg-data/*

  clear-noetl-data:
    desc: Clear noetl ci/kind/cache/noetl-data folder on the host
    aliases: [cnd]
    cmds:
      - rm -rf ci/kind/cache/noetl-data/*

  clear-noetl-logs:
    desc: Clear noetl ci/kind/cache/noetl-logs folder on the host
    aliases: [cnl]
    cmds:
      - rm -rf ci/kind/cache/noetl-logs/*

  clear-all-cache:
    desc: Clear local file cache ci/kind/cache/ sub-folders on the host
    aliases: [clear]
    cmds:
      - rm -rf ci/kind/cache/pg-data/*
      - rm -rf ci/kind/cache/noetl-data/*
      - rm -rf ci/kind/cache/noetl-logs/*

# === Combined Tasks ===
  bring-all:
    desc: Build noetl; Create noetl cluster with all deployments
    aliases: [ba]
    vars:
      CACHE: '{{ if (eq .CLI_ARGS "cache")}}{{ else }}--no-cache{{ end }}'
    cmds:
      - task: check-ports
      - task: docker-build-noetl
      - task: kind-create-cluster
      - task: load-noetl-image
      - task: deploy-monitoring
      - task: deploy-postgres
      - task: deploy-noetl


  noetl-redeploy:
    desc: Build noetl and redeploy
    aliases: [redeploy]
    vars:
      CACHE: '{{ if (eq .CLI_ARGS "cache")}}{{ else }}--no-cache{{ end }}'
    cmds:
      - task: docker-build-noetl
      - task: remove-noetl
      - task: load-noetl-image
      - task: deploy-noetl

  noetl-reset:
    desc: Build noetl and redeploy with new schema and tests playbooks in kind cluster
    aliases: [nreset]
    vars:
      CACHE: '{{ if (eq .CLI_ARGS "cache")}}{{ else }}--no-cache{{ end }}'
    cmds:
      - task: postgres-reset-schema 
      - task: noetl-redeploy
      - uv pip install -e ".[dev]" # noetl CLI with dev extras
      - sleep 30
      - task: setup-test-environment
      - task: test-create-tables
      - echo "UI :http://localhost:8082"
      - echo "API :http://localhost:8082/docs"

  server-debug:
    desc: Run NoETL server in debug mode via Python module (uses .env or .env.pycharm)
    aliases: [sdbg]
    cmds:
      - |
        set -e
        # Select env file: ENV_FILE overrides; otherwise prefer .env.pycharm if present; else .env
        env_file="${ENV_FILE:-}"
        if [ -z "$env_file" ]; then
          if [ -f ".env.pycharm" ]; then env_file=".env.pycharm"; else env_file=".env"; fi
        fi
        # Load environment if file exists
        set -a; [ -f "$env_file" ] && . "$env_file"; set +a
        echo "Using env file: $env_file"

        # Prefer local venv's python, fallback to system python
        py=".venv/bin/python"
        if [ ! -x "$py" ]; then py="python"; fi
        echo "Using python: $py"

        # Compute host/port from env with sensible defaults
        host="${NOETL_API_HOST:-${NOETL_HOST:-0.0.0.0}}"
        port="${NOETL_API_PORT:-${NOETL_PORT:-8083}}"
        echo "Server will bind to $host:$port"

        # Preflight: check if port is busy and kill existing process if found
        if command -v lsof >/dev/null 2>&1; then
          pids=$(lsof -t -i TCP:$port -sTCP:LISTEN || true)
          if [ -n "$pids" ]; then
            echo "Port $port is already in use by PID(s): $pids"
            echo "Killing existing process(es)..."
            kill $pids || true
            sleep 1
            for pid in $pids; do
              if kill -0 "$pid" 2>/dev/null; then
                echo "Force killing $pid"
                kill -9 "$pid" || true
              fi
            done
            echo "Waiting for port to be freed..."
            sleep 1
          fi
        fi

        # Run ASGI app via uvicorn factory; pass-through any extra CLI args (can override --port, --host, etc.)
        if "$py" -c "import uvicorn" >/dev/null 2>&1; then
          exec "$py" -m uvicorn noetl.server:create_app --factory --host "$host" --port "$port" --log-level debug {{.CLI_ARGS}}
        elif command -v uvicorn >/dev/null 2>&1; then
          exec uvicorn noetl.server:create_app --factory --host "$host" --port "$port" --log-level debug {{.CLI_ARGS}}
        else
          echo "uvicorn is not installed in the active interpreter or PATH."
          echo "Install it with one of:"
          echo "  uv add uvicorn"
          echo "  uv pip install uvicorn"
          exit 1
        fi

  server-kill-8083:
    desc: Kill any process listening on port 8083 (uses NOETL_API_PORT/NOETL_PORT if set)
    aliases: [sk83]
    cmds:
      - |
        set -e
        port="${NOETL_API_PORT:-${NOETL_PORT:-8083}}"
        if command -v lsof >/dev/null 2>&1; then
          pids=$(lsof -t -i TCP:$port -sTCP:LISTEN || true)
        elif command -v fuser >/dev/null 2>&1; then
          pids=$(fuser -n tcp $port 2>/dev/null || true)
        else
          echo "Neither lsof nor fuser found. Please install one."
          exit 1
        fi
        if [ -z "$pids" ]; then
          echo "No process is listening on port $port."
          exit 0
        fi
        echo "Killing PIDs on port $port: $pids"
        kill $pids || true
        sleep 1
        for pid in $pids; do
          if kill -0 "$pid" 2>/dev/null; then
            echo "Force killing $pid"
            kill -9 "$pid" || true
          fi
        done
        echo "Done."

  kill-port:
    desc: "Kill any process listening on the specified TCP port. Usage: task kill-port PORT=8090"
    vars:
      PORT: "{{ or .PORT (or (env \"PORT\") \"\") }}"
    cmds:
      - |
        set -e
        port="{{.PORT}}"
        if [ -z "$port" ]; then
          echo "PORT is required: task kill-port PORT=8090"
          exit 1
        fi
        if command -v lsof >/dev/null 2>&1; then
          pids=$(lsof -t -i TCP:$port -sTCP:LISTEN || true)
        elif command -v fuser >/dev/null 2>&1; then
          pids=$(fuser -n tcp $port 2>/dev/null || true)
        else
          echo "Neither lsof nor fuser found. Please install one."
          exit 1
        fi
        if [ -z "$pids" ]; then
          echo "No process is listening on port $port."
          exit 0
        fi
        echo "Killing PIDs on port $port: $pids"
        kill $pids || true
        sleep 1
        for pid in $pids; do
          if kill -0 "$pid" 2>/dev/null; then
            echo "Force killing $pid"
            kill -9 "$pid" || true
          fi
        done
        echo "Done."

  worker-debug:
    desc: Run NoETL worker in debug mode pointing to server on port 8083 (uses .env or .env.pycharm)
    aliases: [wdbg]
    cmds:
      - |
        set -e
        # Select env file: ENV_FILE overrides; otherwise prefer .env.pycharm if present; else .env
        env_file="${ENV_FILE:-}"
        if [ -z "$env_file" ]; then
          if [ -f ".env.pycharm" ]; then env_file=".env.pycharm"; else env_file=".env"; fi
        fi
        # Load environment if file exists
        set -a; [ -f "$env_file" ] && . "$env_file"; set +a

        # Ensure worker points to the local server on 8083 unless already provided
        : "${NOETL_API_URL:=http://localhost:8083}"
        export NOETL_API_URL

        # Ensure run mode is worker for the main dispatcher
        export NOETL_RUN_MODE=worker

        # Prefer local venv's python, fallback to system python
        py=".venv/bin/python"
        if [ ! -x "$py" ]; then py="python"; fi

        # Run worker via CLI (typer): 'noetl main worker start'; pass-through any extra CLI args
        exec "$py" -m noetl.main worker start {{.CLI_ARGS}}

