# db/pool.py
"""
PostgreSQL connection pool management.

This module provides:
1. Global pool for NoETL's internal database (server use)
2. Per-credential pool registry for plugin executions (worker use)
"""
from psycopg import AsyncConnection
from psycopg_pool import AsyncConnectionPool
from psycopg.rows import dict_row, DictRow
import hashlib
import os
import threading
from typing import Optional, Dict
from contextlib import asynccontextmanager
from noetl.core.logger import setup_logger

logger = setup_logger(__name__, include_location=True)

# Global pool for NoETL's internal database
_pool: Optional[AsyncConnectionPool[AsyncConnection[DictRow]]] = None
_pool_lock = threading.Lock()


def _env_int(name: str, default: int) -> int:
    raw = os.getenv(name)
    if raw is None or raw.strip() == "":
        return default
    try:
        return int(raw)
    except (TypeError, ValueError):
        return default


def _env_float(name: str, default: float) -> float:
    raw = os.getenv(name)
    if raw is None or raw.strip() == "":
        return default
    try:
        return float(raw)
    except (TypeError, ValueError):
        return default


_DEFAULT_POOL_MIN_SIZE = max(1, _env_int("NOETL_POSTGRES_POOL_MIN_SIZE", 4))
_DEFAULT_POOL_MAX_SIZE = max(_DEFAULT_POOL_MIN_SIZE, _env_int("NOETL_POSTGRES_POOL_MAX_SIZE", 48))
_DEFAULT_POOL_TIMEOUT = max(1.0, _env_float("NOETL_POSTGRES_POOL_TIMEOUT_SECONDS", 90.0))
_DEFAULT_POOL_MAX_WAITING = max(1, _env_int("NOETL_POSTGRES_POOL_MAX_WAITING", 2000))
_DEFAULT_POOL_MAX_LIFETIME = max(60.0, _env_float("NOETL_POSTGRES_POOL_MAX_LIFETIME_SECONDS", 1800.0))
_DEFAULT_POOL_MAX_IDLE = max(30.0, _env_float("NOETL_POSTGRES_POOL_MAX_IDLE_SECONDS", 300.0))


async def init_pool(conninfo: str):
    """
    Initialize the global AsyncConnectionPool with dict_row as default.
    Safe to call multiple times.

    Pool sizing is controlled by NOETL_POSTGRES_POOL_* env vars with safe defaults.
    """
    global _pool
    pool_to_open: Optional[AsyncConnectionPool[AsyncConnection[DictRow]]] = None

    # Use a thread lock instead of asyncio.Lock to avoid cross-event-loop binding.
    with _pool_lock:
        if _pool is None:
            logger.info(
                "DB.POOL: init min=%d max=%d waiting=%d timeout=%.1fs",
                _DEFAULT_POOL_MIN_SIZE,
                _DEFAULT_POOL_MAX_SIZE,
                _DEFAULT_POOL_MAX_WAITING,
                _DEFAULT_POOL_TIMEOUT,
            )
            _pool = AsyncConnectionPool(
                conninfo,
                min_size=_DEFAULT_POOL_MIN_SIZE,
                max_size=_DEFAULT_POOL_MAX_SIZE,
                max_waiting=_DEFAULT_POOL_MAX_WAITING,
                timeout=_DEFAULT_POOL_TIMEOUT,
                max_lifetime=_DEFAULT_POOL_MAX_LIFETIME,
                max_idle=_DEFAULT_POOL_MAX_IDLE,
                kwargs={"row_factory": dict_row},
                name=os.getenv("NOETL_POSTGRES_POOL_NAME", "noetl_server"),
                open=False,
            )
            pool_to_open = _pool

    if pool_to_open is not None:
        await pool_to_open.open(wait=True)


def get_pool() -> AsyncConnectionPool[AsyncConnection[DictRow]]:
    """Return AsyncConnectionPool with dict_row as default pool instance."""
    global _pool
    if _pool is None:
        raise RuntimeError("Database pool is not initialized. Call init_pool() first.")
    return _pool

@asynccontextmanager
async def get_pool_connection(timeout: float | None = None):
    """Get a connection from the global pool as an async context manager."""
    pool = get_pool()
    if timeout is None:
        async with pool.connection() as conn:
            yield conn
    else:
        async with pool.connection(timeout=timeout) as conn:
            yield conn


async def get_snowflake_id() -> int:
    """
    Generate a new snowflake ID using the database function noetl.snowflake_id().
    
    This ensures consistent ID generation across the system and allows
    the execution_id to be cached/shared for evaluation purposes.
    
    Returns:
        int: A unique snowflake ID generated by the database
    """
    async with get_pool_connection() as conn:
        async with conn.cursor() as cur:
            await cur.execute("SELECT noetl.snowflake_id()")
            result = await cur.fetchone()
            if result:
                return int(result['snowflake_id'])
            raise RuntimeError("Failed to generate snowflake ID from database")


async def close_pool():
    """Close and reset the global connection pool."""
    global _pool
    pool_to_close = None
    with _pool_lock:
        if _pool is not None:
            pool_to_close = _pool
            _pool = None
    if pool_to_close is not None:
        await pool_to_close.close()
