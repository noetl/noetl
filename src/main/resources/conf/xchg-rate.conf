// This script should do the following:
// 1. Request BTC/USD exchange rate from 3 different cryptocurrency exchanges using their public APIs. 
// The calls to exchanges shall be done in parallel.
// 2. Receive a response from each exchange and transform it to canonical data model.
// 3. Calculate average composite exchange rate using exchange rates from different exchanges.
// 4. Write the exchange rate into the database.

// process is a top-level action container that represents an execution flow
// each config file shall have one or more process objects
process {
	// id and name are two attribute that are present in every object by default
	id = "xchg-rate", // id MUST be unique within the file
	name = "xchg-rate", // name is optional, but helps with visual representation
	
	// description is optional, but provides valuable information to users
	description = "Retrieves BTC/USD exchange rate from 5 different exchanges, calculates an average and puts the latter into db",

	// parameters are key/value pairs that allows for parameterization of the process
	// the attribute may probably be renamed to inputData
	parameters = { "httpClientTimeout" = "${httpClientTimeout}" },

	// process starts from its startEvent
	// currently, a process supports exactly one startEvent
	// note: startEvent emits parameters of the process as its result/outputData
	startEvent {
		id = "0000",
		name = "Start",
	},


    // parallelGateway represents forks and joins of multiple flows executed in parallel.
	// gatewayDirection attribute denotes type:
	// "diverging" for forks and "converging" for joins.
	// parallelGateway copies input data to all of its outputs unchanged.
	parallelGateway {
		id = "0101",
		name = "",
		description = "
		gatewayDirection = "diverging", // only "diverging" or "converging"
	},
	// Actually, the above parallelGateway is not necessary in this process,
	// because multiple parallel tasks can diverge directly from startEvent,
	// but is depicted for clarity.


	// sequenceFlow is a line that connects exactly two elements of the process.
	// sequenceFlow carries data from its source to target as an opaque blob,
	// therefore sequenceFlow acts as a data pipeline from its source to target element.
	// If you are attentive enough, then you should remember that this particular sequenceFlow
	// carriers process parameters to its target (process -> startEvent -> sequenceFlow -> parallelGateway)
	sequenceFlow {
		id = "0000-0101",
		name = "",
		sourceRef = "0000",
		targetRef = "0101",
	},


	// webServiceTask calls a HTTP(S) URI to perform a task.
	// HTTP verbs shall be put into "httpMethod" attribute.
	// Parameters can be sent as:
	// a) part of URL for GET requests;
	// b) application/x-www-form-urlencoded for POST/PUT/PATCH/DELETE requests;
	// c) application/json for for POST/PUT/PATCH/DELETE requests.
	// Result format depends on the called service.
	// Parameters are supplied from its inbound sequenceFlow as inputData (rename to parameters?).
	// Result will be conveyed to outbound sequenceFlow as outputData (rename to results?).
	
	// CEX.io provides BTC/USD price as GET URI with result in JSON
	// Example: GET https://cex.io/api/last_price/BTC/USD
	webServiceTask {
		id = "1001",
		name = "CEX.io",
		description = "Request BTC/USD rate from CEX.io",
		httpClientTimeout = "${inputData.httpClientTimeout}",
		httpMethod = "GET",
		url = "https://cex.io/api/last_price/BTC/USD",
		outputData = ${responseBody}, // this sends http.body to the outbound sequenceFlow
	},
	
	// Hypothetical web service to transform CEX.io responses to canonical form.
	webServiceTask {
		id = "2001",
		name = "CEX.io-Transform"
		description = "Transforms answer from CEX.io to a canonical form",
		httpClientTimeout = "${inputData.httpClientTimeout}",
		httpMethod = "POST", // request method
		contentType = "application/json", // request content-type
		url = "https://localservice.noetl.io/transform-cexio",
		requestBody = "${inputData}", // data received from inbound sequenceFlow
		outputData = "${responseBody}", // canonical form is also JSON
	},

	// Bitfinex also provides tickets as GET URI with result as JSON:
	// GET https://api.bitfinex.com/v1/pubticker/btcusd
	webServiceTask {
		id = "1002",
		name = "Bitfinex",
		description = "Request BTC/USD rate from Bitfinex",
		httpClientTimeout = "${inputData.httpClientTimeout}",
		httpMethod = "GET",
		url = "https://api.bitfinex.com/v1/pubticker/btcusd",
		outputData = ${responseBody},
	},
	
	webServiceTask {
		id = "2002",
		name = "Bittrex-Transform"
		description = "Transforms answer from Bittrex to a canonical form",
		httpClientTimeout = "3s",
		httpMethod = "POST",
		url = "...",
		contentType = "application/json"
		contentBody = "{sequenceFlow.data}", // json from incoming sequenceFlow
	},

	webServiceTask {
		id = "1003",
		name = "Bitfinex",
		description = "Request BTC/USD rate from Bitfinex",
		httpClientTimeout = "3s",
		httpMethod = "POST",
		url = "...",
		formData = "", // POST form data
	},
	
	shellTask {
		id = "2003",
		name = "Bitfinex-Transform"
		description = "Transforms answer from Bitfinex to a canonical form",
		shellScript = "~/bin/"
		outputData = "stdin"
	},

	// the final destination of each process is the endEvent
	endEvent {
		id = "9999",
		name = "Finish",
	},

	
}
