// This script should do the following:
// 1. Request BTC/USD exchange rate from 3 different cryptocurrency exchanges using their public APIs. 
// The calls to exchanges shall be done in parallel.
// 2. Receive a response from each exchange and transform it to canonical data model.
// 3. Calculate average composite exchange rate using exchange rates from different exchanges.
// 4. Write the exchange rate into the database.

// Canonical representation of the BTC/USD exchange rate is a JSON object:
// {"BTC/USD":"9328.39","timestamp":"2018-04-30T19:51:12.876Z"}
// Note that the rate value MUST be quoted as string.

// process is a top-level action container that represents an execution flow
// each config file shall have one or more process objects
process {
	// id and name are two attribute that are present in every object by default
	id = "xchg-rate", // id MUST be unique within the file
	name = "xchg-rate", // name is optional, but helps with visual representation
	
	// description is optional, but provides valuable information to users
	description = "Retrieves BTC/USD exchange rate from 5 different exchanges, calculates an average and puts the latter into db",

	// parameters are key/value pairs that allows for parameterization of the process
	// the attribute may probably be renamed to inputData
	parameters = { "httpClientTimeout" = "${httpClientTimeout}" },

	// process starts from its startEvent
	// currently, a process supports exactly one startEvent
	// note: startEvent emits parameters of the process as its result/outputData
	startEvent {
		id = "0000",
		name = "Start",
	},


    // parallelGateway represents forks and joins of multiple flows executed in parallel.
	// gatewayDirection attribute denotes type:
	// "diverging" for forks and "converging" for joins.
	// parallelGateway copies input data to all of its outputs unchanged (fan-out).
	parallelGateway {
		id = "0101",
		name = "",
		description = "
		gatewayDirection = "diverging", // only "diverging" or "converging"
	},
	// Actually, the above parallelGateway is not necessary in this process,
	// because multiple parallel tasks can diverge directly from startEvent,
	// but is depicted for clarity.


    // sequenceFlow is a line that connects exactly two elements of the process.
	// sequenceFlow carries data from its source to target as an opaque blob,
	// therefore sequenceFlow acts as a data pipeline from its source to target element.
	// If you are attentive enough, then you should remember that this particular sequenceFlow
	// carriers process parameters to its target (process -> startEvent -> sequenceFlow -> parallelGateway)
	sequenceFlow {
		id = "0000-0101",
		name = "",
		sourceRef = "0000",
		targetRef = "0101",
	},


	// webServiceTask calls a HTTP(S) URI to perform a task.
	// HTTP verbs shall be put into "httpMethod" attribute.
	// Parameters can be sent as:
	// a) part of URL for GET requests;
	// b) application/x-www-form-urlencoded for POST/PUT/PATCH/DELETE requests;
	// c) application/json for for POST/PUT/PATCH/DELETE requests.
	// Result format depends on the called service.
	// Parameters are supplied from its inbound sequenceFlow as inputData (rename to parameters?).
	// Result will be conveyed to outbound sequenceFlow as outputData (rename to results?).
	
	// CEX.io provides BTC/USD price as GET URI with result in JSON
	// Example: GET https://cex.io/api/last_price/BTC/USD
	webServiceTask {
		id = "1001",
		name = "CEX.io",
		description = "Request BTC/USD rate from CEX.io",
		httpClientTimeout = "${inputData.httpClientTimeout}",
		httpMethod = "GET",
		url = "https://cex.io/api/last_price/BTC/USD",

		outputData = ${responseBody}, // this sends http.body to the outbound sequenceFlow
	},

	sequenceFlow {
		id = "0101-1001",
		name = "",
		sourceRef = "0101",
		targetRef = "1001",
	},

	// Hypothetical web service to transform CEX.io responses to canonical form.
	webServiceTask {
		id = "2001",
		name = "CEX.io-Transform"
		description = "Transforms answer from CEX.io to a canonical form",
		httpClientTimeout = "${inputData.httpClientTimeout}",
		httpMethod = "POST", // request method
		contentType = "application/json", // request content-type
		url = "https://localservice.noetl.io/transform-cexio",
		requestBody = "${inputData}", // data received from inbound sequenceFlow

		outputData = "${responseBody}", // canonical form is also JSON object
	},

	sequenceFlow {
		id = "1001-2001",
		name = "",
		sourceRef = "1001",
		targetRef = "2001",
	},


	// Bitfinex also provides tickets as GET URI with result as JSON:
	// GET https://api.bitfinex.com/v1/pubticker/btcusd
	webServiceTask {
		id = "1002",
		name = "Bitfinex",
		description = "Request BTC/USD rate from Bitfinex",
		httpClientTimeout = "${inputData.httpClientTimeout}",
		httpMethod = "GET",
		url = "https://api.bitfinex.com/v1/pubticker/btcusd",

		outputData = ${responseBody},
	},

	sequenceFlow {
		id = "0101-1002",
		name = "",
		sourceRef = "0101",
		targetRef = "1002",
	},

	// jdbcTask makes a call to a JDBC database.
	// Here we call a hypothetical PostgreSQL function that converts Bitfinex JSON to a canonical JSON form.
	jdbcTask {
		id = "2002",
		name = "Bitfinex-Transform"
		description = "Transforms answer from Bitfinex to a canonical form",
		databaseURL = "jdbc:postgresql://localhost/test?user=fred&password=secret&ssl=true",
		queryString = "SELECT public.bitfinex_to_canonical($1)"
		queryParams = [ ${inputData} ], // data received from inbound sequenceFlow
		
		outputData = ${queryResult}, // PostgreSQL can transform JSON!
	},

	sequenceFlow {
		id = "1002-2002",
		name = "",
		sourceRef = "1002",
		targetRef = "2002",
	},

	// HitBTC also provides BTC/USD ticket as JSON to GET request.
	// GET https://api.hitbtc.com/api/2/public/ticker/BTCUSD
	webServiceTask {
		id = "1003",
		name = "HitBTC",
		description = "Request BTC/USD rate from HitBTC",
		httpClientTimeout = "${inputData.httpClientTimeout}",
		httpMethod = "GET",
		url = "https://api.hitbtc.com/api/2/public/ticker/BTCUSD",
		
		outputData = ${responseBody}, // this sends http response body to the outbound sequenceFlow
	},

	sequenceFlow {
		id = "0101-1003",
		name = "",
		sourceRef = "0101",
		targetRef = "1003",
	},


	// shellTask invokes local shell, which means:
	// a) the engine must execute on Linux/Unix machine;
	// b) commands must be specific only to local host.
	shellTask {
		id = "2003",
		name = "HitBTC-Transform"
		description = "Transforms answer from HitBTC to a canonical form",

		shellScript = "/usr/local/bin/transform-hitbtc",
		// each element of scriptParams array shall be supplied to shellScript as a parameter beginning from $1 = [0]
		scriptParams = [ "${inputData}" ], 
		
		outputData = "${stdout}", // shell's stdout will be copied to the outbound sequenceFlow
	},
	
	sequenceFlow {
		id = "1003-2003",
		name = "",
		sourceRef = "1003",
		targetRef = "2003",
	},

	// Again parallelGateway, but this time for joining flows.
	// Converging parallelGateway combines all inputData from sequenceFlows as an array:
	// outputData = [ inputData1, inputData2, ... ]
	parallelGateway {
		id = "3001",
		name = "",
		description = ""
		gatewayDirection = "converging", // only "diverging" or "converging"		
	},
	// The outputData of this converging parallelGateway must be a JSON array of canonical rates:
	// [{"BTC/USD":"9328.39","timestamp":"2018-04-30T19:51:12.876Z"},
	//  {"BTC/USD":"9666.88","timestamp":"2018-04-30T19:51:13.567Z"},
	//  {"BTC/USD":"9481.39","timestamp":"2018-04-30T19:51:13.218Z"}]

	// sshTash is essentially a shellTask that must be executed on a remote host via SSH.
	// The following sshTask executes a remote script to calculate an average BTC/USD rate.
	sshTask {
		id = "4001",
		name = "Calc-average",
		description = "Calculates average BTC/USD rate on a remote host",
		
		sshHost = "scripthost.noetl.io",
		sshPort = "22", // note string here, not number!
		sshUser = "scripter",
		// Specify a key pair file as SSH identity_file parameter (ssh -i) - see "man ssh".
		// Using password in sshTask is wrong and must be discouraged.
		sshIdentityFile = "/home/noetl/ssh-keys/scripthost.pem", // key pair file must reside in local file system
		
		shellScript = "/usr/local/bin/calc-average", // on the remote host
		scriptParams = "${inputData}", // the array of three BTC/USD rates
	}
	
	sequenceFlow {
		id = "3001-4001",
		name = "",
		sourceRef = "3001",
		targetRef = "4001",
	},
	
	// Notice no outputData from the above sshTask?
	// That is because stupid `/usr/local/bin/calc-average` on the scripthost.noetl.io
	// leaves the result in the file "/usr/local/var/calc-average/current-rate"!
	// No problem, we will get the file from the remote host (though we could just `cat` it from there).
	
	// scpTask securely copies files using SSH protocol.
	scpTask {
		id = "4002",
		name = "Transfer-average",
		description = "Transfers the average result from remote host to local machine",
		
		sourceHost = "scripthost.noetl.io",
		sourcePort = "22", // note string here, not number!
		sourceUser = "scripter",
		sourceIdentifyFile = "/home/noetl/ssh-keys/scripthost.pem", // key pair file must reside in local file system
		sourcePath = "/usr/local/var/calc-average/current-rate", // that file, yeah! 
		
		targetHost = "localhost",
		// no targetPort, targetUser, targetIdentityFile are necessary for "localhost"
		targetPath = "/usr/local/var/calc-average/", // directory name is enough
		overwriteTarget = "always", // "always", "newer", "never" are sane options
	}

	sequenceFlow {
		id = "4001-4002",
		name = "",
		sourceRef = "4001",
		targetRef = "4002",
	},

	// No outputData again?! 
	// That is because scpTask produces no output data, it is a copy procedure and returns no result.
	// Let's print the file and get the rate!
	shellTask {
		id = "4003",
		name = "Print-rate"
		description = "Prints average BTC/USD rate in the canonical form",

		shellScript = "cat /usr/local/var/calc-average/current-rate", // local file, remember?
		outputData = "${stdout}", // shell's stdout will be copied to the outbound sequenceFlow
	}
	// outputData shall be a JSON object like following:
	// {"BTC/USD":"9666.88","timestamp":"2018-04-30T19:51:13.567Z"}

	sequenceFlow {
		id = "4002-4003",
		name = "",
		sourceRef = "4002",
		targetRef = "4003",
	},

	// Finally, let's write the result into the database.
	// Luckily, PostgreSQL accepts and parses JSON as input.
	jdbcTask {
		id = "5555",
		name = "Save-to-database"
		description = "Saves the average BTC/USD rate to database",
		// need to decide how to put passwords into config files
		databaseURL = "jdbc:postgresql://localhost/test?user=fred&password=secret&ssl=true",
		queryString = "SELECT public.append_btc_usd_rate($1::json)"
		queryParams = [ ${inputData} ], // data received from inbound sequenceFlow
		
		outputData = ${queryResult}, // just in case, receive confimation from the database
	},

	sequenceFlow {
		id = "4003-5555",
		name = "",
		sourceRef = "4003",
		targetRef = "5555",
	},

	// The final destination of each process is the endEvent.
	endEvent {
		id = "9999",
		name = "Finish",
	},

	sequenceFlow {
		id = "5555-9999",
		name = "",
		sourceRef = "5555",
		targetRef = "9999",
	},
	
	// Exactly as with input parameters of the process, the outputData of endEvent becomes the outputData of the process.
	// jdbcTask -> endEvent -> process

}
