## this config file is HACON formated https://github.com/lightbend/config/blob/master/HOCON.md

// This script should do the following:
// 1. Request BTC/USD exchange rate from 3 different cryptocurrency exchanges using their public APIs. 
// The calls to exchanges shall be done in parallel.
// 2. Receive a response from each exchange and transform it to canonical data model.
// 3. Calculate average composite exchange rate using exchange rates from different exchanges.
// 4. Write the exchange rate into the database.

// Canonical representation of the BTC/USD exchange rate is a JSON object:
// {"BTC/USD":"9328.39","timestamp":"2018-04-30T19:51:12.876Z"}
// Note that the rate value MUST be quoted as string.

// process is a top-level action container that represents an execution flow
// each config file shall have one or more process objects

	// process id and name are two attribute that are present in every object by default
process.id = "xchg-rate" // id MUST be unique within the file
process.name = "xchg-rate" // name is optional, but helps with visual representation
	
	// description is optional, but provides valuable information to users
process.description = "Retrieves BTC/USD exchange rate from 5 different exchanges, calculates an average and puts the latter into db",

	// parameters are key/value pairs that allows for parameterization of the process
	// the attribute may probably be renamed to inputData
process.parameters.httpClientTimeout = ${httpClientTimeout}

	// process starts from its startEvent
	// currently, a process supports exactly one startEvent
	// note: startEvent emits parameters of the process as its result/outputData
process.startEvent.id = "0000"
process.startEvent.name = "Start"


    // parallelGateway represents forks and joins of multiple flows executed in parallel.
	// gatewayDirection attribute denotes type:
	// "diverging" for forks and "converging" for joins.
	// parallelGateway copies input data to all of its outputs unchanged (fan-out).
process.parallelGateway.id = "0101"
process.parallelGateway.name = ""
process.parallelGateway.description = "
process.parallelGateway.gatewayDirection = "diverging" // only "diverging" or "converging"

	// Actually, the above parallelGateway is not necessary in this process,
	// because multiple parallel tasks can diverge directly from startEvent,
	// but is depicted for clarity.


    // sequenceFlow is a line that connects exactly two elements of the process.
	// sequenceFlow carries data from its source to target as an opaque blob,
	// therefore sequenceFlow acts as a data pipeline from its source to target element.
	// If you are attentive enough, then you should remember that this particular sequenceFlow
	// carriers process parameters to its target (process -> startEvent -> sequenceFlow -> parallelGateway)
process.sequenceFlow.id = "0000-0101"
process.sequenceFlow.name = ""
process.sequenceFlow.sourceRef = "0000"
process.sequenceFlow.targetRef = "0101"


	// webServiceTask calls a HTTP(S) URI to perform a task.
	// HTTP verbs shall be put into "httpMethod" attribute.
	// Parameters can be sent as:
	// a) part of URL for GET requests;
	// b) application/x-www-form-urlencoded for POST/PUT/PATCH/DELETE requests;
	// c) application/json for for POST/PUT/PATCH/DELETE requests.
	// Result format depends on the called service.
	// Parameters are supplied from its inbound sequenceFlow as inputData (rename to parameters?).
	// Result will be conveyed to outbound sequenceFlow as outputData (rename to results?).
	
	// CEX.io provides BTC/USD price as GET URI with result in JSON
	// Example: GET https://cex.io/api/last_price/BTC/USD
process.webServiceTask.id = "1001"
process.webServiceTask.name = "CEX.io"
process.webServiceTask.description = "Request BTC/USD rate from CEX.io"
process.webServiceTask.httpClientTimeout = "${inputData.httpClientTimeout}"
process.webServiceTask.httpMethod = "GET"
process.webServiceTask.url = "https://cex.io/api/last_price/BTC/USD"
process.webServiceTask.outputData = ${responseBody} // this sends http.body to the outbound sequenceFlow


process.sequenceFlow.id = "0101-1001"
process.sequenceFlow.name = ""
process.sequenceFlow.sourceRef = "0101"
process.sequenceFlow.targetRef = "1001"

	// Hypothetical web service to transform CEX.io responses to canonical form.

process.webServiceTask.id = "2001"
process.webServiceTask.name = "CEX.io-Transform"
process.webServiceTask.description = "Transforms answer from CEX.io to a canonical form"
process.webServiceTask.httpClientTimeout = "${inputData.httpClientTimeout}"
process.webServiceTask.httpMethod = "POST", // request method
process.webServiceTask.contentType = "application/json" // request content-type
process.webServiceTask.url = "https://localservice.noetl.io/transform-cexio"
process.webServiceTask.requestBody = "${inputData}" // data received from inbound sequenceFlow
process.webServiceTask.outputData = "${responseBody}" // canonical form is also JSON object


process.sequenceFlow.id = "1001-2001"
process.sequenceFlow.name = ""
process.sequenceFlow.sourceRef = "1001"
process.sequenceFlow.targetRef = "2001"


	// Bitfinex also provides tickets as GET URI with result as JSON:
	// GET https://api.bitfinex.com/v1/pubticker/btcusd

process.webServiceTask.id = "1002"
process.webServiceTask.name = "Bitfinex"
process.webServiceTask.description = "Request BTC/USD rate from Bitfinex"
process.webServiceTask.httpClientTimeout = "${inputData.httpClientTimeout}"
process.webServiceTask.httpMethod = "GET",
process.webServiceTask.url = "https://api.bitfinex.com/v1/pubticker/btcusd"
process.webServiceTask.outputData = ${responseBody}

process.sequenceFlow.id = "0101-1002"
process.sequenceFlow.name = ""
process.sequenceFlow.sourceRef = "0101"
process.sequenceFlow.targetRef = "1002"

	// jdbcTask makes a call to a JDBC database.
	// Here we call a hypothetical PostgreSQL function that converts Bitfinex JSON to a canonical JSON form.

process.jdbcTask.id = "2002"
process.jdbcTask.name = "Bitfinex-Transform"
process.jdbcTask.description = "Transforms answer from Bitfinex to a canonical form"
process.jdbcTask.databaseURL = "jdbc:postgresql://localhost/test?user=fred&password=secret&ssl=true"
process.jdbcTask.queryString = "SELECT public.bitfinex_to_canonical($1)"
process.jdbcTask.queryParams = [ ${inputData} ] // data received from inbound sequenceFlow
process.jdbcTask.outputData = ${queryResult} // PostgreSQL can transform JSON!


process.sequenceFlow.id = "1002-2002"
process.sequenceFlow.name = ""
process.sequenceFlow.sourceRef = "1002"
process.sequenceFlow.targetRef = "2002"

	// HitBTC also provides BTC/USD ticket as JSON to GET request.
	// GET https://api.hitbtc.com/api/2/public/ticker/BTCUSD
process.webServiceTask.id = "1003"
process.webServiceTask.name = "HitBTC"
process.webServiceTask.description = "Request BTC/USD rate from HitBTC"
process.webServiceTask.httpClientTimeout = "${inputData.httpClientTimeout}"
process.webServiceTask.httpMethod = "GET"
process.webServiceTask.url = "https://api.hitbtc.com/api/2/public/ticker/BTCUSD"
process.webServiceTask.outputData = ${responseBody} // this sends http response body to the outbound sequenceFlow


process.sequenceFlow.id = "0101-1003"
process.sequenceFlow.name = ""
process.sequenceFlow.sourceRef = "0101"
process.sequenceFlow.targetRef = "1003"


	// shellTask invokes local shell, which means:
	// a) the engine must execute on Linux/Unix machine;
	// b) commands must be specific only to local host.
process.shellTask.id = "2003"
process.shellTask.name = "HitBTC-Transform"
process.shellTask.description = "Transforms answer from HitBTC to a canonical form"
process.shellTask.shellScript = "/usr/local/bin/transform-hitbtc"
		// each element of scriptParams array shall be supplied to shellScript as a parameter beginning from $1 = [0]
process.shellTask.scriptParams = [ "${inputData}" ]
process.shellTask.outputData = "${stdout}" // shell's stdout will be copied to the outbound sequenceFlow

process.sequenceFlow.id = "1003-2003"
process.sequenceFlow.name = ""
process.sequenceFlow.sourceRef = "1003"
process.sequenceFlow.targetRef = "2003"

	// Again parallelGateway, but this time for joining flows.
	// Converging parallelGateway combines all inputData from sequenceFlows as an array:
	// outputData = [ inputData1, inputData2, ... ]
process.parallelGateway.id = "3001"
process.parallelGateway.name = ""
process.parallelGateway.description = ""
process.parallelGateway.gatewayDirection = "converging" // only "diverging" or "converging"

	// The outputData of this converging parallelGateway must be a JSON array of canonical rates:
	// [{"BTC/USD":"9328.39","timestamp":"2018-04-30T19:51:12.876Z"},
	//  {"BTC/USD":"9666.88","timestamp":"2018-04-30T19:51:13.567Z"},
	//  {"BTC/USD":"9481.39","timestamp":"2018-04-30T19:51:13.218Z"}]

	// sshTash is essentially a shellTask that must be executed on a remote host via SSH.
	// The following sshTask executes a remote script to calculate an average BTC/USD rate.
process.sshTask.id = "4001"
process.sshTask.name = "Calc-average"
process.sshTask.description = "Calculates average BTC/USD rate on a remote host"
process.sshTask.sshHost = "scripthost.noetl.io"
process.sshTask.sshPort = "22" // note string here, not number!
process.sshTask.sshUser = "scripter"
		// Specify a key pair file as SSH identity_file parameter (ssh -i) - see "man ssh".
		// Using password in sshTask is wrong and must be discouraged.
process.sshTask.sshIdentityFile = "/home/noetl/ssh-keys/scripthost.pem" // key pair file must reside in local file system
process.sshTask.shellScript = "/usr/local/bin/calc-average" // on the remote host
process.sshTask.scriptParams = "${inputData}" // the array of three BTC/USD rates


process.sequenceFlow.id = "3001-4001"
process.sequenceFlow.name = ""
process.sequenceFlow.sourceRef = "3001"
process.sequenceFlow.targetRef = "4001"
	
	// Notice no outputData from the above sshTask?
	// That is because stupid `/usr/local/bin/calc-average` on the scripthost.noetl.io
	// leaves the result in the file "/usr/local/var/calc-average/current-rate"!
	// No problem, we will get the file from the remote host (though we could just `cat` it from there).
	
	// scpTask securely copies files using SSH protocol.
process.scpTask.id = "4002"
process.scpTask.name = "Transfer-average"
process.scpTask.description = "Transfers the average result from remote host to local machine"
process.scpTask.sourceHost = "scripthost.noetl.io"
process.scpTask.sourcePort = "22" // note string here, not number!
process.scpTask.sourceUser = "scripter"
process.scpTask.sourceIdentifyFile = "/home/noetl/ssh-keys/scripthost.pem" // key pair file must reside in local file system
process.scpTask.sourcePath = "/usr/local/var/calc-average/current-rate" // that file, yeah!
process.scpTask.targetHost = "localhost"
		// no targetPort, targetUser, targetIdentityFile are necessary for "localhost"
process.scpTask.targetPath = "/usr/local/var/calc-average/" // directory name is enough
process.scpTask.overwriteTarget = "always" // "always", "newer", "never" are sane options


process.sequenceFlow.id = "4001-4002"
process.sequenceFlow.name = ""
process.sequenceFlow.sourceRef = "4001"
process.sequenceFlow.targetRef = "4002"

	// No outputData again?! 
	// That is because scpTask produces no output data, it is a copy procedure and returns no result.
	// Let's print the file and get the rate!

process.shellTask.id = "4003"
process.shellTask.name = "Print-rate"
process.shellTask.description = "Prints average BTC/USD rate in the canonical form"
process.shellTask.shellScript = "cat /usr/local/var/calc-average/current-rate", // local file, remember?
process.shellTask.outputData = "${stdout}", // shell's stdout will be copied to the outbound sequenceFlow

	// outputData shall be a JSON object like following:
	// {"BTC/USD":"9666.88","timestamp":"2018-04-30T19:51:13.567Z"}


process.sequenceFlow.id = "4002-4003"
process.sequenceFlow.name = ""
process.sequenceFlow.sourceRef = "4002"
process.sequenceFlow.targetRef = "4003"

	// Finally, let's write the result into the database.
	// Luckily, PostgreSQL accepts and parses JSON as input.

process.jdbcTask.id = "5555"
process.jdbcTask.name = "Save-to-database"
process.jdbcTask.description = "Saves the average BTC/USD rate to database"
		// need to decide how to put passwords into config files
process.jdbcTask.databaseURL = "jdbc:postgresql://localhost/test?user=fred&password=secret&ssl=true"
process.jdbcTask.queryString = "SELECT public.append_btc_usd_rate($1::json)"
process.jdbcTask.queryParams = [ ${inputData} ] // data received from inbound sequenceFlow
process.jdbcTask.outputData = ${queryResult} // just in case, receive confimation from the database


process.sequenceFlow.id = "4003-5555"
process.sequenceFlow.name = ""
process.sequenceFlow.sourceRef = "4003"
process.sequenceFlow.targetRef = "5555"

	// The final destination of each process is the endEvent.

process.endEvent.id = "9999"
process.endEvent.name = "Finish"


process.sequenceFlow.id = "5555-9999"
process.sequenceFlow.name = ""
process.sequenceFlow.sourceRef = "5555"
process.sequenceFlow.targetRef = "9999"
	
	// Exactly as with input parameters of the process, the outputData of endEvent becomes the outputData of the process.
	// jdbcTask -> endEvent -> process

