version: '3.45'

tasks:
  server-debug:
    desc: Run NoETL server in debug mode as a background daemon with logging
    aliases: [sdbg]
    cmds:
      - |
        set -e
        mkdir -p logs

        # Select env file: ENV_FILE overrides; otherwise prefer .env.pycharm if present; else .env
        env_file="${ENV_FILE:-}"
        if [ -z "$env_file" ]; then
          if [ -f ".env.pycharm" ]; then env_file=".env.pycharm"; else env_file=".env"; fi
        fi
        # Load environment if file exists
        set -a; [ -f "$env_file" ] && . "$env_file"; set +a
        echo "Using env file: $env_file"

        # Prefer local venv's python, fallback to system python
        py=".venv/bin/python"
        if [ ! -x "$py" ]; then py="python"; fi
        echo "Using python: $py"

        # Compute host/port from env with sensible defaults
        host="${NOETL_API_HOST:-${NOETL_HOST:-0.0.0.0}}"
        port="${NOETL_API_PORT:-${NOETL_PORT:-8083}}"
        echo "Server will bind to $host:$port"

        # Preflight: check if port is busy and kill existing process if found
        if command -v lsof >/dev/null 2>&1; then
          pids=$(lsof -t -i TCP:$port -sTCP:LISTEN || true)
          if [ -n "$pids" ]; then
            echo "Port $port is already in use by PID(s): $pids"
            echo "Killing existing process(es)..."
            kill $pids || true
            sleep 1
            for pid in $pids; do
              if kill -0 "$pid" 2>/dev/null; then
                echo "Force killing $pid"
                kill -9 "$pid" || true
              fi
            done
            echo "Waiting for port to be freed..."
            sleep 1
          fi
        fi

        # Run ASGI app via uvicorn factory in background; pass-through any extra CLI args
        logfile="logs/server-debug.log"
        pidfile="logs/server-debug.pid"

        if "$py" -c "import uvicorn" >/dev/null 2>&1; then
          bash -c "exec \"$py\" -m uvicorn noetl.server:create_app --factory --host \"$host\" --port \"$port\" --log-level debug > \"$logfile\" 2>&1 & echo \$! > \"$pidfile\""
          server_pid=$(cat "$pidfile")
        elif command -v uvicorn >/dev/null 2>&1; then
          bash -c "exec uvicorn noetl.server:create_app --factory --host \"$host\" --port \"$port\" --log-level debug > \"$logfile\" 2>&1 & echo \$! > \"$pidfile\""
          server_pid=$(cat "$pidfile")
        else
          echo "uvicorn is not installed in the active interpreter or PATH."
          echo "Install it with one of:"
          echo "  uv add uvicorn"
          echo "  uv pip install uvicorn"
          exit 1
        fi
        echo "Server started with PID $server_pid"
        echo "Logs: $logfile"
        echo "PID file: $pidfile"
        echo "To stop: task server-debug-stop"
        sleep 2
        if kill -0 $server_pid 2>/dev/null; then
          echo "Server is running on $host:$port"
        else
          echo "Server failed to start. Check logs: $logfile"
          exit 1
        fi

  server-debug-stop:
    desc: Stop the background NoETL server debug process
    aliases: [sdbg-stop]
    cmds:
      - |
        pidfile="logs/server-debug.pid"
        if [ ! -f "$pidfile" ]; then
          echo "No PID file found at $pidfile"
          echo "Server may not be running or was started differently"
          exit 0
        fi
        pid=$(cat "$pidfile")
        if [ -z "$pid" ]; then
          echo "PID file is empty"
          rm -f "$pidfile"
          exit 0
        fi
        if kill -0 "$pid" 2>/dev/null; then
          echo "Stopping server (PID $pid)..."
          kill "$pid" || true
          sleep 2
          if kill -0 "$pid" 2>/dev/null; then
            echo "Force killing server..."
            kill -9 "$pid" || true
          fi
          echo "Server stopped"
        else
          echo "Server (PID $pid) is not running"
        fi
        rm -f "$pidfile"

  server-kill-8083:
    desc: Kill any process listening on port 8083 (uses NOETL_API_PORT/NOETL_PORT if set)
    aliases: [sk83]
    cmds:
      - |
        set -e
        port="${NOETL_API_PORT:-${NOETL_PORT:-8083}}"
        if command -v lsof >/dev/null 2>&1; then
          pids=$(lsof -t -i TCP:$port -sTCP:LISTEN || true)
        elif command -v fuser >/dev/null 2>&1; then
          pids=$(fuser -n tcp $port 2>/dev/null || true)
        else
          echo "Neither lsof nor fuser found. Please install one."
          exit 1
        fi
        if [ -z "$pids" ]; then
          echo "No process is listening on port $port."
          exit 0
        fi
        echo "Killing PIDs on port $port: $pids"
        kill $pids || true
        sleep 1
        for pid in $pids; do
          if kill -0 "$pid" 2>/dev/null; then
            echo "Force killing $pid"
            kill -9 "$pid" || true
          fi
        done
        echo "Done."

  kill-port:
    desc: "Kill any process listening on the specified TCP port. Usage: task kill-port PORT=8090"
    vars:
      PORT: "{{ or .PORT (or (env \"PORT\") \"\") }}"
    cmds:
      - |
        set -e
        port="{{.PORT}}"
        if [ -z "$port" ]; then
          echo "PORT is required: task kill-port PORT=8090"
          exit 1
        fi
        if command -v lsof >/dev/null 2>&1; then
          pids=$(lsof -t -i TCP:$port -sTCP:LISTEN || true)
        elif command -v fuser >/dev/null 2>&1; then
          pids=$(fuser -n tcp $port 2>/dev/null || true)
        else
          echo "Neither lsof nor fuser found. Please install one."
          exit 1
        fi
        if [ -z "$pids" ]; then
          echo "No process is listening on port $port."
          exit 0
        fi
        echo "Killing PIDs on port $port: $pids"
        kill $pids || true
        sleep 1
        for pid in $pids; do
          if kill -0 "$pid" 2>/dev/null; then
            echo "Force killing $pid"
            kill -9 "$pid" || true
          fi
        done
        echo "Done."

  worker-debug:
    desc: Run NoETL worker in debug mode as a background daemon with logging
    aliases: [wdbg]
    cmds:
      - |
        set -e
        mkdir -p logs

        # Select env file: ENV_FILE overrides; otherwise prefer .env.pycharm if present; else .env
        env_file="${ENV_FILE:-}"
        if [ -z "$env_file" ]; then
          if [ -f ".env.pycharm" ]; then env_file=".env.pycharm"; else env_file=".env"; fi
        fi
        # Load environment if file exists
        set -a; [ -f "$env_file" ] && . "$env_file"; set +a
        echo "Using env file: $env_file"

        # Ensure worker points to the local server on 8083 unless already provided
        : "${NOETL_API_URL:=http://localhost:8083}"
        export NOETL_API_URL

        # Ensure run mode is worker for the main dispatcher
        export NOETL_RUN_MODE=worker

        # Prefer local venv's python, fallback to system python
        py=".venv/bin/python"
        if [ ! -x "$py" ]; then py="python"; fi
        echo "Using python: $py"

        # Run worker via CLI in background; pass-through any extra CLI args
        logfile="logs/worker-debug.log"
        pidfile="logs/worker-debug.pid"

        bash -c "exec \"$py\" -m noetl.main worker start > \"$logfile\" 2>&1 & echo \$! > \"$pidfile\""
        worker_pid=$(cat "$pidfile")
        echo "Worker started with PID $worker_pid"
        echo "Logs: $logfile"
        echo "PID file: $pidfile"
        echo "To stop: task worker-debug-stop"
        sleep 2
        if kill -0 $worker_pid 2>/dev/null; then
          echo "Worker is running"
        else
          echo "Worker failed to start. Check logs: $logfile"
          exit 1
        fi

  worker-debug-stop:
    desc: Stop the background NoETL worker debug process
    aliases: [wdbg-stop]
    cmds:
      - |
        pidfile="logs/worker-debug.pid"
        if [ ! -f "$pidfile" ]; then
          echo "No PID file found at $pidfile"
          echo "Worker may not be running or was started differently"
          exit 0
        fi
        pid=$(cat "$pidfile")
        if [ -z "$pid" ]; then
          echo "PID file is empty"
          rm -f "$pidfile"
          exit 0
        fi
        if kill -0 "$pid" 2>/dev/null; then
          echo "Stopping worker (PID $pid)..."
          kill "$pid" || true
          sleep 2
          if kill -0 "$pid" 2>/dev/null; then
            echo "Force killing worker..."
            kill -9 "$pid" || true
          fi
          echo "Worker stopped"
        else
          echo "Worker (PID $pid) is not running"
        fi
        rm -f "$pidfile"

  debug-stop-all:
    desc: Stop both server and worker debug processes
    aliases: [stop-all]
    cmds:
      - task: server-debug-stop
      - task: worker-debug-stop

  debug-kill-all:
    desc: Force kill ALL noetl server and worker processes (including orphaned ones)
    aliases: [kill-all]
    cmds:
      - |
        echo "Searching for all noetl processes..."

        # Find and kill server processes
        server_pids=$(ps aux | grep -E "uvicorn.*noetl.server" | grep -v grep | awk '{print $2}')
        if [ -n "$server_pids" ]; then
          echo "Found server processes: $server_pids"
          for pid in $server_pids; do
            echo "Killing server PID $pid..."
            kill -9 "$pid" 2>/dev/null || true
          done
        else
          echo "No server processes found"
        fi

        # Find and kill worker processes
        worker_pids=$(ps aux | grep -E "noetl.main worker" | grep -v grep | awk '{print $2}')
        if [ -n "$worker_pids" ]; then
          echo "Found worker processes: $worker_pids"
          for pid in $worker_pids; do
            echo "Killing worker PID $pid..."
            kill -9 "$pid" 2>/dev/null || true
          done
        else
          echo "No worker processes found"
        fi

        # Clean up PID files
        rm -f logs/server-debug.pid logs/worker-debug.pid
        echo "Done. All noetl processes killed and PID files cleaned up."

  debug-status:
    desc: Check status of server and worker debug processes
    aliases: [status]
    cmds:
      - |
        echo "=== Debug Process Status ==="
        echo ""

        # Check server
        server_pidfile="logs/server-debug.pid"
        if [ -f "$server_pidfile" ]; then
          server_pid=$(cat "$server_pidfile")
          if kill -0 "$server_pid" 2>/dev/null; then
            echo "‚úì Server (PID $server_pid) is RUNNING"
            echo "  Logs: logs/server-debug.log"
          else
            echo "‚úó Server (PID $server_pid) is NOT running"
          fi
        else
          echo "‚úó Server: No PID file found"
        fi

        echo ""

        # Check worker
        worker_pidfile="logs/worker-debug.pid"
        if [ -f "$worker_pidfile" ]; then
          worker_pid=$(cat "$worker_pidfile")
          if kill -0 "$worker_pid" 2>/dev/null; then
            echo "‚úì Worker (PID $worker_pid) is RUNNING"
            echo "  Logs: logs/worker-debug.log"
          else
            echo "‚úó Worker (PID $worker_pid) is NOT running"
          fi
        else
          echo "‚úó Worker: No PID file found"
        fi

        echo ""
        echo "Commands:"
        echo "  task server-debug-stop  - Stop server"
        echo "  task worker-debug-stop  - Stop worker"
        echo "  task debug-stop-all     - Stop both"

  noetl-local-start:
    desc: Start both NoETL server and worker in debug mode locally
    aliases: [local-start, lstart]
    cmds:
      - task: server-debug
      - echo "Waiting 5 seconds for server to be ready..."
      - sleep 5
      - task: worker-debug
      - echo ""
      - echo "=== NoETL Local Stack Started ==="
      - echo "Server - http://localhost:8083"
      - echo "API Docs - http://localhost:8083/docs"
      - echo ""
      - echo "Logs -"
      - echo "  Server - logs/server-debug.log"
      - echo "  Worker - logs/worker-debug.log"
      - echo ""
      - echo "Commands -"
      - echo "  task debug-status       - Check status"
      - echo "  task debug-stop-all     - Stop both"
      - echo "  tail -f logs/server-debug.log  - Follow server logs"
      - echo "  tail -f logs/worker-debug.log  - Follow worker logs"

  ui-dev:
    desc: Start the NoETL UI locally (Vite dev server) and auto-connect to local API
    aliases: [ui, ui-start]
    dir: ui-src
    cmds:
      - |
        set -e
        echo "Starting NoETL UI (Vite)"

        # Quick sanity check: ensure we're in the UI folder
        if [ ! -f package.json ]; then
          echo "package.json not found in $(pwd). Are you missing the ui-src folder?"
          echo "Expected to run in noetl/ui-src."
          exit 1
        fi

        # Install deps if missing
        if [ ! -d node_modules ]; then
          echo "node_modules not found; installing dependencies"
          if ! command -v npm >/dev/null 2>&1; then
            echo "npm is not installed. Please install Node.js and npm."
            exit 1
          fi
          echo "npm version: $(npm --version 2>/dev/null || echo unknown)"
          if [ -f package-lock.json ]; then
            echo "Using package-lock.json -> running: npm ci"
            npm ci
          else
            echo "No package-lock.json -> running: npm install"
            npm install
          fi
        fi

        # Determine API base URL - always use local server on port 8083
        if [ -n "$VITE_API_BASE_URL" ]; then
          api_url="$VITE_API_BASE_URL"
          echo "Using VITE_API_BASE_URL from env: $api_url"
        else
          # Use local server on port 8083 with /api prefix
          api_url="http://localhost:8083/api"
          echo "Using local NoETL server: $api_url"
          
          # Check if server is running (check base URL without /api)
          base_url="http://localhost:8083"
          if command -v curl >/dev/null 2>&1; then
            if ! curl -s -m 2 -f "$base_url/health" >/dev/null 2>&1; then
              echo "WARNING: NoETL server not responding at $base_url"
              echo "Make sure to start the server first with: task server-debug"
            else
              echo "‚úì NoETL server is running at $base_url"
            fi
          fi
        fi

        export VITE_API_BASE_URL="$api_url"
        echo "Launching UI with VITE_API_BASE_URL=$VITE_API_BASE_URL"
        npm run dev

  noetl-local-setup-test-environment:
    desc: Setup test environment using local NoETL service on port 8083 - reset postgres, register credentials and playbooks
    aliases: [local-setup-test, lste]
    cmds:
      - |
        set -e
        echo "=== Setting up test environment using local NoETL service (port 8083) ==="
        
        # Check if local server is running
        echo "Checking if NoETL server is running on port 8083..."
        if ! curl -s -m 2 -f "http://localhost:8083/health" >/dev/null 2>&1; then
          echo "ERROR: NoETL server is not running on port 8083"
          echo "Please start the server first with: task server-debug"
          exit 1
        fi
        echo "‚úì NoETL server is running"
        
        # Reset postgres schema
        echo "Resetting PostgreSQL schema..."
        task postgres-reset-schema
        echo "‚úì PostgreSQL schema reset completed"
        
        # Wait a moment for schema to be ready
        sleep 3
        
        # Register test credentials using local server
        echo "Registering test credentials..."
        if command -v jq >/dev/null 2>&1; then
          curl -sS -X POST "http://localhost:8083/api/credentials" \
            -H 'Content-Type: application/json' \
            --data-binary @tests/fixtures/credentials/pg_local.json | jq -C . || echo "pg_local credential registration failed"
          curl -sS -X POST "http://localhost:8083/api/credentials" \
            -H 'Content-Type: application/json' \
            --data-binary @tests/fixtures/credentials/gcs_hmac_local.json | jq -C . || echo "gcs_hmac_local credential registration failed"
        else
          curl -sS -X POST "http://localhost:8083/api/credentials" \
            -H 'Content-Type: application/json' \
            --data-binary @tests/fixtures/credentials/pg_local.json || echo "pg_local credential registration failed"
          curl -sS -X POST "http://localhost:8083/api/credentials" \
            -H 'Content-Type: application/json' \
            --data-binary @tests/fixtures/credentials/gcs_hmac_local.json || echo "gcs_hmac_local credential registration failed"
        fi
        echo "‚úì Test credentials registered"
        
        # Register all test playbooks using local server with local postgres auth
        echo "Registering all test playbooks with local postgres credentials..."
        ./register_test_playbooks.sh localhost 8083
        echo "‚úì Test playbooks registered"
        
        echo ""
        echo "NOTE: Test playbooks are registered with default pg_auth=pg_k8s"
        echo "      To execute with local credentials, override at runtime:"
        echo "      .venv/bin/noetl execute playbook <name> --payload '{\"pg_auth\": \"pg_local\"}' --merge"
        
        echo ""
        echo "=== Test environment setup completed successfully ==="
        echo "NoETL server: http://localhost:8083"
        echo "API docs: http://localhost:8083/docs"
        echo "UI (if running): http://localhost:3001"
        echo ""
        echo "Next steps:"
        echo "  task noetl-local-start  - Start/restart both server and worker (recommended)"
        echo "  task test-create-tables-local - Create database tables for save storage tests"
        echo "  task ui-dev             - Start the UI dev server"
        echo ""
        echo "NOTE: If you need to restart services after schema reset, run:"
        echo "      task debug-stop-all && task noetl-local-start"
        echo ""
        echo "NOTE: Before running, ensure you've updated tests/fixtures/credentials/gcs_hmac_local.json"
        echo "      with values from: https://console.cloud.google.com/security/secret-manager/secret/gcs_hmac_local/versions?project=noetl-demo-19700101"

  test-create-tables-local:
    desc: Create database tables for save storage tests using local postgres credentials
    aliases: [tctl]
    cmds:
      - |
        set -e
        echo "=== Creating database tables for save storage tests (local) ==="
        
        # Check if local server is running
        if ! curl -s -m 2 -f "http://localhost:8083/health" >/dev/null 2>&1; then
          echo "ERROR: NoETL server is not running on port 8083"
          echo "Please start the server first with: task server-debug"
          exit 1
        fi
        
        if [ -x ".venv/bin/noetl" ]; then
          cli=".venv/bin/noetl"
        else
          cli="noetl"
        fi
        
        echo "Executing create_tables playbook with local postgres credentials..."
        $cli execute playbook "tests/fixtures/playbooks/save_storage_test/create_tables" \
          --host localhost --port 8083 \
          --payload '{"pg_auth": "pg_local"}' --merge --json
        echo "‚úì Database tables created successfully"

  test-execute-local:
    desc: Execute a test playbook with local postgres credentials
    vars:
      PLAYBOOK: "{{ or .PLAYBOOK \"\" }}"
    cmds:
      - |
        set -e
        playbook="{{.PLAYBOOK}}"
        if [ -z "$playbook" ]; then
          echo "ERROR: PLAYBOOK parameter is required"
          echo "Usage: task test-execute-local PLAYBOOK=tests/fixtures/playbooks/save_storage_test/save_simple_test"
          exit 1
        fi
        
        # Check if local server is running
        if ! curl -s -m 2 -f "http://localhost:8083/health" >/dev/null 2>&1; then
          echo "ERROR: NoETL server is not running on port 8083"
          echo "Please start the server first with: task server-debug"
          exit 1
        fi
        
        if [ -x ".venv/bin/noetl" ]; then
          cli=".venv/bin/noetl"
        else
          cli="noetl"
        fi
        
        echo "Executing playbook: $playbook (with local postgres credentials)"
        $cli execute playbook "$playbook" \
          --host localhost --port 8083 \
          --payload '{"pg_auth": "pg_local"}' --merge --json

  noetl-local-full-setup:
    desc: Complete local setup - test environment, services, and tables (everything except UI)
    aliases: [local-full-setup, lfs]
    cmds:
      - |
        set -e
        echo "=== NoETL Local Full Setup Starting ==="
        echo ""
        
        echo "Step 1/4: Setting up test environment..."
        task noetl-local-setup-test-environment
        echo ""
        
        echo "Step 2/4: Starting NoETL services..."
        task debug-stop-all || true  # Stop any existing services
        sleep 2
        task noetl-local-start
        echo ""
        
        echo "Step 3/4: Creating database tables..."
        sleep 3  # Give services time to fully start
        task test-create-tables-local
        echo ""
        
        echo "Step 4/4: Checking service status..."
        task debug-status
        echo ""
        
        echo "=== üéâ NoETL Local Full Setup Complete! ==="
        echo ""
        echo "Services Running:"
        echo "  ‚úÖ NoETL Server: http://localhost:8083"
        echo "  ‚úÖ NoETL Worker: background process"
        echo "  ‚úÖ Database: tables created"
        echo "  ‚úÖ Test Environment: credentials and playbooks registered"
        echo ""
        echo "Next Steps:"
        echo "  üåê Start UI: task ui-dev"
        echo "  üìä API Docs: http://localhost:8083/docs"
        echo "  üß™ Run Test: task test-execute-local PLAYBOOK=tests/fixtures/playbooks/save_storage_test/save_simple_test"
        echo ""
        echo "Logs:"
        echo "  üìÑ Server: tail -f logs/server-debug.log"
        echo "  üîß Worker: tail -f logs/worker-debug.log"
        echo ""
        echo "To start UI in a new terminal:"
        echo "  task ui-dev"
