apiVersion: noetl.io/v1
kind: Playbook

metadata:
  name: unified_auth_example
  path: examples/test/unified_auth_example

workload:
  gcs_bucket: "noetl-demo-19700101"
  api_base_url: "https://api.example.com"

workflow:
  - step: simple_postgres_step
    desc: "Simple Postgres step using unified auth dictionary"
    type: postgres
    auth:
      pg:
        type: postgres
        key: pg_local
    command: |
      CREATE TABLE IF NOT EXISTS public.demo_table (
        id SERIAL PRIMARY KEY,
        name TEXT,
        created_at TIMESTAMPTZ DEFAULT now()
      );
    next:
      - step: multi_credential_duckdb_step

  - step: multi_credential_duckdb_step
    desc: "DuckDB step with multiple credentials using unified auth dictionary"
    type: duckdb
    auth:
      pg_db:
        type: postgres
        key: pg_local
      gcs_store:
        type: gcs
        key: gcs_hmac_local
        scope: "gs://{{ workload.gcs_bucket }}"
      s3_backup:
        type: s3
        key: aws_s3_backup
    commands: |
      INSTALL postgres; LOAD postgres;
      INSTALL httpfs;  LOAD httpfs;
      
      -- Use postgres credential
      ATTACH '' AS pg_db (TYPE postgres, SECRET pg_db);
      
      -- Access GCS with scoped credentials
      CREATE OR REPLACE SECRET gcs_store (
        TYPE gcs,
        KEY_ID  '{{ auth.gcs_store.key_id }}',
        SECRET  '{{ auth.gcs_store.secret_key }}',
        SCOPE   '{{ auth.gcs_store.scope }}'
      );
      
      -- Access S3 for backup
      CREATE OR REPLACE SECRET s3_backup (
        TYPE s3,
        KEY_ID     '{{ auth.s3_backup.access_key_id }}',
        SECRET     '{{ auth.s3_backup.secret_access_key }}',
        REGION     '{{ auth.s3_backup.region }}'
      );
      
      -- Query and export data
      CREATE OR REPLACE TABLE demo_export AS
      SELECT * FROM pg_db.public.demo_table;
      
      COPY demo_export TO '{{ auth.gcs_store.scope }}/exports/demo_{{ execution_id }}.parquet' (FORMAT PARQUET);
      COPY demo_export TO 's3://my-backup-bucket/exports/demo_{{ execution_id }}.parquet' (FORMAT PARQUET);
    next:
      - step: api_call_with_bearer_token

  - step: api_call_with_bearer_token
    desc: "HTTP API call with bearer token from auth dictionary"
    type: http
    method: POST
    endpoint: "{{ workload.api_base_url }}/data"
    auth:
      api_cred:
        type: bearer
        key: api_service_token
    headers:
      Authorization: "Bearer {{ auth.api_cred.access_token }}"
      Content-Type: "application/json"
    data:
      execution_id: "{{ execution_id }}"
      timestamp: "{{ now() }}"
      status: "completed"
    next:
      - step: mixed_auth_save_step

  - step: mixed_auth_save_step
    desc: "Save step showing auth dictionary in storage config"
    type: save
    save:
      storage:
        kind: postgres
        auth:
          pg_main:
            type: postgres
            key: pg_local
      table: public.execution_log
      mode: insert
      data:
        id: "{{ execution_id }}"
        step_name: "mixed_auth_save_step"
        completed_at: "{{ now() }}"
    next:
      - step: end

  - step: end
    desc: "End of workflow"
    type: noop
