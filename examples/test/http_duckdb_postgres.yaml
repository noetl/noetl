apiVersion: noetl.io/v1
kind: Playbook
name: http_duckdb_postgres
path: examples/test/http_duckdb_postgres

workload:
  message: "HTTP -> DuckDB -> Postgres pipeline"
  cities:
    - name: "London"
      lat: 51.51
      lon: -0.13
    - name: "Paris"
      lat: 48.85
      lon: 2.35
    - name: "Berlin"
      lat: 52.52
      lon: 13.41
  base_url: "https://api.open-meteo.com/v1"
  gcs_bucket: "noetl-demo-19700101"   # set this to an actual bucket; requires HMAC key_id/secret_key

workflow:
  - step: start
    desc: "Start pipeline"
    next:
      - step: ensure_pg_table

  - step: ensure_pg_table
    desc: "Ensure raw HTTP results table exists in Postgres"
    type: postgres
    credential: pg_local
    command: |
      CREATE TABLE IF NOT EXISTS public.weather_http_raw (
        id TEXT PRIMARY KEY,
        execution_id TEXT,
        iter_index INTEGER,
        city TEXT,
        url TEXT,
        elapsed DOUBLE PRECISION,
        payload TEXT,
        created_at TIMESTAMPTZ DEFAULT now()
      );
    next:
      - step: http_loop
        input:
          cities: "{{ workload.cities }}"

  - step: http_loop
    desc: "Fetch hourly temperatures for each city via child playbook"
    type: playbook
    path: examples/test/city_http_to_pg
    loop:
      in: "{{ cities }}"
      iterator: city_item
      mode: async
    with:
      city: "{{ city_item }}"
      base_url: "{{ workload.base_url }}"
      parent_execution_id: "{{ execution_id }}"
      index: "{{ _loop.current_index }}"
    next:
      - step: aggregate_with_duckdb

  - step: aggregate_with_duckdb
    desc: "Read raw rows from Postgres in DuckDB, aggregate, and write to GCS"
    type: duckdb
    # Step-level credentials mapping by alias (refer by name in credential table)
    credentials:
      postgres_db:
        kind: postgres
        credential: pg_local
        spec:
          dbname: demo_noetl
      gcs_hmac:
        kind: gcs_hmac
        credential: gcs_hmac_local
    commands: |
      -- Simplified: copy rows as-is from the attached Postgres table
      CREATE OR REPLACE TABLE weather_raw AS
      SELECT *
      FROM postgres_db.public.weather_http_raw
      WHERE execution_id = '{{ execution_id }}';
    next:
      - step: ensure_metrics_table

  - step: ensure_metrics_table
    desc: "Ensure metrics table exists in Postgres"
    type: postgres
    credential: pg_local
    command: |
      CREATE TABLE IF NOT EXISTS public.weather_pipeline_metrics (
        execution_id TEXT PRIMARY KEY,
        pg_rows_saved INTEGER,
        gcs_flat_uri TEXT,
        gcs_agg_uri  TEXT,
        created_at   TIMESTAMPTZ DEFAULT now()
      );
    next:
      - step: end

  - step: end
    desc: "Finish"
    save:
      storage:
        kind: postgres
        credential: pg_local
      table: public.weather_pipeline_metrics
      mode: upsert
      key: execution_id
      data:
        execution_id: "{{ execution_id }}"
        pg_rows_saved: "{{ http_loop.count }}"
        gcs_flat_uri: "gs://{{ workload.gcs_bucket }}/weather/flat_{{ execution_id }}.parquet"
        gcs_agg_uri:  "gs://{{ workload.gcs_bucket }}/weather/agg_{{ execution_id }}.parquet"
