apiVersion: noetl.io/v1
kind: Playbook
name: gcp_vm_control_loop
path: examples/iac/gcp_vm_control_loop
description: Provision GCP VM, store state in Postgres, detect and fix drift

workload:
  # GCP settings (allow override via environment, but tasks reference workload.* only)
  project: "{{ env.GCP_PROJECT | default('your-gcp-project-id') }}"
  zone: "{{ env.GCP_ZONE | default('us-central1-a') }}"
  vm_name: "{{ env.VM_NAME | default('noetl-demo-vm') }}"
  vm_type: "{{ env.VM_TYPE | default('e2-micro') }}"
  vm_image: "{{ env.VM_IMAGE | default('projects/debian-cloud/global/images/family/debian-11') }}"
  google_application_credentials: "{{ env.GOOGLE_APPLICATION_CREDENTIALS | default('') }}"
  gcp_scopes: "{{ env.GCP_SCOPES | default('https://www.googleapis.com/auth/cloud-platform') }}"
  use_metadata_token: "{{ (env.USE_GCP_METADATA | default('false') | lower) in ['1','true','yes','y'] }}"
  use_noetl_token: "{{ (env.USE_NOETL_TOKEN | default('false') | lower) in ['1','true','yes','y'] }}"
  use_oidc_auth: "{{ (env.USE_OIDC_AUTH | default('false') | lower) in ['1','true','yes','y'] }}"
  gcp_credentials_secret: "{{ env.GCP_CREDENTIALS_SECRET | default('gcp-sa-noetl') }}"

  # Postgres settings
  pg_host: "{{ env.POSTGRES_HOST | default('postgres') }}"
  pg_port: "{{ env.POSTGRES_PORT | default('5432') }}"
  pg_user: "{{ env.POSTGRES_USER | default('demo') }}"
  pg_password: "{{ env.POSTGRES_PASSWORD | default('demo') }}"
  pg_db: "{{ env.POSTGRES_DB | default('demo_noetl') }}"
  pg_conn: "postgresql://{{ env.POSTGRES_USER | default('demo') }}:{{ env.POSTGRES_PASSWORD | default('demo') }}@{{ env.POSTGRES_HOST | default('postgres') }}:{{ env.POSTGRES_PORT | default('5432') }}/{{ env.POSTGRES_DB | default('demo_noetl') }}"

  # NoETL settings
  noetl_base_url: "{{ env.NOETL_BASE_URL | default(env.NOETL_INTERNAL_URL | default('http://localhost:' ~ (env.NOETL_PORT | default('8084')))) }}"

workflow:
  - step: start
    desc: "Start GCP VM control loop"
    next:
      - step: list_zones_http

  - step: list_zones_http
    desc: "List available GCP zones using OIDC auth from stored credential"
    type: workbook
    task: list_zones_http_task
    next:
      - step: create_vm_http

  - step: create_vm_http
    desc: "Create a VM in Google Cloud via HTTP"
    type: workbook
    task: create_vm_http_task
    with:
      project: "{{ workload.project }}"
      zone: "{{ workload.zone }}"
      vm_name: "{{ workload.vm_name }}"
      vm_type: "{{ workload.vm_type }}"
      vm_image: "{{ workload.vm_image }}"
    next:
      - step: store_state

  - step: store_state
    desc: "Store VM state in Postgres"
    type: workbook
    task: store_state_task
    with:
      vm:
        vm_name: "{{ workload.vm_name }}"
        zone: "{{ workload.zone }}"
        project: "{{ workload.project }}"
        machine_type: "{{ workload.vm_type }}"
        image: "{{ workload.vm_image }}"
    next:
      - step: get_instance_http

  - step: get_instance_http
    desc: "Fetch VM instance from Google Cloud via HTTP"
    type: workbook
    task: get_instance_http_task
    with:
      project: "{{ workload.project }}"
      zone: "{{ workload.zone }}"
      vm_name: "{{ workload.vm_name }}"
    next:
      - step: get_stored_state

  - step: get_stored_state
    desc: "Fetch stored VM state from Postgres"
    type: workbook
    task: get_stored_state_task
    with:
      vm_name: "{{ workload.vm_name }}"
    next:
      - step: compare_drift

  - step: compare_drift
    desc: "Compare stored state with actual GCP state"
    type: workbook
    task: compare_drift_task
    with:
      instance: "{{ get_instance_http_task.result.data }}"
      stored_rows: "{{ get_stored_state_task.command_1.rows | default([]) }}"
    next:
      - when: "{{ compare_drift_task.result.drift | length > 0 }}"
        then:
          - step: stop_instance_http
      - step: end

  - step: stop_instance_http
    desc: "Stop VM instance prior to machine type change"
    type: workbook
    task: stop_instance_http_task
    with:
      project: "{{ workload.project }}"
      zone: "{{ workload.zone }}"
      vm_name: "{{ workload.vm_name }}"
    next:
      - step: set_machine_type_http

  - step: set_machine_type_http
    desc: "Set VM machine type via HTTP"
    type: workbook
    task: set_machine_type_http_task
    with:
      project: "{{ workload.project }}"
      zone: "{{ workload.zone }}"
      vm_name: "{{ workload.vm_name }}"
      expected_machine_type: "{{ compare_drift_task.result.drift.machine_type.expected if compare_drift_task.result.drift and compare_drift_task.result.drift.machine_type else workload.vm_type }}"
    next:
      - step: start_instance_http

  - step: start_instance_http
    desc: "Start VM instance after machine type change"
    type: workbook
    task: start_instance_http_task
    with:
      project: "{{ workload.project }}"
      zone: "{{ workload.zone }}"
      vm_name: "{{ workload.vm_name }}"
    next:
      - step: end

  - step: end
    desc: "End of workflow"

workbook:
  - name: get_gcp_token_http_task
    type: http
    endpoint: "{{ workload.noetl_base_url }}/gcp/token"
    method: POST
    headers:
      Content-Type: "application/json"
    payload:
      scopes:
        - "{{ workload.gcp_scopes }}"
      use_metadata: false
    timeout: 5
    on_error: continue

  - name: list_zones_http_task
    type: http
    method: GET
    endpoint: "https://compute.googleapis.com/compute/v1/projects/{{ workload.project }}/zones"
    headers:
      Accept: "application/json"
    auth:
      type: OIDC
      provider: gcp
      credential:
        name: "{{ workload.gcp_credentials_secret }}"
      scopes:
        - "{{ workload.gcp_scopes }}"
    timeout: 10
    on_error: continue

  - name: create_vm_http_task
    type: http
    method: POST
    endpoint: "https://compute.googleapis.com/compute/v1/projects/{{ project }}/zones/{{ zone }}/instances"
    headers:
      Content-Type: "application/json"
      Accept: "application/json"
    auth:
      type: OIDC
      provider: gcp
      credential:
        name: "{{ workload.gcp_credentials_secret }}"
      scopes:
        - "{{ workload.gcp_scopes }}"
    payload:
      name: "{{ vm_name }}"
      machineType: "zones/{{ zone }}/machineTypes/{{ vm_type }}"
      disks:
        - boot: true
          autoDelete: true
          initializeParams:
            sourceImage: "{{ vm_image }}"
      networkInterfaces:
        - network: "global/networks/default"
    timeout: 20

  - name: get_instance_http_task
    type: http
    method: GET
    endpoint: "https://compute.googleapis.com/compute/v1/projects/{{ project }}/zones/{{ zone }}/instances/{{ vm_name }}"
    headers:
      Accept: "application/json"
    auth:
      type: OIDC
      provider: gcp
      credential:
        name: "{{ workload.gcp_credentials_secret }}"
      scopes:
        - "{{ workload.gcp_scopes }}"
    timeout: 10
    on_error: continue

  - name: stop_instance_http_task
    type: http
    method: POST
    endpoint: "https://compute.googleapis.com/compute/v1/projects/{{ project }}/zones/{{ zone }}/instances/{{ vm_name }}/stop"
    headers:
      Accept: "application/json"
    auth:
      type: OIDC
      provider: gcp
      credential:
        name: "{{ workload.gcp_credentials_secret }}"
      scopes:
        - "{{ workload.gcp_scopes }}"
    timeout: 20

  - name: set_machine_type_http_task
    type: http
    method: POST
    endpoint: "https://compute.googleapis.com/compute/v1/projects/{{ project }}/zones/{{ zone }}/instances/{{ vm_name }}/setMachineType"
    headers:
      Content-Type: "application/json"
      Accept: "application/json"
    auth:
      type: OIDC
      provider: gcp
      credential:
        name: "{{ workload.gcp_credentials_secret }}"
      scopes:
        - "{{ workload.gcp_scopes }}"
    payload:
      machineType: "zones/{{ zone }}/machineTypes/{{ expected_machine_type }}"
    timeout: 20

  - name: start_instance_http_task
    type: http
    method: POST
    endpoint: "https://compute.googleapis.com/compute/v1/projects/{{ project }}/zones/{{ zone }}/instances/{{ vm_name }}/start"
    headers:
      Accept: "application/json"
    auth:
      type: OIDC
      provider: gcp
      credential:
        name: "{{ workload.gcp_credentials_secret }}"
      scopes:
        - "{{ workload.gcp_scopes }}"
    timeout: 20

  - name: store_state_task
    type: postgres
    command: |
      CREATE TABLE IF NOT EXISTS gcp_vm_state (
        vm_name TEXT PRIMARY KEY,
        zone TEXT,
        project TEXT,
        machine_type TEXT,
        image TEXT
      );
      INSERT INTO gcp_vm_state (vm_name, zone, project, machine_type, image)
      VALUES ('{{ vm.vm_name }}', '{{ vm.zone }}', '{{ vm.project }}', '{{ vm.machine_type }}', '{{ vm.image }}')
      ON CONFLICT (vm_name) DO UPDATE SET
        zone=EXCLUDED.zone,
        project=EXCLUDED.project,
        machine_type=EXCLUDED.machine_type,
        image=EXCLUDED.image;

  - name: get_stored_state_task
    type: postgres
    with:
      db_host: "{{ workload.pg_host }}"
      db_port: "{{ workload.pg_port }}"
      db_user: "{{ workload.pg_user }}"
      db_password: "{{ workload.pg_password }}"
      db_name: "{{ workload.pg_db }}"
      vm_name: "{{ vm_name }}"
    command: |
      SELECT vm_name, zone, project, machine_type, image
      FROM gcp_vm_state
      WHERE vm_name = '{{ vm_name }}';

  - name: compare_drift_task
    type: python
    with:
      instance: "{{ instance }}"
      stored_rows: "{{ stored_rows }}"
    code: |
      def main(instance=None, stored_rows=None):
          # stored_rows is expected to be a list of rows from the postgres task
          rows = stored_rows or []
          if not rows:
              return {"drift": {}, "note": "No stored state found"}

          row = rows[0]

          # Support both dict and positional row formats
          if isinstance(row, dict):
              stored = {
                  "vm_name": row.get("vm_name"),
                  "zone": row.get("zone"),
                  "project": row.get("project"),
                  "machine_type": row.get("machine_type"),
                  "image": row.get("image"),
              }
          else:
              # Fallback to positional mapping
              cols = ["vm_name", "zone", "project", "machine_type", "image"]
              stored = dict(zip(cols, list(row)))

          # Actual state from HTTP response (instance JSON)
          actual = {}
          if isinstance(instance, dict):
              # machineType is a URL; take the last segment
              mt = instance.get("machineType") or ""
              actual["machine_type"] = mt.split("/")[-1] if mt else ""
              # Derive image/license info if available
              disks = instance.get("disks") or []
              if disks:
                  lic = (disks[0].get("licenses") or [""])[0]
                  actual["image"] = lic.split("/")[-1] if lic else ""

          drift = {}
          for k in ["machine_type", "image"]:
              if stored.get(k) != actual.get(k):
                  drift[k] = {"expected": stored.get(k), "actual": actual.get(k)}

          return {"drift": drift}
