# This is a NoETL DSL Playbook for iterating over cities to fetch and evaluate weather data.
# It includes a loop to process each city, fetch weather data, evaluate conditions, and handle alerts or logging.
# The playbooks demonstrates nested loops for processing city districts, with conditions to skip certain districts.
# noetl playbooks --execute --path "workflows/weather/weather_example" --payload '{"cities": [{"name": "New York", "lat": 40.71, "lon": -74.01}], "temperature_threshold": 30}'


apiVersion: noetl.io/v1
kind: Playbook
name: weather_example
path: examples/weather/weather_loop_example  # Unique path identifier for this playbooks

workload:  # Input parameters section accessible throughout the workflow
  jobId: "{{ job.uuid }}"
  state: ready
  cities:  # List of cities to process in the loop
    - name: "London"  # City name
      lat: 51.51  # Latitude
      lon: -0.13  # Longitude
    - name: "Paris"
      lat: 48.85
      lon: 2.35
    - name: "Berlin"
      lat: 52.52
      lon: 13.41
  base_url: "https://api.open-meteo.com/v1"  # Base URL for weather API
  temperature_threshold: 12  # Threshold for alerting on temperature
  # Postgres connection parameters (must be provided - no defaults)
  pg_host: "localhost"
  pg_port: "30543"
  pg_user: "demo"
  pg_password: "demo"
  pg_db: "demo_noetl"

workflow:  # Workflow steps and transitions
  - step: start  # Entry point of the workflow
    desc: "Start Weather Analysis Workflow"
    next:  # Transition rules based on condition
      - when: "{{ workload.state == 'ready' }}"  # Condition for transition
        then:
          - step: city_loop  # If condition met, goto city_loop step
      - else:
          - step: end  # If not ready, end the workflow

  - step: city_loop
    type: playbook
    path: examples/weather/city_process
    loop:
      in: "{{ workload.cities }}"
      iterator: city_item
      distribution: true
    with:
      city: "{{ city_item }}"
      base_url: "{{ workload.base_url }}"
      temperature_threshold: "{{ workload.temperature_threshold }}"
    next:
      - step: debug_results

  - step: debug_results
    desc: "Debug what city_loop.result contains"
    type: python
    code: |
      def main(results):
          print(f"DEBUG_RESULTS: city_loop.result = {results}")
          print(f"DEBUG_RESULTS: type = {type(results)}")
          if isinstance(results, list):
              print(f"DEBUG_RESULTS: length = {len(results)}")
              for i, item in enumerate(results):
                  print(f"DEBUG_RESULTS: item[{i}] = {item} (type: {type(item)})")
          return {"debug_complete": True, "results": results}
    with:
      results: "{{ city_loop.result }}"
    next:
      - step: aggregate_alerts
        with:
          alerts: "{{ city_loop.result }}"

  - step: aggregate_alerts
    desc: "Aggregate results after all city loops complete"
    type: workbook
    name: aggregate_alerts_task
    with:
      alerts: "{{ city_loop.result }}"
    next:
      - step: log_aggregate_result
        with:
          summary: "{{ aggregate_alerts.summary | default({'alert_cities': [], 'count': 0}) }}"

  - step: log_aggregate_result
    desc: "Log the aggregated alert summary"
    type: workbook
    name: log_aggregate_result_task
    with:
      summary: "{{ aggregate_alerts.summary | default({'alert_cities': [], 'count': 0}) }}"
    next:
      - step: store_summary_postgres
        with:
          alert_cities: "{{ aggregate_alerts.summary.alert_cities | default([]) }}"
          alert_count: "{{ aggregate_alerts.summary.count | default(0) }}"

  - step: store_summary_postgres
    desc: "Store aggregated summary in Postgres"
    type: workbook
    name: store_summary_postgres_task
    with:
      alert_cities: "{{ alert_cities }}"
      alert_count: "{{ alert_count }}"
    next:
      - step: end

  - step: end
    desc: "End of workflow"


workbook:
  - name: process_city_weather
    type: python
    with:
      city: "{{ city }}"
      base_url: "{{ base_url }}"
      temperature_threshold: "{{ temperature_threshold }}"
    code: |
      def main(city, base_url, temperature_threshold):
          print(f"PROCESS_CITY_WEATHER: Processing city: {city}")
          print(f"PROCESS_CITY_WEATHER: Temperature threshold: {temperature_threshold}")
          
          # Step 1: Get forecast (simplified - just return empty data)
          forecast_data = {}
          
          # Step 2: Evaluate weather
          try:
              threshold = float(temperature_threshold) if temperature_threshold not in (None, "") else 25.0
          except Exception:
              threshold = 25.0

          temps = []
          if isinstance(forecast_data, dict):
              hourly = forecast_data.get("hourly", {})
              if isinstance(hourly, dict):
                  temps = hourly.get("temperature_2m", []) or []

          max_temp = max(temps) if temps else 0.0
          alert = bool(max_temp > threshold)
          
          # Step 3: Determine action
          if alert:
              action = "alert"
              print(f"PROCESS_CITY_WEATHER: Alert needed for {city['name']} - temp {max_temp} > {threshold}")
          else:
              action = "log"
              print(f"PROCESS_CITY_WEATHER: No alert for {city['name']} - temp {max_temp} <= {threshold}")
          
          # Step 4: Return result
          result = {
              "city": city["name"],
              "action": action,
              "max_temp": max_temp,
              "alert": alert
          }
          
          print(f"PROCESS_CITY_WEATHER: Final result: {result}")
          return result

  - name: evaluate_weather
    type: python
    with:
      city: "{{ city }}"
      threshold: "{{ temperature_threshold }}"
      forecast_data: "{{ get_forecast }}"
    code: |
      def main(city, threshold, forecast_data):
          print(f"City: {city}")
          print(f"Threshold: {threshold}")
          print(f"Forecast data type: {type(forecast_data)}")
          threshold = float(threshold) if threshold else 5
          print(f"Threshold after conversion: {threshold}")
          temps = []
          if isinstance(forecast_data, dict):
              print(f"Forecast data keys: {forecast_data.keys()}")
              hourly = forecast_data.get('hourly', {})
              if isinstance(hourly, dict) and 'temperature_2m' in hourly:
                  temps = hourly['temperature_2m']
                  print(f"Found temps in hourly.temperature_2m: {temps}")
              elif 'data' in forecast_data and isinstance(forecast_data['data'], dict):
                  data = forecast_data['data']
                  print(f"Data keys: {data.keys()}")
                  data_hourly = data.get('hourly', {})
                  if isinstance(data_hourly, dict) and 'temperature_2m' in data_hourly:
                      temps = data_hourly['temperature_2m']
                      print(f"Found temps in data.hourly.temperature_2m: {temps}")
          max_temp = max(temps) if temps else 0
          print(f"Max temperature: {max_temp}")
          alert = max_temp > threshold
          print(f"Alert needed: {alert}")
          result = {
              "city": city["name"],
              "max_temp": max_temp,
              "alert": alert
          }
          print(f"Returning result: {result}")
          return result

  - name: alert_task
    type: http
    method: POST
    endpoint: "https://postman-echo.com/post"
    payload:
      city: "{{ city }}"
      temperature: "{{ temperature }}"
      message: "High temperature alert."

  - name: log_task
    type: http
    method: POST
    endpoint: "https://postman-echo.com/post"
    payload:
      city: "{{ city }}"
      message: "No alert needed."

  - name: get_city_districts
    type: http
    method: GET
    endpoint: "https://postman-echo.com/post"

  - name: process_district
    type: python
    with:
      city: "{{ city }}"
      district: "{{ district }}"
    code: |
      def main(city, district):
          return {
              "city": city["name"],
              "district": district["name"],
              "processed": True,
              "timestamp": "2024-01-01T12:00:00Z"
          }

  - name: aggregate_alerts_task
    type: python
    with:
      alerts: "{{ alerts }}"
    code: |
      def main(alerts):
          print(f"AGGREGATE_ALERTS_TASK: Received alerts input: {alerts}")
          print(f"AGGREGATE_ALERTS_TASK: Alerts type: {type(alerts)}")
          
          import ast
          # Normalize alerts input
          if isinstance(alerts, str):
              try:
                  alerts = ast.literal_eval(alerts)
              except Exception:
                  alerts = []
          alerts = alerts or []

          print(f"AGGREGATE_ALERTS_TASK: After normalization: {alerts}")
          print(f"AGGREGATE_ALERTS_TASK: After normalization type: {type(alerts)}")
          
          # Unwrap nested results if coming from sub-playbook aggregates
          normalized = []
          for item in alerts:
              print(f"AGGREGATE_ALERTS_TASK: Processing item: {item} (type: {type(item)})")
              if isinstance(item, dict):
                  if 'evaluate_weather' in item and isinstance(item['evaluate_weather'], dict):
                      normalized.append(item['evaluate_weather'])
                  else:
                      normalized.append(item)
          
          print(f"AGGREGATE_ALERTS_TASK: Normalized results: {normalized}")
          
          # Compute summary
          alert_cities = [a for a in normalized if isinstance(a, dict) and a.get('alert')]
          print(f"AGGREGATE_ALERTS_TASK: Alert cities: {alert_cities}")
          
          global_alert = bool(alert_cities)
          summary = {
              "alert_cities": [a.get("city") for a in alert_cities],
              "count": len(alert_cities)
          }
          
          result = {"global_alert": global_alert, "summary": summary}
          print(f"AGGREGATE_ALERTS_TASK: Final result: {result}")
          return result

  - name: global_alert_task
    type: http
    method: POST
    endpoint: "https://postman-echo.com/post"
    payload:
      summary: "{{ summary }}"
      message: "Global weather alert triggered."

  - name: log_aggregate_result_task
    type: python
    with:
      summary: "{{ summary }}"
    code: |
      def main(summary):
          print(f"Aggregated weather alert summary: {summary}")
          return {"logged": True, "summary": summary}

  - name: store_summary_duckdb_task
    type: duckdb
    with:
      alert_cities: "{{ alert_cities }}"
      alert_count: "{{ alert_count }}"
    command: |
      -- Create DuckDB table for weather alert summary and insert the current summary
      CREATE TABLE IF NOT EXISTS weather_alert_summary (
        id BIGINT,
        alert_cities TEXT,
        alert_count INTEGER,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      );
      -- Insert aggregated summary. DuckDB does not support SQLite's strftime('%s', ...); use date_part('epoch', ...) for epoch seconds
      INSERT INTO weather_alert_summary (id, alert_cities, alert_count)
        VALUES (
          (date_part('epoch', current_timestamp)*1000)::BIGINT,
          '{{ alert_cities | default([], true) | tojson }}',
          {{ alert_count | default(0, true) }}
        );

      SELECT * FROM weather_alert_summary ORDER BY created_at DESC LIMIT 5;

  - name: store_summary_postgres_task
    type: postgres
    with:
      alert_cities: "{{ alert_cities }}"
      alert_count: "{{ alert_count }}"
      db_host: "localhost"
      db_port: "30543"
      db_user: "demo"
      db_password: "demo"
      db_name: "demo_noetl"
    command: |
      -- Create table if not exists
      CREATE TABLE IF NOT EXISTS weather_alert_summary (
        id SERIAL PRIMARY KEY,
        alert_cities TEXT,
        alert_count INTEGER,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      );

      -- Insert aggregated summary
      INSERT INTO weather_alert_summary (alert_cities, alert_count)
        VALUES (
          '{{ alert_cities | default([], true) | tojson }}',
          {{ alert_count | default(0, true) }}
        );

      -- Return recent entries for verification
      SELECT * FROM weather_alert_summary ORDER BY id DESC LIMIT 5;