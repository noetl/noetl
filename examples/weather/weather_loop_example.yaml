# This is a NoETL DSL Playbook for iterating over cities to fetch and evaluate weather data.
# It processes each city, fetches weather data from Open-Meteo, evaluates against a threshold,
# posts alerts/logs to httpbin, aggregates results, and stores a summary in DuckDB.

apiVersion: noetl.io/v1
kind: Playbook
name: weather_example
path: examples/weather_loop_example

workload:
  jobId: "{{ job.uuid }}"
  state: ready
  cities:
    - name: "London"
      lat: 51.51
      lon: -0.13
    - name: "Paris"
      lat: 48.85
      lon: 2.35
    - name: "Berlin"
      lat: 52.52
      lon: 13.41
  base_url: "https://api.open-meteo.com/v1"
  temperature_threshold: 12

workflow:
  - step: start
    desc: "Start Weather Analysis Workflow"
    next:
      - when: "{{ workload.state == 'ready' }}"
        then:
          - step: city_loop
      - else:
          - step: end

  - step: city_loop
    desc: "Iterate over cities"
    loop:
      in: "{{ workload.cities }}"
      iterator: city
    next:
      - step: fetch_and_evaluate
        with:
          city: "{{ city }}"
          base_url: "{{ workload.base_url }}"
          temperature_threshold: "{{ workload.temperature_threshold }}"

  - step: fetch_and_evaluate
    desc: "Fetch and evaluate weather for one city"
    type: workbook
    name: evaluate_weather_directly
    with:
      city: "{{ city }}"
      base_url: "{{ base_url }}"
      threshold: "{{ temperature_threshold }}"
    next:
      - when: "{{ evaluate_weather_directly.alert }}"
        then:
          - step: alert_step
            with:
              city: "{{ city.name }}"
              max_temp: "{{ evaluate_weather_directly.max_temp }}"
          - step: end_city_loop
      - else:
          - step: log_step
            with:
              city: "{{ city.name }}"
          - step: end_city_loop

  - step: evaluate_weather_step
    desc: "Evaluate weather data and determine if alert is needed"
    type: workbook
    name: evaluate_weather
    with:
      city: "{{ city }}"
      threshold: "{{ workload.temperature_threshold }}"
      forecast_data: "{{ get_forecast }}"
    next:
      - when: "{{ evaluate_weather.alert }}"
        then:
          - step: alert_step
            with:
              city: "{{ city.name }}"
              max_temp: "{{ evaluate_weather.max_temp }}"
      - else:
          - step: log_step
            with:
              city: "{{ city.name }}"

  - step: alert_step
    desc: "Send alert if threshold exceeded"
    type: workbook
    name: alert_task
    with:
      city: "{{ city }}"
      temperature: "{{ max_temp }}"
    next:
      - step: end_city_loop

  - step: log_step
    desc: "Log result if no alert"
    type: workbook
    name: log_task
    with:
      city: "{{ city }}"
    next:
      - step: end_city_loop

  - step: end_city_loop
    desc: "End of the city loop"
    end_loop: city_loop
    result:
      alerts: "{{ city_loop_results | map(attribute='fetch_and_evaluate') | list }}"
    next:
      - step: aggregate_alerts
        with:
          alerts: "{{ alerts }}"

  - step: aggregate_alerts
    desc: "Aggregate results after all city loops complete"
    type: workbook
    name: aggregate_alerts_task
    with:
      alerts: "{{ alerts }}"
    next:
      - step: log_aggregate_result
        with:
          summary: "{{ aggregate_alerts.summary }}"
      - when: "{{ aggregate_alerts.global_alert }}"
        then:
          - step: global_alert_step
            with:
              summary: "{{ aggregate_alerts.summary }}"
      - else:
          - step: end

  - step: log_aggregate_result
    desc: "Log the aggregated alert summary"
    type: workbook
    name: log_aggregate_result_task
    with:
      summary: "{{ aggregate_alerts.summary }}"
    next:
      - step: store_aggregate_result
        with:
          summary: "{{ aggregate_alerts.summary }}"

  - step: global_alert_step
    desc: "Send a global alert if any city triggered an alert"
    type: workbook
    name: global_alert_task
    with:
      summary: "{{ aggregate_alerts.summary }}"
    next:
      - step: store_aggregate_result
        with:
          summary: "{{ aggregate_alerts.summary }}"

  - step: store_aggregate_result
    desc: "Store the aggregated alert summary in DuckDB/Postgres"
    type: workbook
    name: store_aggregate_result_task_postgres_pipeline
    with:
      summary: "{{ aggregate_alerts.summary }}"
    next:
      - step: end

  - step: end
    desc: "End of workflow"

workbook:

  - name: log_forcast_request
    type: http
    method: GET
    endpoint: "{{ base_url }}/forecast"
    params:
      latitude: "{{ city.lat }}"
      longitude: "{{ city.lon }}"
      hourly: "temperature_2m"
      forecast_days: 1
    timeout: 10

  - name: get_forecast
    type: http
    method: GET
    endpoint: "{{ base_url }}/forecast"
    params:
      latitude: "{{ city.lat }}"
      longitude: "{{ city.lon }}"
      hourly: "temperature_2m"
      forecast_days: 1
    timeout: 10

  - name: evaluate_weather_directly
    type: python
    with:
      city: "{{ city }}"
      threshold: "{{ threshold }}"
      base_url: "{{ base_url }}"
    code: |
      def main(city, threshold, base_url):
          import httpx
          threshold = float(threshold) if threshold not in (None, "") else 25.0
          try:
              resp = httpx.get(
                  f"{base_url}/forecast",
                  params={
                      "latitude": city["lat"],
                      "longitude": city["lon"],
                      "hourly": "temperature_2m",
                      "forecast_days": 1,
                  },
                  timeout=10.0,
              )
              resp.raise_for_status()
              data = resp.json()
          except Exception as e:
              return {"city": city["name"], "max_temp": 0.0, "alert": False, "error": str(e)}

          temps = []
          if isinstance(data, dict):
              hourly = data.get("hourly", {})
              if isinstance(hourly, dict):
                  temps = hourly.get("temperature_2m", []) or []

          max_temp = max(temps) if temps else 0.0
          return {"city": city["name"], "max_temp": max_temp, "alert": bool(max_temp > threshold)}

  - name: evaluate_weather
    type: python
    with:
      city: "{{ city }}"
      threshold: "{{ workload.temperature_threshold }}"
      forecast_data: "{{ get_forecast }}"
    code: |
      def main(city, threshold, forecast_data):
          threshold = float(threshold) if threshold not in (None, "") else 5.0
          temps = []
          if isinstance(forecast_data, dict):
              hourly = forecast_data.get("hourly", {})
              if isinstance(hourly, dict):
                  temps = hourly.get("temperature_2m", []) or []
          max_temp = max(temps) if temps else 0.0
          return {"city": city["name"], "max_temp": max_temp, "alert": bool(max_temp > threshold)}

  - name: alert_task
    type: http
    method: POST
    endpoint: "https://httpbin.org/post"
    payload:
      kind: "city_alert"
      city: "{{ city }}"
      temperature: "{{ temperature }}"
      message: "High temperature alert."
    timeout: 10

  - name: log_task
    type: http
    method: POST
    endpoint: "https://httpbin.org/post"
    payload:
      kind: "city_log"
      city: "{{ city }}"
      message: "No alert needed."
    timeout: 10

  - name: global_alert_task
    type: http
    method: POST
    endpoint: "https://httpbin.org/post"
    payload:
      kind: "global_alert"
      summary: "{{ summary }}"
      message: "Global weather alert triggered."
    timeout: 10

  - name: log_aggregate_result_task
    type: python
    with:
      summary: "{{ summary }}"
    code: |
      def main(summary):
          print(f"Aggregated weather alert summary: {summary}")
          return {"logged": True, "summary": summary}

  - name: store_aggregate_result_task_postgres_pipeline
    type: python
    with:
      summary: "{{ summary }}"
    code: |
      def main(summary):
          import duckdb, json, time, os
          con = duckdb.connect('data/noetldb/postgres_pipeline.duckdb')
          con.execute("""
              CREATE TABLE IF NOT EXISTS weather_alert_summary (
                  id BIGINT,
                  alert_cities TEXT,
                  alert_count INTEGER,
                  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
              )
          """)
          row_id = int(time.time() * 1000)
          con.execute(
              "INSERT INTO weather_alert_summary (id, alert_cities, alert_count) VALUES (?, ?, ?)",
              (row_id, json.dumps(summary.get('alert_cities', [])), int(summary.get('count', 0)))
          )

          # --- Optional: enable Postgres via DuckDB extension (requires reachable host & creds) ---
          # if os.getenv("ENABLE_POSTGRES_BRIDGE") == "1":
          #     con.execute("INSTALL postgres;")
          #     con.execute("LOAD postgres;")
          #     con.execute("ATTACH 'dbname=demo_noetl user=demo password=demo host=YOUR_HOST port=5432' AS pg (TYPE postgres);")
          #     con.execute("""
          #         CREATE TABLE IF NOT EXISTS pg.weather_alert_summary (
          #             id BIGINT PRIMARY KEY,
          #             alert_cities TEXT,
          #             alert_count INTEGER,
          #             created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
          #         )
          #     """)
          #     con.execute(
          #         "INSERT INTO pg.weather_alert_summary (id, alert_cities, alert_count) VALUES (?, ?, ?)",
          #         (row_id, json.dumps(summary.get('alert_cities', [])), int(summary.get('count', 0)))
          #     )

          con.close()
          return {'status': 'stored_in_duckdb', 'id': row_id, 'summary': summary}
