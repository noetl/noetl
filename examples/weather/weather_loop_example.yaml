# This is a NoETL DSL Playbook for iterating over cities to fetch and evaluate weather data.
# It processes each city, fetches weather data from Open-Meteo, evaluates against a threshold,
# posts alerts/logs to httpbin, aggregates results, and stores summary in DuckDB.

apiVersion: noetl.io/v1
kind: Playbook
name: weather_example
path: examples/weather_loop_example

workload:
  jobId: "{{ job.uuid }}"
  state: ready
  cities:
    - name: "London"
      lat: 51.51
      lon: -0.13
    - name: "Paris"
      lat: 48.85
      lon: 2.35
    - name: "Berlin"
      lat: 52.52
      lon: 13.41
  base_url: "https://api.open-meteo.com/v1"
  temperature_threshold: 12

workflow:
  - step: start
    desc: "Start Weather Analysis Workflow"
    next:
      - when: "{{ workload.state == 'ready' }}"
        then:
          - step: city_loop
      - else:
          - step: end

  - step: city_loop
    desc: "Iterate over cities"
    loop:
      in: "{{ workload.cities }}"
      iterator: city
    next:
      - step: fetch_and_evaluate
        with:
          city: "{{ city }}"
          base_url: "{{ workload.base_url }}"
          temperature_threshold: "{{ workload.temperature_threshold }}"

  - step: fetch_and_evaluate
    desc: "Fetch and evaluate weather for one city"
    type: workbook
    task: evaluate_weather_directly
    with:
      city: "{{ city }}"
      base_url: "{{ base_url }}"
      threshold: "{{ temperature_threshold }}"
    next:
      - step: check_alert_needed
        with:
          city: "{{ city }}"
          evaluation_result: "{{ evaluate_weather_directly }}"

  - step: check_alert_needed
    desc: "Check if alert is needed based on evaluation result"
    type: python
    code: |
      def main(city, evaluation_result):
          if evaluation_result.get("alert", False):
              return {"action": "alert", "city": city, "max_temp": evaluation_result.get("max_temp", 0)}
          else:
              return {"action": "log", "city": city}
    next:
      - when: "{{ check_alert_needed.action == 'alert' }}"
        then:
          - step: alert_step
            with:
              city: "{{ city.name }}"
              max_temp: "{{ check_alert_needed.max_temp }}"
      - else:
          - step: log_step
            with:
              city: "{{ city.name }}"

  - step: evaluate_weather_step
    desc: "Evaluate weather data and determine if alert is needed"
    type: workbook
    task: evaluate_weather
    with:
      city: "{{ city }}"
      threshold: "{{ workload.temperature_threshold }}"
      forecast_data: "{{ get_forecast }}"
    next:
      - when: "{{ evaluate_weather.alert }}"
        then:
          - step: alert_step
            with:
              city: "{{ city.name }}"
              max_temp: "{{ evaluate_weather.max_temp }}"
      - else:
          - step: log_step
            with:
              city: "{{ city.name }}"

  - step: alert_step
    desc: "Send alert if threshold exceeded"
    type: workbook
    task: alert_task
    with:
      city: "{{ city }}"
      temperature: "{{ max_temp }}"
    next:
      - step: end_city_loop

  - step: log_step
    desc: "Log result if no alert"
    type: workbook
    task: log_task
    with:
      city: "{{ city }}"
    next:
      - step: end_city_loop

  - step: end_city_loop
    desc: "End of the city loop"
    end_loop: city_loop
    result:
      city_result: "{{ fetch_and_evaluate }}"
      alerts: "{{ (city_loop_results | default([])) + [city_result] if city_result else (city_loop_results | default([])) }}"
    next:
      - step: aggregate_alerts
        with:
          alerts: "{{ alerts }}"

  - step: aggregate_alerts
    desc: "Aggregate results after all city loops complete"
    type: workbook
    task: aggregate_alerts_task
    with:
      alerts: "{{ alerts }}"
    next:
      - step: log_aggregate_result
        with:
          summary: "{{ aggregate_alerts.summary }}"
      - when: "{{ aggregate_alerts.global_alert }}"
        then:
          - step: global_alert_step
            with:
              summary: "{{ aggregate_alerts.summary }}"

  - step: log_aggregate_result
    desc: "Log the aggregated alert summary"
    type: workbook
    task: log_aggregate_result_task
    with:
      summary: "{{ aggregate_alerts.summary }}"
    next:
      - step: store_aggregate_result
        with:
          summary: "{{ aggregate_alerts.summary }}"

  - step: global_alert_step
    desc: "Send a global alert if any city triggered an alert"
    type: workbook
    task: global_alert_task
    with:
      summary: "{{ aggregate_alerts.summary }}"
    next:
      - step: store_aggregate_result
        with:
          summary: "{{ aggregate_alerts.summary }}"

  - step: store_aggregate_result
    desc: "Store the aggregated alert summary in DuckDB/Postgres"
    type: workbook
    task: store_aggregate_result_task_postgres_pipeline
    with:
      summary: "{{ aggregate_alerts.summary }}"
    next:
      - step: end

  - step: end
    desc: "End of workflow"

workbooks:

  - name: log_forcast_request
    type: http
    method: GET
    endpoint: "{{ base_url }}/forecast"
    params:
      latitude: "{{ city.lat }}"
      longitude: "{{ city.lon }}"
      hourly: "temperature_2m"
      forecast_days: 1
    timeout: 10

  - name: get_forecast
    type: http
    method: GET
    endpoint: "{{ base_url }}/forecast"
    params:
      latitude: "{{ city.lat }}"
      longitude: "{{ city.lon }}"
      hourly: "temperature_2m"
      forecast_days: 1
    timeout: 10

  - name: evaluate_weather_directly
    type: python
    with:
      city: "{{ city }}"
      threshold: "{{ threshold }}"
      base_url: "{{ base_url }}"
    code: |
      def main(city, threshold, base_url):
          import httpx
          threshold = float(threshold) if threshold not in (None, "") else 25.0
          try:
              resp = httpx.get(
                  f"{base_url}/forecast",
                  params={
                      "latitude": city["lat"],
                      "longitude": city["lon"],
                      "hourly": "temperature_2m",
                      "forecast_days": 1,
                  },
                  timeout=10.0,
              )
              resp.raise_for_status()
              data = resp.json()
          except Exception as e:
              return {"city": city["name"], "max_temp": 0.0, "alert": False, "error": str(e)}

          temps = []
          if isinstance(data, dict):
              hourly = data.get("hourly", {})
              if isinstance(hourly, dict):
                  temps = hourly.get("temperature_2m", []) or []

          max_temp = max(temps) if temps else 0.0
          return {"city": city["name"], "max_temp": max_temp, "alert": bool(max_temp > threshold)}

  - name: evaluate_weather
    type: python
    with:
      city: "{{ city }}"
      threshold: "{{ workload.temperature_threshold }}"
      forecast_data: "{{ get_forecast }}"
    code: |
      def main(city, threshold, forecast_data):
          threshold = float(threshold) if threshold not in (None, "") else 5.0
          temps = []
          if isinstance(forecast_data, dict):
              hourly = forecast_data.get("hourly", {})
              if isinstance(hourly, dict):
                  temps = hourly.get("temperature_2m", []) or []
          max_temp = max(temps) if temps else 0.0
          return {"city": city["name"], "max_temp": max_temp, "alert": bool(max_temp > threshold)}

  - name: alert_task
    type: http
    method: POST
    endpoint: "https://postman-echo.com/post"
    payload:
      kind: "city_alert"
      city: "{{ city.name }}"
      temperature: "{{ temperature }}"
      message: "High temperature alert."
    timeout: 10

  - name: log_task
    type: http
    method: POST
    endpoint: "https://postman-echo.com/post"
    payload:
      kind: "city_log"
      city: "{{ city.name }}"
      message: "No alert needed."
    timeout: 10

  - name: global_alert_task
    type: http
    method: POST
    endpoint: "https://postman-echo.com/post"
    payload:
      kind: "global_alert"
      summary: "{{ summary }}"
      message: "Global weather alert triggered."
    timeout: 10

  - name: aggregate_alerts_task
    type: python
    with:
      alerts: "{{ alerts }}"
    code: |
      def main(alerts):
          if not alerts:
              return {"summary": {"alert_cities": [], "count": 0}, "global_alert": False}
          
          alert_cities = []
          for alert in alerts:
              if isinstance(alert, dict) and alert.get("alert", False):
                  alert_cities.append({
                      "city": alert.get("city", "Unknown"),
                      "max_temp": alert.get("max_temp", 0.0)
                  })
          
          summary = {
              "alert_cities": alert_cities,
              "count": len(alert_cities)
          }
          
          return {
              "summary": summary,
              "global_alert": len(alert_cities) > 0
          }

  - name: log_aggregate_result_task
    type: python
    with:
      summary: "{{ summary }}"
    code: |
      def main(summary):
          print(f"Aggregated weather alert summary: {summary}")
          return {"logged": True, "summary": summary}

  - name: store_aggregate_result_task_postgres_pipeline
    type: duckdb
    with:
      summary: "{{ summary }}"
    database: "data/noetldb/postgres_pipeline.duckdb"
    command: |
      CREATE TABLE IF NOT EXISTS weather_alert_summary (
          id BIGINT,
          alert_cities TEXT,
          alert_count INTEGER,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      );
      
      INSERT INTO weather_alert_summary (id, alert_cities, alert_count) 
      VALUES (
          CAST((EXTRACT(epoch FROM NOW()) * 1000) AS BIGINT),
          '{{ summary.alert_cities | tojson }}',
          {{ summary.count }}
      );
      
      SELECT 'stored_in_duckdb' as status, 
             CAST((EXTRACT(epoch FROM NOW()) * 1000) AS BIGINT) as id,
             '{{ summary | tojson }}' as summary;
