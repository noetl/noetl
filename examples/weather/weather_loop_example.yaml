apiVersion: noetl.io/v1
kind: Playbook
name: weather_example
path: examples/weather/weather_loop_example
metadata:
  name: weather_example
  path: examples/weather/weather_loop_example
workload:
  jobId: '{{ job.uuid }}'
  state: ready
  cities:
  - name: London
    lat: 51.51
    lon: -0.13
  - name: Paris
    lat: 48.85
    lon: 2.35
  - name: Berlin
    lat: 52.52
    lon: 13.41
  base_url: https://api.open-meteo.com/v1
  temperature_threshold: 12
  pg_host: localhost
  pg_port: '30543'
  pg_user: demo
  pg_password: demo
  pg_db: demo_noetl
workflow:
- step: start
  desc: Start Weather Analysis Workflow
  next:
  - when: '{{ workload.state == ''ready'' }}'
    then:
    - step: city_loop
  - else:
    - step: end
- step: city_loop
  type: iterator
  element: city_item
  task:
    data:
      city: '{{ city_item }}'
      base_url: '{{ workload.base_url }}'
      temperature_threshold: '{{ workload.temperature_threshold }}'
    type: playbook
    path: examples/weather/city_process
  next:
  - step: debug_results
  data: '{{ workload.cities }}'
- data:
    results: '{{ city_loop.results }}'
  step: debug_results
  desc: Debug what city_loop.result contains
  type: python
  code: "def main(results):\n    print(f\"DEBUG_RESULTS: city_loop.result = {results}\"\
    )\n    print(f\"DEBUG_RESULTS: type = {type(results)}\")\n    if isinstance(results,\
    \ list):\n        print(f\"DEBUG_RESULTS: length = {len(results)}\")\n       \
    \ for i, item in enumerate(results):\n            print(f\"DEBUG_RESULTS: item[{i}]\
    \ = {item} (type: {type(item)})\")\n    return {\"debug_complete\": True, \"results\"\
    : results}\n"
  next:
  - data:
      alerts: '{{ city_loop.results }}'
    step: aggregate_alerts
- data:
    alerts: '{{ city_loop.results }}'
  step: aggregate_alerts
  desc: Aggregate results after all city loops complete
  type: workbook
  name: aggregate_alerts_task
  next:
  - data:
      summary: '{{ aggregate_alerts.summary | default({''alert_cities'': [], ''count'':
        0}) }}'
    step: log_aggregate_result
- data:
    summary: '{{ aggregate_alerts.summary | default({''alert_cities'': [], ''count'':
      0}) }}'
  step: log_aggregate_result
  desc: Log the aggregated alert summary
  type: workbook
  name: log_aggregate_result_task
  next:
  - data:
      alert_cities: '{{ aggregate_alerts.summary.alert_cities | default([]) }}'
      alert_count: '{{ aggregate_alerts.summary.count | default(0) }}'
    step: store_summary_postgres
- data:
    alert_cities: '{{ alert_cities }}'
    alert_count: '{{ alert_count }}'
  step: store_summary_postgres
  desc: Store aggregated summary in Postgres
  type: workbook
  name: store_summary_postgres_task
  next:
  - step: end
- step: end
  desc: End of workflow
workbook:
- data:
    city: '{{ city }}'
    base_url: '{{ base_url }}'
    temperature_threshold: '{{ temperature_threshold }}'
  name: process_city_weather
  type: python
  code: "def main(city, base_url, temperature_threshold):\n    print(f\"PROCESS_CITY_WEATHER:\
    \ Processing city: {city}\")\n    print(f\"PROCESS_CITY_WEATHER: Temperature threshold:\
    \ {temperature_threshold}\")\n    \n    # Step 1: Get forecast (simplified - just\
    \ return empty data)\n    forecast_data = {}\n    \n    # Step 2: Evaluate weather\n\
    \    try:\n        threshold = float(temperature_threshold) if temperature_threshold\
    \ not in (None, \"\") else 25.0\n    except Exception:\n        threshold = 25.0\n\
    \n    temps = []\n    if isinstance(forecast_data, dict):\n        hourly = forecast_data.get(\"\
    hourly\", {})\n        if isinstance(hourly, dict):\n            temps = hourly.get(\"\
    temperature_2m\", []) or []\n\n    max_temp = max(temps) if temps else 0.0\n \
    \   alert = bool(max_temp > threshold)\n    \n    # Step 3: Determine action\n\
    \    if alert:\n        action = \"alert\"\n        print(f\"PROCESS_CITY_WEATHER:\
    \ Alert needed for {city['name']} - temp {max_temp} > {threshold}\")\n    else:\n\
    \        action = \"log\"\n        print(f\"PROCESS_CITY_WEATHER: No alert for\
    \ {city['name']} - temp {max_temp} <= {threshold}\")\n    \n    # Step 4: Return\
    \ result\n    result = {\n        \"city\": city[\"name\"],\n        \"action\"\
    : action,\n        \"max_temp\": max_temp,\n        \"alert\": alert\n    }\n\
    \    \n    print(f\"PROCESS_CITY_WEATHER: Final result: {result}\")\n    return\
    \ result\n"
- data:
    city: '{{ city }}'
    threshold: '{{ temperature_threshold }}'
    forecast_data: '{{ get_forecast }}'
  name: evaluate_weather
  type: python
  code: "def main(city, threshold, forecast_data):\n    print(f\"City: {city}\")\n\
    \    print(f\"Threshold: {threshold}\")\n    print(f\"Forecast data type: {type(forecast_data)}\"\
    )\n    threshold = float(threshold) if threshold else 5\n    print(f\"Threshold\
    \ after conversion: {threshold}\")\n    temps = []\n    if isinstance(forecast_data,\
    \ dict):\n        print(f\"Forecast data keys: {forecast_data.keys()}\")\n   \
    \     hourly = forecast_data.get('hourly', {})\n        if isinstance(hourly,\
    \ dict) and 'temperature_2m' in hourly:\n            temps = hourly['temperature_2m']\n\
    \            print(f\"Found temps in hourly.temperature_2m: {temps}\")\n     \
    \   elif 'data' in forecast_data and isinstance(forecast_data['data'], dict):\n\
    \            data = forecast_data['data']\n            print(f\"Data keys: {data.keys()}\"\
    )\n            data_hourly = data.get('hourly', {})\n            if isinstance(data_hourly,\
    \ dict) and 'temperature_2m' in data_hourly:\n                temps = data_hourly['temperature_2m']\n\
    \                print(f\"Found temps in data.hourly.temperature_2m: {temps}\"\
    )\n    max_temp = max(temps) if temps else 0\n    print(f\"Max temperature: {max_temp}\"\
    )\n    alert = max_temp > threshold\n    print(f\"Alert needed: {alert}\")\n \
    \   result = {\n        \"city\": city[\"name\"],\n        \"max_temp\": max_temp,\n\
    \        \"alert\": alert\n    }\n    print(f\"Returning result: {result}\")\n\
    \    return result\n"
- name: alert_task
  type: http
  method: POST
  endpoint: https://postman-echo.com/post
  payload:
    city: '{{ city }}'
    temperature: '{{ temperature }}'
    message: High temperature alert.
- name: log_task
  type: http
  method: POST
  endpoint: https://postman-echo.com/post
  payload:
    city: '{{ city }}'
    message: No alert needed.
- name: get_city_districts
  type: http
  method: GET
  endpoint: https://postman-echo.com/post
- data:
    city: '{{ city }}'
    district: '{{ district }}'
  name: process_district
  type: python
  code: "def main(city, district):\n    return {\n        \"city\": city[\"name\"\
    ],\n        \"district\": district[\"name\"],\n        \"processed\": True,\n\
    \        \"timestamp\": \"2024-01-01T12:00:00Z\"\n    }\n"
- data:
    alerts: '{{ alerts }}'
  name: aggregate_alerts_task
  type: python
  code: "def main(alerts):\n    print(f\"AGGREGATE_ALERTS_TASK: Received alerts input:\
    \ {alerts}\")\n    print(f\"AGGREGATE_ALERTS_TASK: Alerts type: {type(alerts)}\"\
    )\n    \n    import ast\n    # Normalize alerts input\n    if isinstance(alerts,\
    \ str):\n        try:\n            alerts = ast.literal_eval(alerts)\n       \
    \ except Exception:\n            alerts = []\n    alerts = alerts or []\n\n  \
    \  print(f\"AGGREGATE_ALERTS_TASK: After normalization: {alerts}\")\n    print(f\"\
    AGGREGATE_ALERTS_TASK: After normalization type: {type(alerts)}\")\n    \n   \
    \ # Unwrap nested results if coming from sub-playbook aggregates\n    normalized\
    \ = []\n    for item in alerts:\n        print(f\"AGGREGATE_ALERTS_TASK: Processing\
    \ item: {item} (type: {type(item)})\")\n        if isinstance(item, dict):\n \
    \           if 'evaluate_weather' in item and isinstance(item['evaluate_weather'],\
    \ dict):\n                normalized.append(item['evaluate_weather'])\n      \
    \      else:\n                normalized.append(item)\n    \n    print(f\"AGGREGATE_ALERTS_TASK:\
    \ Normalized results: {normalized}\")\n    \n    # Compute summary\n    alert_cities\
    \ = [a for a in normalized if isinstance(a, dict) and a.get('alert')]\n    print(f\"\
    AGGREGATE_ALERTS_TASK: Alert cities: {alert_cities}\")\n    \n    global_alert\
    \ = bool(alert_cities)\n    summary = {\n        \"alert_cities\": [a.get(\"city\"\
    ) for a in alert_cities],\n        \"count\": len(alert_cities)\n    }\n    \n\
    \    result = {\"global_alert\": global_alert, \"summary\": summary}\n    print(f\"\
    AGGREGATE_ALERTS_TASK: Final result: {result}\")\n    return result\n"
- name: global_alert_task
  type: http
  method: POST
  endpoint: https://postman-echo.com/post
  payload:
    summary: '{{ summary }}'
    message: Global weather alert triggered.
- data:
    summary: '{{ summary }}'
  name: log_aggregate_result_task
  type: python
  code: "def main(summary):\n    print(f\"Aggregated weather alert summary: {summary}\"\
    )\n    return {\"logged\": True, \"summary\": summary}\n"
- data:
    alert_cities: '{{ alert_cities }}'
    alert_count: '{{ alert_count }}'
  name: store_summary_duckdb_task
  type: duckdb
  command: "-- Create DuckDB table for weather alert summary and insert the current\
    \ summary\nCREATE TABLE IF NOT EXISTS weather_alert_summary (\n  id BIGINT,\n\
    \  alert_cities TEXT,\n  alert_count INTEGER,\n  created_at TIMESTAMP DEFAULT\
    \ CURRENT_TIMESTAMP\n);\n-- Insert aggregated summary. DuckDB does not support\
    \ SQLite's strftime('%s', ...); use date_part('epoch', ...) for epoch seconds\n\
    INSERT INTO weather_alert_summary (id, alert_cities, alert_count)\n  VALUES (\n\
    \    (date_part('epoch', current_timestamp)*1000)::BIGINT,\n    '{{ alert_cities\
    \ | default([], true) | tojson }}',\n    {{ alert_count | default(0, true) }}\n\
    \  );\n\nSELECT * FROM weather_alert_summary ORDER BY created_at DESC LIMIT 5;\n"
- data:
    alert_cities: '{{ alert_cities }}'
    alert_count: '{{ alert_count }}'
    db_host: localhost
    db_port: '30543'
    db_user: demo
    db_password: demo
    db_name: demo_noetl
  name: store_summary_postgres_task
  type: postgres
  command: "-- Create table if not exists\nCREATE TABLE IF NOT EXISTS weather_alert_summary\
    \ (\n  id SERIAL PRIMARY KEY,\n  alert_cities TEXT,\n  alert_count INTEGER,\n\
    \  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Insert aggregated\
    \ summary\nINSERT INTO weather_alert_summary (alert_cities, alert_count)\n  VALUES\
    \ (\n    '{{ alert_cities | default([], true) | tojson }}',\n    {{ alert_count\
    \ | default(0, true) }}\n  );\n\n-- Return recent entries for verification\nSELECT\
    \ * FROM weather_alert_summary ORDER BY id DESC LIMIT 5;\n"
