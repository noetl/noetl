{"version":3,"sources":["ConfigEntry.es6"],"names":[],"mappings":"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","file":"ConfigEntry.js","sourcesContent":["\"use strict\";\nvar nconf = require('nconf');\n\n// www.noetl.io ////////////////////////////////////////////////////////////////////////////////////////////////////////\n// www.noetl.io ///////////////// NoETL ConfigEntry class //////////////////////////////////////////////////////////////\n// www.noetl.io ////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nconst   _confEntryName       = Symbol(\"config entry name\"),\n        _confEntryPath       = Symbol(\"config entry path\"),\n        _entryId             = Symbol(\"object entry id\"),\n        _entryPath           = Symbol(\"object entry path\"),\n        _getConfigEntryName  = Symbol(\"retrieve entry name\"),\n        _getConfEntryPath    = Symbol(\"retrieve entry path\");\n\n/**\n * @class ConfigEntry\n * @classdesc The main class to be used to access configuration entries.\n *\n * @description class creates an object for given config path\n * @param ...arguments\n * @example\n * var workflow = new ConfigEntry(\n * '-',                                     // delimiter to be used as for this._confEntryName\n * 'WORKFLOW',\n * 'TIMESTAMP'\n * );\n */\nmodule.exports = class ConfigEntry{\n    constructor() {\n        let [confEntryName,confEntryPath] = ConfigEntry.getConfigEntryPath(...arguments)\n        this[_confEntryName] = confEntryName\n        this[_confEntryPath] = confEntryPath\n        this[_getConfigEntryName] = () => { return this[_confEntryName] || undefined}\n        this[_getConfEntryPath] = () => { return this[_confEntryPath] || undefined}\n        //configEntryPath = (arguments.length>1) ? ConfigEntryPath.configEntryPath(...arguments) : configEntryPath;\n        let validatedConfigEntry = ConfigEntry.validateConfigEntry(this[_getConfEntryPath]());\n        if (validatedConfigEntry) {\n            this[_entryId] = this.configEntryName;\n            this[_entryPath] = this.configEntryPath;\n            Object.assign(this, ConfigEntry.translateConfigEntryReference({},validatedConfigEntry));\n        }\n    }\n\n    static configEntry() {\n        return new ConfigEntry(...arguments)\n    }\n\n    /**\n     * isObject checks if input is an object and not is an array and not is null.\n     * @param item {object}\n     * @returns {boolean}\n     */\n    static isObject(item) {\n        return (item && typeof item === 'object' && !Array.isArray(item) && item !== null);\n    }\n\n    /**\n     * getConfigEntryPath method gets list of strings ['W','D','A'] and returns 'W:D:A' string.\n     * if first item is ':' or ',' or ';', like ['|','W','D','A'] the first item will be used as\n     * delimiter - returning 'W|D|A' string.\n     * @param [keys]\n     * @returns configEntryPath {object}\n     */\n    static getConfigEntryPath(...keys) {\n        let checkDelimiter = arg => arg.length==1 && ConfigEntry.getDelimiter().indexOf(arg)>-1, configEntryPath = checkDelimiter(keys[0])  ? [keys.slice(1).join(keys[0]),keys.slice(1).join(':')] : [keys.join(':'),keys.join(':') ]  // checkDelimiter returns true if separator exists as a first argument of configEntryPath function that returns array of \"Entry Path Name\" and \"Entry Path\"\n        return configEntryPath\n    }\n\n    static getDelimiter(sep = [' ',':','.',',',';','|','-']) {return sep;};\n\n    set configEntryName(confName) {\n        this[_confEntryName] = confName\n    }\n\n    set configEntryPath(confPath) {\n        this[_confEntryPath] = confPath\n    }\n\n    get configEntryName() {\n        return this[_confEntryName] || undefined;\n    }\n\n    get configEntryPath() {\n        return this[_confEntryPath] || undefined;\n    }\n\n    get entryId() {\n        return this[_entryId] || undefined;\n    }\n\n    get entryPath() {\n        return this[_entryPath] || undefined;\n    }\n\n    /**\n     * validatedConfigValue function gets delimited path string 'Node1:Node2:Node3' and returns 'Node3' value.\n     * @param entryPath String\n     * @returns validatedConfigValue {object}\n     */\n    static validateConfigEntry(entryPath){\n        let validatedConfigValue = nconf.get(entryPath) || undefined;\n        return validatedConfigValue;\n    };\n\n    /**\n     * translateConfigEntryReference makes a deep copy of an object replacing values for the referenced values.\n     * @param refValue\n     * @param srcValue\n     * @returns {object} || [array] || string\n     */\n    static translateConfigEntryReference(refValue, srcValue) {\n        const REGEX = /\\${(.*?)}/g;\n        if (ConfigEntry.isObject(refValue) && ConfigEntry.isObject(srcValue))  {\n            Object.keys(srcValue).forEach(key => {\n                if (ConfigEntry.isObject(srcValue[key])) {\n                    if (!refValue[key]) Object.assign(refValue, { [key]: {} });\n                    ConfigEntry.translateConfigEntryReference(refValue[key], srcValue[key]);\n                } else {\n                    Object.assign(refValue, { [key]: ConfigEntry.translateConfigEntryReference(null,srcValue[key]) });\n                }\n            });\n        } else if (Array.isArray(srcValue)) {\n            return  srcValue.map(item => { return ConfigEntry.translateConfigEntryReference(null,item);})\n        } else if (REGEX.test(srcValue)) {\n            let val = srcValue.replace(REGEX, (match,p1) => {return nconf.get(p1.replace(/\\./g, \":\"));});\n            return ConfigEntry.translateConfigEntryReference( ConfigEntry.isObject(val) ? {} : null, val);\n        } else {\n            return srcValue;\n        }\n        return refValue;\n    }\n\n\n};\n//export {ConfigEntry}"]}