{"version":3,"sources":["ConfigEntry.es6"],"names":[],"mappings":"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","file":"ConfigEntry.js","sourcesContent":["\"use strict\";\nvar nconf = require('nconf');\n\n/**\n * ConfigEntry class creates an object for given config path.\n * @param configEntryPath {Object}\n */\n\nmodule.exports = class ConfigEntry{\n    constructor() {\n        let [confEntryName,confEntryPath] = ConfigEntry.getConfigEntryPath(...arguments)\n        this._confEntryName = confEntryName\n        this._confEntryPath = confEntryPath\n        this.getConfigEntryName = () => { return this._confEntryName || undefined}\n        this.getConfEntryPath = () => { return this._confEntryPath || undefined}\n        //configEntryPath = (arguments.length>1) ? ConfigEntryPath.configEntryPath(...arguments) : configEntryPath;\n        let validatedConfigEntry = ConfigEntry.validateConfigEntry(this.getConfEntryPath());\n        if (validatedConfigEntry) {\n            this._entryId = this.configEntryName;\n            this._entryPath = this.configEntryPath;\n            Object.assign(this, ConfigEntry.translateConfigEntryReference({},validatedConfigEntry));\n        }\n    }\n    static configEntry() {\n        return new ConfigEntry(...arguments)\n    }\n    /**\n     * isObject checks if input is an object and not is an array and not is null.\n     * @param item\n     * @returns {boolean}\n     */\n    static isObject(item) {\n        return (item && typeof item === 'object' && !Array.isArray(item) && item !== null);\n    }\n\n    /**\n     * getConfigEntryPath method gets list of strings ['W','D','A'] and returns 'W:D:A' string.\n     * if first item is ':' or ',' or ';', like ['|','W','D','A'] the first item will be used as\n     * delimiter - returning 'W|D|A' string.\n     * @param [keys]\n     * @returns configEntryPath {object}\n     */\n    static getConfigEntryPath(...keys) {\n        let checkDelimiter = arg => arg.length==1 && ConfigEntry.getDelimiter().indexOf(arg)>-1, configEntryPath = checkDelimiter(keys[0])  ? [keys.slice(1).join(keys[0]),keys.slice(1).join(':')] : [keys.join(':'),keys.join(':') ]  // checkDelimiter returns true if separator exists as a first argument of configEntryPath function that returns array of \"Entry Path Name\" and \"Entry Path\"\n        return configEntryPath\n    }\n    static getDelimiter(sep = [' ',':','.',',',';','|','-']) {return sep;};\n    set configEntryName(confName) {\n        this._confEntryName = confName\n    }\n    set configEntryPath(confPath) {\n        this._confEntryPath = confPath\n    }\n    get configEntryName() {\n        return this._confEntryName || undefined;\n    }\n    get configEntryPath() {\n        return this._confEntryPath || undefined;\n    }\n\n    /**\n     * validatedConfigValue function gets delimited path string 'Node1:Node2:Node3' and returns 'Node3' value.\n     * @param entryPath String\n     * @returns validatedConfigValue {object}\n     */\n    static validateConfigEntry(entryPath){\n        let validatedConfigValue = nconf.get(entryPath) || undefined;\n        return validatedConfigValue;\n    };\n\n    /**\n     * translateConfigEntryReference makes a deep copy of an object replacing values for the referenced values.\n     * @param refValue\n     * @param srcValue\n     * @returns {object} || [array] || string\n     */\n    static translateConfigEntryReference(refValue, srcValue) {\n        const REGEX = /\\${(.*?)}/g;\n        if (ConfigEntry.isObject(refValue) && ConfigEntry.isObject(srcValue))  {\n            Object.keys(srcValue).forEach(key => {\n                if (ConfigEntry.isObject(srcValue[key])) {\n                    if (!refValue[key]) Object.assign(refValue, { [key]: {} });\n                    ConfigEntry.translateConfigEntryReference(refValue[key], srcValue[key]);\n                } else {\n                    Object.assign(refValue, { [key]: ConfigEntry.translateConfigEntryReference(null,srcValue[key]) });\n                }\n            });\n        } else if (Array.isArray(srcValue)) {\n                return  srcValue.map(item => { return ConfigEntry.translateConfigEntryReference(null,item);})\n        } else if (REGEX.test(srcValue)) {\n                let val = srcValue.replace(REGEX, (match,p1) => {return nconf.get(p1.replace(/\\./g, \":\"));});\n                return ConfigEntry.translateConfigEntryReference( ConfigEntry.isObject(val) ? {} : null, val);\n        } else {\n            return srcValue;\n        }\n\n        return refValue;\n    }\n\n    get entryId (){\n        return this._entryId || undefined;\n    }\n\n};\n//export {ConfigEntry}"]}