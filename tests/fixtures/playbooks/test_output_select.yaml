apiVersion: noetl.io/v2
kind: Playbook
metadata:
  name: test_output_select
  path: tests/output_select_test
  description: |
    Test playbook for output_select pattern with large results.

    This demonstrates:
    1. Large result externalization to NATS storage
    2. output_select extraction of small fields
    3. Lazy loading via artifact.get
    4. Template access to extracted fields

workload:
  item_count: 1000
  item_size: 200

workflow:
  # Step 1: Generate large result (must be named 'start')
  - step: start
    tool:
      - generate_data:
          kind: python
          args:
            count: "{{ item_count }}"
            size: "{{ item_size }}"
          code: |
            # Generate large result that exceeds inline threshold (64KB)
            items = [
                {"id": i, "name": f"item_{i}", "data": "x" * size, "status": "active"}
                for i in range(count)
            ]
            result = {
                "status": "success",
                "count": len(items),
                "total_size": sum(len(item["data"]) for item in items),
                "items": items
            }
    # Configure result storage
    result:
      # Auto-select storage tier based on size
      store:
        kind: auto
      # Extract these fields for render_context (available via {{ start.status }})
      output_select:
        - status
        - count
        - total_size
    next:
      spec:
        mode: exclusive
      arcs:
        - step: verify_extracted_fields

  # Step 2: Verify extracted fields are available without loading full data
  - step: verify_extracted_fields
    tool:
      - verify:
          kind: python
          args:
            # These come from output_select - no full data load needed
            status: "{{ start.status }}"
            count: "{{ start.count }}"
            total_size: "{{ start.total_size }}"
            # Check if _ref is present (indicates externalized result)
            has_ref: "{{ start._ref is defined }}"
          code: |
            result = {
                "verified": True,
                "status_received": status,
                "count_received": count,
                "total_size_received": total_size,
                "was_externalized": has_ref,
                "message": f"Verified {count} items with total size {total_size}"
            }
    next:
      spec:
        mode: exclusive
      arcs:
        - step: lazy_load_full_data

  # Step 3: Lazy load full data via artifact.get (only when needed)
  - step: lazy_load_full_data
    tool:
      - load_artifact:
          kind: artifact
          action: get
          args:
            # Access the ResultRef from the externalized result
            result_ref: "{{ start._ref }}"
    next:
      spec:
        mode: exclusive
      arcs:
        - step: process_full_data

  # Step 4: Process the full data (now loaded)
  - step: process_full_data
    tool:
      - process:
          kind: python
          args:
            # Full data is now available from lazy_load step
            data: "{{ lazy_load_full_data.data }}"
          code: |
            if isinstance(data, dict) and "items" in data:
                items = data["items"]
                active_count = sum(1 for item in items if item.get("status") == "active")
                result = {
                    "status": "success",
                    "total_items": len(items),
                    "active_items": active_count,
                    "first_item_id": items[0]["id"] if items else None
                }
            else:
                result = {"status": "error", "message": "Data not in expected format"}
    next:
      spec:
        mode: exclusive
      arcs:
        - step: summary

  # Step 5: Final summary
  - step: summary
    tool:
      - summarize:
          kind: python
          args:
            extraction_verified: "{{ verify_extracted_fields.verified }}"
            was_externalized: "{{ verify_extracted_fields.was_externalized }}"
            full_data_processed: "{{ process_full_data.total_items }}"
          code: |
            result = {
                "test_result": "PASSED" if extraction_verified and was_externalized else "FAILED",
                "output_select_worked": extraction_verified,
                "result_was_externalized": was_externalized,
                "full_data_items_processed": full_data_processed,
                "message": "output_select pattern verified successfully" if extraction_verified else "Test failed"
            }
