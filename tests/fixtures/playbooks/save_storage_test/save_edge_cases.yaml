apiVersion: noetl.io/v2
kind: Playbook
metadata:
  name: save_edge_cases
  path: tests/fixtures/playbooks/save_storage_test/save_edge_cases
  description: "Test playbook for save storage edge cases and error scenarios"

workload:
  pg_auth: pg_local
  test_scenarios:
    - "mixed_data_types"
    - "large_payload"
    - "special_characters"
    - "empty_data"

workflow:
  # Setup: Create tables
  - step: start
    desc: "Create test tables for edge cases"
    tool:
      kind: postgres
      auth: "{{ workload.pg_auth }}"
      command: |
        -- Create table for mixed data types test
        CREATE TABLE IF NOT EXISTS test_mixed_types (
          execution_id VARCHAR,
          string_field VARCHAR,
          integer_field INTEGER,
          float_field DOUBLE PRECISION,
          boolean_field BOOLEAN,
          null_field VARCHAR,
          datetime_field VARCHAR,
          list_field TEXT,
          dict_field TEXT,
          decimal_field DOUBLE PRECISION
        );
        
        -- Create table for special characters test
        CREATE TABLE IF NOT EXISTS test_special_chars (
          execution_id VARCHAR,
          quotes VARCHAR,
          unicode TEXT,
          sql_injection TEXT,
          newlines TEXT,
          backslashes TEXT,
          json_string TEXT
        );
    
    case:
      - when: "{{ event.name == 'step.exit' and response is defined }}"
        then:
          next:
            - step: test_mixed_types

  # Test mixed data types
  - step: test_mixed_types
    desc: "Test save with mixed data types"
    tool:
      kind: python
      auth: {}
      libs:
        datetime:
          from: datetime
          import: datetime
        Decimal:
          from: decimal
          import: Decimal
      args:
        input_data: {}
      code: |
        mixed_data = { 
          "string_field": "test_string",
          "integer_field": 12345,
          "float_field": 3.14159,
          "boolean_field": True,
          "null_field": None,
          "datetime_field": datetime.now().isoformat(),
          "list_field": [1, 2, 3, "mixed", True],
          "dict_field": {"nested": "value", "count": 42},
          "decimal_field": float(Decimal("99.99"))
        }
        
        result = mixed_data
    
    case:
      - when: "{{ event.name == 'step.exit' and response is defined }}"
        then:
          - sink:
              tool:
                kind: postgres
                auth: "{{ workload.pg_auth }}"
                statement: |
                  INSERT INTO test_mixed_types (
                    execution_id, string_field, integer_field, float_field,
                    boolean_field, null_field, datetime_field, list_field,
                    dict_field, decimal_field
                  ) VALUES (
                    '{{ execution_id }}',
                    '{{ response.string_field }}',
                    {{ response.integer_field }},
                    {{ response.float_field }},
                    {% if response.boolean_field %}true{% else %}false{% endif %},
                    {% if response.null_field is none %}NULL{% else %}'{{ response.null_field }}'{% endif %},
                    '{{ response.datetime_field }}',
                    '{{ response.list_field | tojson | replace("'", "''") }}',
                    '{{ response.dict_field | tojson | replace("'", "''") }}',
                    {{ response.decimal_field }}
                  )
          - next:
              - step: test_special_characters

  # Test special characters and unicode
  - step: test_special_characters
    desc: "Test save with special characters and unicode"
    tool:
      kind: python
      auth: {}
      libs: {}
      args:
        input_data: "{{ test_mixed_types }}"
      code: |
        special_data = {
            "quotes": "This has 'single' and \"double\" quotes",
            "unicode": "Unicode: Î±Î²Î³Î´Îµ, ä¸­æ–‡, ðŸš€ðŸŒŸ",
            "sql_injection": "'; DROP TABLE test; --",
            "newlines": "Line 1\nLine 2\r\nLine 3",
            "backslashes": "C:\\path\\to\\file",
            "json_string": '{"embedded": "json", "value": 123}'
        }
        
        result = special_data
    
    case:
      - when: "{{ event.name == 'step.exit' and response is defined }}"
        then:
          sink:
            tool:
              kind: postgres
              auth: "{{ workload.pg_auth }}"
              table: test_special_chars
              mode: insert
              args:
                execution_id: "{{ execution_id }}"
                quotes: "{{ response.quotes }}"
                unicode: "{{ response.unicode }}"
                sql_injection: "{{ response.sql_injection }}"
                newlines: "{{ response.newlines }}"
                backslashes: "{{ response.backslashes }}"
                json_string: "{{ response.json_string }}"
          next:
            - step: test_empty_data

  # Test empty and null data scenarios
  - step: test_empty_data
    desc: "Test save with empty and null data"
    tool:
      kind: python
      auth: {}
      libs: {}
      args:
        input_data: "{{ test_special_characters }}"
      code: |
        empty_scenarios = {
            "empty_string": "",
            "empty_list": [],
            "empty_dict": {},
            "zero_value": 0,
            "false_value": False,
            "none_value": None
        }
        
        result = empty_scenarios
    
    case:
      - when: "{{ event.name == 'step.exit' and response is defined }}"
        then:
          sink:
            tool:
              kind: python
              auth: {}
              libs:
                json: json
              args:
                data: null
              code: |
                # Handle empty/null data gracefully
                processed = {}
                for key, value in data.items():
                    if value is None:
                        processed[key] = "NULL_VALUE"
                    elif value == "":
                        processed[key] = "EMPTY_STRING"
                    elif value == []:
                        processed[key] = "EMPTY_LIST"
                    elif value == {}:
                        processed[key] = "EMPTY_DICT"
                    else:
                        processed[key] = value
                
                result_data = {
                    "original_data": data,
                    "processed_data": processed,
                    "processing_notes": "Handled empty/null values"
                }
                
                print(f"Empty data processing: {json.dumps(result_data, indent=2)}")
                result = result_data
          next:
            - step: test_large_payload

  # Test large payload handling
  - step: test_large_payload
    desc: "Test save with large data payload"
    tool:
      kind: python
      auth: {}
      libs: {}
      args:
        input_data: "{{ test_empty_data }}"
      code: |
        # Generate moderately large dataset
        large_data = {
            "metadata": {
                "test_type": "large_payload",
                "record_count": 100
            },
            "records": []
        }
        
        for i in range(100):
            record = {
                "id": i + 1,
                "name": f"Test Record {i + 1}",
                "description": f"This is a test record with ID {i + 1} " * 5,  # Repeat for size
                "data_field": f"data_value_{i}",
                "large_text": "Lorem ipsum dolor sit amet " * 20  # Large text field
            }
            large_data["records"].append(record)
        
        result = large_data
    
    case:
      - when: "{{ event.name == 'step.exit' and response is defined }}"
        then:
          sink:
            tool:
              kind: duckdb
              commands: |
                -- Create table for large dataset
                CREATE OR REPLACE TABLE test_large_payload (
                  test_type VARCHAR,
                  record_count INTEGER,
                  execution_id VARCHAR,
                  created_at TIMESTAMP
                );
                
                -- Insert test record
                INSERT INTO test_large_payload 
                VALUES ('large_payload_test', {{ response.metadata.record_count }}, '{{ execution_id }}', NOW());
                
                -- Query results
                SELECT * FROM test_large_payload WHERE execution_id = '{{ execution_id }}';
          next:
            - step: test_error_recovery

  # Test error recovery scenarios
  - step: test_error_recovery
    desc: "Test save error handling and recovery"
    tool:
      kind: python
      auth: {}
      libs: {}
      args: {}
      code: |
        # Data that might cause issues but should be handled gracefully            
        potentially_problematic = {
            "valid_field": "this should work",
            "test_execution": "completed",
            "recovery_test": True
        }
        
        result = potentially_problematic
    
    case:
      - when: "{{ event.name == 'step.exit' and response is defined }}"
        then:
          sink:
            tool:
              kind: http
              endpoint: "https://httpbin.org/status/200"
              method: POST
              headers:
                Content-Type: "application/json"
                X-Test-Type: "error-recovery"
              payload:
                test_execution: "{{ response.test_execution }}"
                valid_field: "{{ response.valid_field }}"
                recovery_test: "{{ response.recovery_test }}"
                execution_id: "{{ execution_id }}"
          next:
            - step: test_completion_summary

  # Final summary
  - step: test_completion_summary
    desc: "Summarize edge case testing results"
    tool:
      kind: python
      auth: {}
      libs: {}
      args: {}
      code: |
        summary = {
            "edge_case_tests_completed": [
                "mixed_data_types",
                "special_characters_unicode",
                "empty_null_data",
                "large_payload",
                "error_recovery"
            ],
            "storage_types_tested": [
                "postgres",
                "python", 
                "duckdb",
                "http"
            ],
            "test_status": "completed"
        }
        
        result = summary
    
    case:
      - when: "{{ event.name == 'step.exit' and response is defined }}"
        then:
          sink:
            tool:
              kind: python
              auth: {}
              libs:
                json: json
              args:
                data: "{{ response }}"
              code: |
                summary = {
                    "edge_case_tests": data.get("edge_case_tests_completed", []),
                    "storage_types": data.get("storage_types_tested", []),
                    "status": data.get("test_status")
                }
                print(f"Test Summary: {json.dumps(summary, indent=2)}")
                result = summary
          next:
            - step: end

  # End
  - step: end
    desc: "Edge case testing completed"
    tool:
      kind: python
      auth: {}
      libs: {}
      args: {}
      code: |
        result = {"status": "complete"}