apiVersion: noetl.io/v2
kind: Playbook
metadata:
  name: http_pagination_v2
  path: examples/http_pagination_v2
  labels:
    category: example
    version: v2
    pattern: pagination

workload:
  api_url: "https://api.example.com"
  page_size: 100

workflow:
  - step: start
    desc: "Initialize pagination workflow"
    tool:
      kind: python
      code: |
        def main():
            return {"status": "initialized"}
    
    case:
      - when: "{{ event.name == 'step.exit' }}"
        then:
          next:
            - step: fetch_paginated

  - step: fetch_paginated
    desc: "Fetch data with pagination"
    tool:
      kind: http
      method: GET
      endpoint: "{{ workload.api_url }}/data"
      params:
        page: 1
        pageSize: "{{ workload.page_size }}"
    
    case:
      # Initialize collection on step.enter
      - when: "{{ event.name == 'step.enter' }}"
        then:
          set:
            ctx:
              all_pages: []
              current_page: 1
      
      # Retry on 5xx errors
      - when: "{{ event.name == 'call.done' and error is defined and error.status in [500, 502, 503] }}"
        then:
          retry:
            max_attempts: 3
            backoff_multiplier: 2.0
            initial_delay: 0.5
      
      # Collect and continue pagination if hasMore
      - when: "{{ event.name == 'call.done' and response is defined and response.data.paging.hasMore == true }}"
        then:
          collect:
            from: response.data.items
            into: all_pages
            mode: extend
          call:
            params:
              page: "{{ (response.data.paging.page | int) + 1 }}"
              pageSize: "{{ response.data.paging.pageSize }}"
      
      # Final page - collect and transition
      - when: "{{ event.name == 'call.done' and response is defined and response.data.paging.hasMore == false }}"
        then:
          collect:
            from: response.data.items
            into: all_pages
            mode: extend
          result:
            from: ctx.all_pages
          next:
            - step: process_results
              args:
                items: "{{ ctx.all_pages }}"

  - step: process_results
    desc: "Process collected results"
    tool:
      kind: python
      code: |
        def main(items):
            print(f"Processing {len(items)} items")
            return {"count": len(items), "status": "processed"}
    
    case:
      - when: "{{ event.name == 'call.done' and response is defined }}"
        then:
          result:
            from: response
          next:
            - step: end

  - step: end
    desc: "End workflow"
    tool:
      kind: python
      code: |
        def main():
            return {"status": "complete"}
