apiVersion: noetl.io/v2
kind: Playbook
metadata:
  name: test_loop_with_pagination
  path: tests/pagination/loop_with_pagination/loop_with_pagination
  description: Test loop with HTTP pagination - single step_result after loop completes

workload:
  api_url: "http://paginated-api.test-server.svc.cluster.local:5555"
  endpoints:
    - name: assessments
      path: /api/v1/assessments
      page_size: 10
    - name: assessments2
      path: /api/v1/assessments
      page_size: 15
    - name: assessments3
      path: /api/v1/assessments
      page_size: 20

workflow:
  - step: start
    desc: Start loop + pagination test
    tool:
      kind: python
      auth: {}
      libs: {}
      args: {}
      code: |
        result = {"status": "initialized"}

    case:
      - when: "{{ event.name == 'step.exit' }}"
        then:
          next:
            - step: fetch_all_endpoints

  - step: fetch_all_endpoints
    desc: Loop over endpoints with HTTP pagination - verify single step_result after loop
    loop:
      in: "{{ workload.endpoints }}"
      iterator: endpoint
      mode: sequential
    tool:
      kind: http
      url: "{{ workload.api_url }}{{ endpoint.path }}"
      method: GET
      params:
        page: 1
        pageSize: "{{ endpoint.page_size }}"

    case:
      - when: "{{ event.name == 'call.error' and error.status in [500, 502, 503] }}"
        then:
          retry:
            max_attempts: 3
            backoff_multiplier: 2.0
            initial_delay: 0.5

      - when: "{{ event.name == 'call.done' and response is defined and response.data.paging.hasMore == true }}"
        then:
          collect:
            strategy: append
            path: data.data
            into: pages
          retry:
            params:
              page: "{{ (response.data.paging.page | int) + 1 }}"
              pageSize: "{{ response.data.paging.pageSize }}"

      - when: "{{ event.name == 'call.done' and response is defined and response.data.paging.hasMore != true }}"
        then:
          collect:
            strategy: append
            path: data.data
            into: pages

      - when: "{{ event.name == 'loop.done' }}"
        then:
          next:
            - step: validate_results

  - step: validate_results
    desc: Validate loop + pagination results - expect single aggregated result
    tool:
      kind: python
      auth: {}
      libs: {}
      args:
        loop_results: "{{ fetch_all_endpoints }}"
        workload: "{{ workload }}"
      code: |
        """
        Validate loop execution produced single aggregated result.
        
        Expected structure:
        {
            "results": [
                [item1, item2, ...],  # Iteration 0 (endpoint 1, all pages)
                [item1, item2, ...],  # Iteration 1 (endpoint 2, all pages)
                [item1, item2, ...]   # Iteration 2 (endpoint 3, all pages)
            ],
            "stats": {
                "total": 3,
                "success": 3,
                "failed": 0
            }
        }
        """
        
        print(f"Loop results type: {type(loop_results)}")
        print(f"Loop results keys: {loop_results.keys() if isinstance(loop_results, dict) else 'N/A'}")
        
        # Expect aggregated structure with results array
        assert isinstance(loop_results, dict), f"Expected dict, got {type(loop_results)}"
        assert 'results' in loop_results, "Expected 'results' key in aggregated loop result"
        assert 'stats' in loop_results, "Expected 'stats' key in aggregated loop result"
        
        results = loop_results['results']
        stats = loop_results['stats']
        
        print(f"Number of iterations: {len(results)}")
        print(f"Stats: {stats}")
        
        validation = {
            'total_iterations': len(results),
            'endpoints_tested': [],
            'total_items_fetched': 0
        }
        
        # Validate each iteration result (accumulated pagination data)
        expected_iterations = len(workload['endpoints'])
        assert len(results) == expected_iterations, \
            f"Expected {expected_iterations} iterations, got {len(results)}"
        
        for idx, iteration_result in enumerate(results):
            print(f"\n=== Iteration {idx} ===")
            print(f"Result type: {type(iteration_result)}")
            
            # iteration_result is HTTP response: {url, data: {data: [...], paging: {}}, status_code, ...}
            if isinstance(iteration_result, list):
                items = iteration_result
            elif isinstance(iteration_result, dict):
                # Prefer pagination aggregation if present
                if '_all_collected_items' in iteration_result:
                    items = iteration_result['_all_collected_items']
                elif 'data' in iteration_result and isinstance(iteration_result['data'], dict):
                    # HTTP response has nested data.data structure
                    if 'data' in iteration_result['data']:
                        items = iteration_result['data']['data']
                    else:
                        items = iteration_result['data']
                elif 'value' in iteration_result:
                    items = iteration_result['value']
                else:
                    items = [iteration_result]
            else:
                items = []
            
            endpoint_name = workload['endpoints'][idx]['name']
            items_count = len(items) if isinstance(items, list) else 0
            
            print(f"Endpoint: {endpoint_name}")
            print(f"Items fetched: {items_count}")
            
            validation['endpoints_tested'].append({
                'endpoint': endpoint_name,
                'items_count': items_count
            })
            validation['total_items_fetched'] += items_count
        
        # Pagination collection aggregates all pages for each endpoint
        expected_counts = [35, 35, 35]
        for idx, endpoint_result in enumerate(validation['endpoints_tested']):
            items_count = endpoint_result['items_count']
            endpoint_name = endpoint_result['endpoint']
            expected = expected_counts[idx]
            assert items_count == expected, \
                f"Expected {expected} items for {endpoint_name}, got {items_count}"
        
        # Validate stats
        assert stats['total'] == expected_iterations, \
            f"Stats total should be {expected_iterations}, got {stats['total']}"
        assert stats['success'] == expected_iterations, \
            f"All iterations should succeed, got {stats['success']}/{stats['total']}"
        
        validation['status'] = 'success'
        validation['message'] = \
            f"Successfully validated {len(results)} endpoints with " \
            f"{validation['total_items_fetched']} total items"
        
        result = validation

    case:
      - when: "{{ event.name == 'step.exit' and response is defined }}"
        then:
          next:
            - step: end

  - step: end
    desc: Test complete
    tool:
      kind: python
      auth: {}
      libs: {}
      args: {}
      code: |
        result = {"status": "complete"}
