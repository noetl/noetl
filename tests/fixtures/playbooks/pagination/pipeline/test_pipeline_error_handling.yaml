apiVersion: noetl.io/v2
kind: Playbook
metadata:
  name: test_pipeline_error_handling
  path: tests/pagination/pipeline/errors
  description: 'Tests tool.spec.policy.rules error handling patterns in task sequence
    execution.


    Validates:

    - Retry on transient errors (500, 503)

    - Rate limit handling with Retry-After header

    - Continue on transform errors (skip pattern)

    - Fail on auth errors (401, 403)

    - outcome variable access in policy conditions

    '
workload:
  api_url: http://paginated-api.test-server.svc.cluster.local:5555
  test_results: []
  current_test: null
workflow:
- step: start
  desc: Initialize error handling tests
  tool:
    kind: python
    code: "result = {\n  \"status\": \"initialized\",\n  \"tests_to_run\": [\n   \
      \ \"retry_on_500\",\n    \"retry_on_rate_limit\",\n    \"skip_transform_error\"\
      ,\n    \"fail_on_auth_error\"\n  ]\n}\n"
  set_ctx:
    test_results: '{{ workload.test_results }}'
    current_test: '{{ workload.current_test }}'
  next:
    spec:
      mode: exclusive
    arcs:
    - step: test_retry_transient
- step: test_retry_transient
  desc: Test retry on 500 errors with flaky endpoint
  tool:
  - name: reset_flaky
    kind: http
    url: '{{ api_url }}/api/v1/flaky/reset'
    method: POST
  - name: fetch_flaky
    kind: http
    url: '{{ api_url }}/api/v1/flaky'
    method: GET
    params:
      page: 1
      fail_on: '1'
    spec:
      policy:
        rules:
        - when: '{{ outcome.error.retryable and outcome.error.kind == ''server_error''
            }}'
          then:
            do: retry
            attempts: 3
            backoff: linear
            delay: 0.5
        - when: '{{ outcome.status == ''error'' }}'
          then:
            do: fail
        - else:
            then:
              do: continue
  - name: validate
    kind: python
    args:
      http_response: '{{ _prev }}'
    code: "response_body = http_response.get('data', {})\ndata = response_body.get('data',\
      \ [])\nresult = {\n  'test': 'retry_on_500',\n  'status': 'passed' if len(data)\
      \ > 0 else 'failed',\n  'items_received': len(data),\n  'message': 'Retry succeeded\
      \ after 500 error'\n}\n"
  next:
    spec:
      mode: exclusive
    arcs:
    - step: test_rate_limit
- step: test_rate_limit
  desc: Test rate limit handling with Retry-After header
  tool:
  - name: fetch_1
    kind: http
    url: '{{ api_url }}/api/v1/rate-limited'
    method: GET
    params:
      page: 1
      requests_per_second: 1
    spec:
      policy:
        rules:
        - when: '{{ outcome.error.kind == ''rate_limit'' }}'
          then:
            do: retry
            attempts: 5
            delay: 2.0
        - when: '{{ outcome.error.retryable }}'
          then:
            do: retry
            attempts: 3
        - when: '{{ outcome.status == ''error'' }}'
          then:
            do: fail
        - else:
            then:
              do: continue
  - name: fetch_2
    kind: http
    url: '{{ api_url }}/api/v1/rate-limited'
    method: GET
    params:
      page: 2
      requests_per_second: 1
    spec:
      policy:
        rules:
        - when: '{{ outcome.error.kind == ''rate_limit'' }}'
          then:
            do: retry
            attempts: 5
            delay: 2.0
        - when: '{{ outcome.error.retryable }}'
          then:
            do: retry
            attempts: 3
        - when: '{{ outcome.status == ''error'' }}'
          then:
            do: fail
        - else:
            then:
              do: continue
  - name: validate
    kind: python
    args:
      http_response: '{{ _prev }}'
    code: "response_body = http_response.get('data', {})\ndata = response_body.get('data',\
      \ [])\nresult = {\n  'test': 'retry_on_rate_limit',\n  'status': 'passed',\n\
      \  'items_received': len(data),\n  'message': 'Rate limit handled correctly'\n\
      }\n"
  next:
    spec:
      mode: exclusive
    arcs:
    - step: test_skip_transform
- step: test_skip_transform
  desc: Test continue action on transform errors (skip pattern)
  tool:
  - name: fetch
    kind: http
    url: '{{ api_url }}/api/v1/assessments'
    method: GET
    params:
      page: 1
  - name: transform_bad
    kind: python
    args:
      http_response: '{{ _prev }}'
    code: 'broken = http_response[''nonexistent_key''][''also_missing'']

      result = broken

      '
    spec:
      policy:
        rules:
        - when: '{{ outcome.status == ''error'' }}'
          then:
            do: continue
        - else:
            then:
              do: continue
  - name: validate
    kind: python
    args:
      prev_data: '{{ _prev }}'
    code: "result = {\n  'test': 'skip_transform_error',\n  'status': 'passed',\n\
      \  'skipped': True,\n  'prev_after_skip': prev_data,\n  'message': 'Transform\
      \ error was skipped successfully'\n}\n"
  next:
    spec:
      mode: exclusive
    arcs:
    - step: test_fail_auth
- step: test_fail_auth
  desc: Test fail action on auth errors
  tool:
  - name: fetch_auth_error
    kind: http
    url: '{{ api_url }}/api/v1/errors'
    method: GET
    params:
      error_type: auth
    spec:
      policy:
        rules:
        - when: '{{ outcome.error.kind == ''auth'' }}'
          then:
            do: fail
        - else:
            then:
              do: continue
  - name: should_not_reach
    kind: python
    code: 'result = {''error'': ''This should not execute''}

      '
  next:
    spec:
      mode: exclusive
    arcs:
    - step: generate_report
- step: generate_report
  desc: Generate test results report
  tool:
    kind: python
    args:
      results: '{{ ctx.test_results }}'
    code: "passed = sum(1 for r in results if r.get('status') == 'passed')\nfailed\
      \ = sum(1 for r in results if r.get('status') == 'failed')\ntotal = len(results)\n\
      \nresult = {\n  \"status\": \"ok\" if failed == 0 else \"failed\",\n  \"summary\"\
      : {\n    \"total_tests\": total,\n    \"passed\": passed,\n    \"failed\": failed\n\
      \  },\n  \"test_results\": results,\n  \"policy_features_tested\": [\n    \"\
      retry with exponential backoff\",\n    \"retry with Retry-After header\",\n\
      \    \"continue on error (skip pattern)\",\n    \"fail on non-retryable errors\"\
      ,\n    \"outcome.error.kind condition matching\",\n    \"outcome.error.retryable\
      \ boolean check\",\n    \"outcome.status check\"\n  ]\n}\n"
  next:
    spec:
      mode: exclusive
    arcs:
    - step: end
- step: end
  desc: Tests complete
  tool:
    kind: noop
