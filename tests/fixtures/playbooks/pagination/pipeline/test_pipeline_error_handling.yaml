# NoETL Canonical v10 Playbook
# Tests tool.spec.policy.rules error handling patterns in task sequence execution.

apiVersion: noetl.io/v10
kind: Playbook
metadata:
  name: test_pipeline_error_handling
  path: tests/pagination/pipeline/errors
  description: |
    Tests tool.spec.policy.rules error handling patterns in task sequence execution.

    Validates:
    - Retry on transient errors (500, 503)
    - Rate limit handling with Retry-After header
    - Continue on transform errors (skip pattern)
    - Fail on auth errors (401, 403)
    - outcome variable access in policy conditions

workload:
  api_url: "http://paginated-api.test-server.svc.cluster.local:5555"
  test_results: []
  current_test: null

workflow:
  - step: start
    desc: Initialize error handling tests
    tool:
      kind: python
      code: |
        result = {
          "status": "initialized",
          "tests_to_run": [
            "retry_on_500",
            "retry_on_rate_limit",
            "skip_transform_error",
            "fail_on_auth_error"
          ]
        }
    set_ctx:
      test_results: "{{ workload.test_results }}"
      current_test: "{{ workload.current_test }}"
    next:
      spec:
        mode: exclusive
      arcs:
        - step: test_retry_transient

  - step: test_retry_transient
    desc: Test retry on 500 errors with flaky endpoint
    tool:
      - reset_flaky:
          kind: http
          url: "{{ api_url }}/api/v1/flaky/reset"
          method: POST

      - fetch_flaky:
          kind: http
          url: "{{ api_url }}/api/v1/flaky"
          method: GET
          params:
            page: 1
            fail_on: "1"
          spec:
            policy:
              rules:
                - when: "{{ outcome.error.retryable and outcome.error.kind == 'server_error' }}"
                  then:
                    do: retry
                    attempts: 3
                    backoff: linear
                    delay: 0.5
                - when: "{{ outcome.status == 'error' }}"
                  then:
                    do: fail
                - else:
                    then:
                      do: continue

      - validate:
          kind: python
          args:
            http_response: "{{ _prev }}"
          code: |
            response_body = http_response.get('data', {})
            data = response_body.get('data', [])
            result = {
              'test': 'retry_on_500',
              'status': 'passed' if len(data) > 0 else 'failed',
              'items_received': len(data),
              'message': 'Retry succeeded after 500 error'
            }
    next:
      spec:
        mode: exclusive
      arcs:
        - step: test_rate_limit

  - step: test_rate_limit
    desc: Test rate limit handling with Retry-After header
    tool:
      - fetch_1:
          kind: http
          url: "{{ api_url }}/api/v1/rate-limited"
          method: GET
          params:
            page: 1
            requests_per_second: 1
          spec:
            policy:
              rules:
                - when: "{{ outcome.error.kind == 'rate_limit' }}"
                  then:
                    do: retry
                    attempts: 5
                    delay: 2.0
                - when: "{{ outcome.error.retryable }}"
                  then:
                    do: retry
                    attempts: 3
                - when: "{{ outcome.status == 'error' }}"
                  then:
                    do: fail
                - else:
                    then:
                      do: continue

      - fetch_2:
          kind: http
          url: "{{ api_url }}/api/v1/rate-limited"
          method: GET
          params:
            page: 2
            requests_per_second: 1
          spec:
            policy:
              rules:
                - when: "{{ outcome.error.kind == 'rate_limit' }}"
                  then:
                    do: retry
                    attempts: 5
                    delay: 2.0
                - when: "{{ outcome.error.retryable }}"
                  then:
                    do: retry
                    attempts: 3
                - when: "{{ outcome.status == 'error' }}"
                  then:
                    do: fail
                - else:
                    then:
                      do: continue

      - validate:
          kind: python
          args:
            http_response: "{{ _prev }}"
          code: |
            response_body = http_response.get('data', {})
            data = response_body.get('data', [])
            result = {
              'test': 'retry_on_rate_limit',
              'status': 'passed',
              'items_received': len(data),
              'message': 'Rate limit handled correctly'
            }
    next:
      spec:
        mode: exclusive
      arcs:
        - step: test_skip_transform

  - step: test_skip_transform
    desc: Test continue action on transform errors (skip pattern)
    tool:
      - fetch:
          kind: http
          url: "{{ api_url }}/api/v1/assessments"
          method: GET
          params:
            page: 1

      - transform_bad:
          kind: python
          args:
            http_response: "{{ _prev }}"
          code: |
            broken = http_response['nonexistent_key']['also_missing']
            result = broken
          spec:
            policy:
              rules:
                - when: "{{ outcome.status == 'error' }}"
                  then:
                    do: continue
                - else:
                    then:
                      do: continue

      - validate:
          kind: python
          args:
            prev_data: "{{ _prev }}"
          code: |
            result = {
              'test': 'skip_transform_error',
              'status': 'passed',
              'skipped': True,
              'prev_after_skip': prev_data,
              'message': 'Transform error was skipped successfully'
            }
    next:
      spec:
        mode: exclusive
      arcs:
        - step: test_fail_auth

  - step: test_fail_auth
    desc: Test fail action on auth errors
    tool:
      - fetch_auth_error:
          kind: http
          url: "{{ api_url }}/api/v1/errors"
          method: GET
          params:
            error_type: "auth"
          spec:
            policy:
              rules:
                - when: "{{ outcome.error.kind == 'auth' }}"
                  then:
                    do: fail
                - else:
                    then:
                      do: continue

      - should_not_reach:
          kind: python
          code: |
            result = {'error': 'This should not execute'}
    next:
      spec:
        mode: exclusive
      arcs:
        - step: generate_report

  - step: generate_report
    desc: Generate test results report
    tool:
      kind: python
      args:
        results: "{{ ctx.test_results }}"
      code: |
        passed = sum(1 for r in results if r.get('status') == 'passed')
        failed = sum(1 for r in results if r.get('status') == 'failed')
        total = len(results)

        result = {
          "status": "ok" if failed == 0 else "failed",
          "summary": {
            "total_tests": total,
            "passed": passed,
            "failed": failed
          },
          "test_results": results,
          "policy_features_tested": [
            "retry with exponential backoff",
            "retry with Retry-After header",
            "continue on error (skip pattern)",
            "fail on non-retryable errors",
            "outcome.error.kind condition matching",
            "outcome.error.retryable boolean check",
            "outcome.status check"
          ]
        }
    next:
      spec:
        mode: exclusive
      arcs:
        - step: end

  - step: end
    desc: Tests complete
    tool:
      kind: noop
