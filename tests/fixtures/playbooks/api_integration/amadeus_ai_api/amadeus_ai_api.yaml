apiVersion: noetl.io/v2
kind: Playbook
metadata:
  name: amadeus_ai_api
  path: api_integration/amadeus_ai_api
  description: Complete Amadeus AI travel API integration with OpenAI translation
  version: "3.2"
  labels:
    feature: result_storage
    category: api_integration

executor:
  profile: distributed
  version: noetl-runtime/2

workload:
  pg_auth: pg_k8s
  gcp_auth: google_oauth
  openai_secret_path: projects/1014428265962/secrets/openai-api-key/versions/1
  amadeus_key_path: projects/1014428265962/secrets/api-key-test-api-amadeus-com/versions/1
  amadeus_secret_path: projects/1014428265962/secrets/api-secret-test-api-amadeus-com/versions/1
  query: I want a one-way flight from SFO to JFK on March 15, 2026 for 1 adult
  request_id: ""
  gateway_url: "http://gateway.gateway.svc.cluster.local:8090"
  api_url: "https://test.api.amadeus.com"
  callback_url: ""

keychain:
  - name: openai_token
    kind: secret_manager
    provider: gcp
    scope: global
    auth: "{{ gcp_auth }}"
    map:
      api_key: '{{ openai_secret_path }}'

  - name: amadeus_credentials
    kind: secret_manager
    provider: gcp
    scope: global
    auth: "{{ gcp_auth }}"
    map:
      client_id: '{{ amadeus_key_path }}'
      client_secret: '{{ amadeus_secret_path }}'

  - name: amadeus_token
    kind: oauth2
    scope: global
    auto_renew: true
    endpoint: https://test.api.amadeus.com/v1/security/oauth2/token
    method: POST
    headers:
      Content-Type: application/x-www-form-urlencoded
    data:
      grant_type: client_credentials
      client_id: '{{ keychain.amadeus_credentials.client_id }}'
      client_secret: '{{ keychain.amadeus_credentials.client_secret }}'

workflow:
  - step: init_db
    desc: Verify DB connection (tables already exist)
    tool:
      - verify_connection:
          kind: postgres
          auth: pg_k8s
          query: |
            SELECT 1;
          spec:
            policy:
              rules:
                - when: "{{ outcome.status == 'error' }}"
                  then: { do: fail }
                - else:
                    then: { do: continue }
            result:
              inline_max_bytes: 8192
    next:
      spec: { mode: exclusive }
      arcs:
        - step: run_amadeus_ai

  - step: run_amadeus_ai
    desc: |
      Single-step pipeline:
      1) OpenAI translates user query -> Amadeus query
      2) Amadeus API call
      3) Transform + OpenAI summary/translation
      4) Persist event records + final result
      5) Optional callback
    tool:
      - openai_translate_query:
          kind: http
          method: POST
          url: "https://api.openai.com/v1/chat/completions"
          headers:
            Authorization: "Bearer {{ keychain.openai_token.api_key }}"
            Content-Type: "application/json"
          body:
            model: "gpt-4o-mini"
            messages:
              - role: system
                content: "Translate user travel request into an Amadeus Search API query (JSON or query params). Return ONLY JSON."
              - role: user
                content: "{{ workload.query }}"
          spec:
            timeout: { connect: 10, read: 30 }
            policy:
              rules:
                - when: "{{ outcome.status == 'error' and outcome.http.status in [429,500,502,503,504] }}"
                  then: { do: retry, attempts: 8, backoff: exponential, delay: 2.0 }
                - when: "{{ outcome.status == 'error' and outcome.http.status in [401,403] }}"
                  then: { do: fail }
                - when: "{{ outcome.status == 'error' }}"
                  then: { do: fail }
                - else:
                    then: { do: continue }
            result:
              inline_max_bytes: 8192

      - log_openai_query_event:
          kind: postgres
          auth: pg_k8s
          query: |
            INSERT INTO amadeus_ai_events (execution_id, event_type, api_call_type)
            VALUES ('{{ execution_id }}', 'openai.translate_query', 'openai');
          spec:
            policy:
              rules:
                - when: "{{ outcome.status == 'error' }}"
                  then: { do: fail }
                - else:
                    then: { do: continue }

      - build_amadeus_query:
          kind: python
          args:
            openai_response: "{{ openai_translate_query }}"
          code: |
            import json
            import re

            # Extract content from OpenAI response
            raw = ""
            if isinstance(openai_response, dict):
                data = openai_response.get("data", {})
                choices = data.get("choices", [])
                if choices:
                    raw = choices[0].get("message", {}).get("content", "")

            # Strip markdown code blocks if present
            raw = raw.strip()
            if raw.startswith("```"):
                raw = re.sub(r'^```\w*\n?', '', raw)
                raw = re.sub(r'\n?```$', '', raw)
                raw = raw.strip()

            # Parse the JSON
            try:
                parsed = json.loads(raw) if raw else {}
            except Exception:
                parsed = {}

            # Transform to Amadeus Flight Offers Search API format
            origin = parsed.get("origin") or parsed.get("originLocationCode") or "SFO"
            dest = parsed.get("destination") or parsed.get("destinationLocationCode") or "JFK"
            dep_date = parsed.get("departureDate") or "2026-03-15"
            adults = parsed.get("adults") or 1

            amadeus_query = {
                "currencyCode": "USD",
                "originDestinations": [{
                    "id": "1",
                    "originLocationCode": origin,
                    "destinationLocationCode": dest,
                    "departureDateTimeRange": {"date": dep_date}
                }],
                "travelers": [{"id": "1", "travelerType": "ADULT"} for _ in range(adults)],
                "sources": ["GDS"],
                "searchCriteria": {
                    "maxFlightOffers": 10
                }
            }

            # Return dict directly - will be serialized by HTTP executor
            result = {
                "amadeus_query": amadeus_query
            }
          spec:
            policy:
              rules:
                - when: "{{ outcome.status == 'error' }}"
                  then: { do: fail }
                - else:
                    then: { do: continue }
            result:
              inline_max_bytes: 8192

      # Token already obtained via keychain.amadeus_token - use noop
      - amadeus_oauth_token:
          kind: noop
          spec:
            policy:
              rules:
                - else:
                    then: { do: continue }

      - amadeus_search:
          kind: http
          method: POST
          url: "{{ workload.api_url }}/v2/shopping/flight-offers"
          headers:
            Authorization: "Bearer {{ keychain.amadeus_token.access_token }}"
            Content-Type: "application/json"
          body:
            currencyCode: "USD"
            originDestinations:
              - id: "1"
                originLocationCode: "{{ build_amadeus_query.amadeus_query.originDestinations[0].originLocationCode }}"
                destinationLocationCode: "{{ build_amadeus_query.amadeus_query.originDestinations[0].destinationLocationCode }}"
                departureDateTimeRange:
                  date: "{{ build_amadeus_query.amadeus_query.originDestinations[0].departureDateTimeRange.date }}"
            travelers:
              - id: "1"
                travelerType: "ADULT"
            sources:
              - "GDS"
            searchCriteria:
              maxFlightOffers: 10
          spec:
            timeout: { connect: 10, read: 60 }
            policy:
              rules:
                - when: "{{ outcome.status == 'error' and outcome.http.status in [429,500,502,503,504] }}"
                  then: { do: retry, attempts: 10, backoff: exponential, delay: 2.0 }
                - when: "{{ outcome.status == 'error' and outcome.http.status in [401,403] }}"
                  then: { do: fail }
                - when: "{{ outcome.status == 'error' }}"
                  then: { do: fail }
                - else:
                    then: { do: continue }
            result:
              inline_max_bytes: 262144

      - log_amadeus_event:
          kind: postgres
          auth: pg_k8s
          query: |
            INSERT INTO amadeus_ai_events (execution_id, event_type, api_call_type)
            VALUES ('{{ execution_id }}', 'amadeus.search', 'amadeus');
          spec:
            policy:
              rules:
                - when: "{{ outcome.status == 'error' }}"
                  then: { do: fail }
                - else:
                    then: { do: continue }

      - compact_amadeus_payload:
          kind: python
          args:
            amadeus: "{{ amadeus_search }}"
          code: |
            data = {}
            if isinstance(amadeus, dict):
                data = amadeus.get("data") or amadeus
            offers = data.get("data") if isinstance(data, dict) else None
            if not isinstance(offers, list):
                offers = []
            compact = []
            for o in offers[:10]:
                try:
                    price = (o.get("price") or {}).get("total")
                    itineraries = o.get("itineraries") or []
                    compact.append({
                        "id": o.get("id"),
                        "price_total": price,
                        "itineraries_count": len(itineraries),
                    })
                except Exception:
                    continue
            result = {
                "offers_preview": compact,
                "offers_total": len(offers),
            }
          spec:
            policy:
              rules:
                - when: "{{ outcome.status == 'error' }}"
                  then: { do: fail }
                - else:
                    then: { do: continue }
            result:
              inline_max_bytes: 65536

      - openai_translate_response:
          kind: http
          method: POST
          url: "https://api.openai.com/v1/chat/completions"
          headers:
            Authorization: "Bearer {{ keychain.openai_token.api_key }}"
            Content-Type: "application/json"
          body:
            model: "gpt-4o-mini"
            messages:
              - role: system
                content: |
                  You are a travel assistant. Summarize flight offers and return user-friendly text.
                  Use the provided compact JSON. If offers_total==0, explain no offers found.
              - role: user
                content: "{{ compact_amadeus_payload | tojson }}"
          spec:
            timeout: { connect: 10, read: 60 }
            policy:
              rules:
                - when: "{{ outcome.status == 'error' and outcome.http.status in [429,500,502,503,504] }}"
                  then: { do: retry, attempts: 6, backoff: exponential, delay: 2.0 }
                - when: "{{ outcome.status == 'error' and outcome.http.status in [401,403] }}"
                  then: { do: fail }
                - when: "{{ outcome.status == 'error' }}"
                  then: { do: fail }
                - else:
                    then: { do: continue }
            result:
              inline_max_bytes: 8192

      - log_openai_response_event:
          kind: postgres
          auth: pg_k8s
          query: |
            INSERT INTO amadeus_ai_events (execution_id, event_type, api_call_type)
            VALUES ('{{ execution_id }}', 'openai.translate_response', 'openai');
          spec:
            policy:
              rules:
                - when: "{{ outcome.status == 'error' }}"
                  then: { do: fail }
                - else:
                    then: { do: continue }

      - persist_result:
          kind: postgres
          auth: pg_k8s
          query: |
            INSERT INTO amadeus_ai_results (
              execution_id,
              query_text,
              amadeus_query,
              openai_query_ref,
              amadeus_ref,
              openai_response_ref,
              summary_text
            )
            VALUES (
              '{{ execution_id }}',
              '{{ workload.query | default("") | replace("''", "''''") }}',
              '',
              '{}'::jsonb,
              '{}'::jsonb,
              '{}'::jsonb,
              ''
            );
          spec:
            policy:
              rules:
                - when: "{{ outcome.status == 'error' }}"
                  then: { do: fail }
                - else:
                    then: { do: continue }

      # Optional callback - noop when no callback URL configured
      - callback_if_requested:
          kind: noop
          spec:
            policy:
              rules:
                - else:
                    then: { do: continue }

    next:
      spec: { mode: exclusive }
      arcs:
        - step: end

  - step: end
    desc: Finished
    tool:
      - done:
          kind: noop
