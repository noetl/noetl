apiVersion: noetl.io/v2
kind: Playbook
metadata:
  name: amadeus_ai_api
  path: api_integration/amadeus_ai_api
  description: Complete Amadeus AI travel API integration with OpenAI translation
  version: "3.2"
  labels:
    feature: result_storage
    category: api_integration

# Canonical v10 root sections only:
# metadata, executor, workload, workflow, workbook
executor:
  profile: distributed
  version: noetl-runtime/2



workload:
  pg_auth: pg_k8s
  gcp_auth: google_oauth
  openai_secret_path: projects/1014428265962/secrets/openai-api-key/versions/1
  amadeus_key_path: projects/1014428265962/secrets/api-key-test-api-amadeus-com/versions/1
  amadeus_secret_path: projects/1014428265962/secrets/api-secret-test-api-amadeus-com/versions/1
  query: I want a one-way flight from SFO to JFK on March 15, 2026 for 1 adult
  request_id: ""
  gateway_url: "http://gateway.gateway.svc.cluster.local:8090"

keychain:
  - name: openai_token
    kind: secret_manager
    provider: gcp
    scope: global
    auth: "{{ gcp_auth }}"
    map:
      api_key: '{{ openai_secret_path }}'

  - name: amadeus_credentials
    kind: secret_manager
    provider: gcp
    scope: global
    auth: "{{ gcp_auth }}"
    map:
      client_id: '{{ amadeus_key_path }}'
      client_secret: '{{ amadeus_secret_path }}'

  - name: amadeus_token
    kind: oauth2
    scope: global
    auto_renew: true
    endpoint: https://test.api.amadeus.com/v1/security/oauth2/token
    method: POST
    headers:
      Content-Type: application/x-www-form-urlencoded
    data:
      grant_type: client_credentials
      client_id: '{{ keychain.amadeus_credentials.client_id }}'
      client_secret: '{{ keychain.amadeus_credentials.client_secret }}'

workflow:
  - step: init_db
    desc: Ensure DB tables exist for event + results (reference-first)
    tool:
      - ensure_tables:
          kind: postgres
          auth: pg_k8s
          query: |
            CREATE TABLE IF NOT EXISTS amadeus_ai_events (
              id BIGSERIAL PRIMARY KEY,
              execution_id TEXT NOT NULL,
              event_type TEXT NOT NULL,
              created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
              payload_ref JSONB NOT NULL,
              payload_meta JSONB
            );

            CREATE TABLE IF NOT EXISTS amadeus_ai_results (
              id BIGSERIAL PRIMARY KEY,
              execution_id TEXT NOT NULL,
              created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
              query_text TEXT,
              amadeus_query TEXT,
              openai_query_ref JSONB,
              amadeus_ref JSONB,
              openai_response_ref JSONB,
              summary_text TEXT
            );
          spec:
            policy:
              rules:
                - when: "{{ outcome.status == 'error' and outcome.pg.code in ['40001','40P01'] }}"
                  then: { do: retry, attempts: 5, backoff: exponential, delay: 2.0 }
                - when: "{{ outcome.status == 'error' }}"
                  then: { do: fail }
                - else:
                    then: { do: continue }
            result:
              inline_max_bytes: 8192
    next:
      spec: { mode: exclusive }
      arcs:
        - step: run_amadeus_ai

  - step: run_amadeus_ai
    desc: |
      Single-step pipeline (Canonical v10):
      1) OpenAI translates user query -> Amadeus query
      2) Amadeus API call
      3) Transform + OpenAI summary/translation
      4) Persist reference-only event records + final result
      5) Optional callback
    tool:
      # --- 1) OpenAI translate user query -> Amadeus query (reference-first) ---
      - openai_translate_query:
          kind: http
          method: POST
          url: "https://api.openai.com/v1/chat/completions"
          headers:
            Authorization: "Bearer {{ keychain.openai_token.api_key }}"
            Content-Type: "application/json"
          body:
            model: "gpt-4o-mini"
            messages:
              - role: system
                content: "Translate user travel request into an Amadeus Search API query (JSON or query params). Return ONLY JSON."
              - role: user
                content: "{{ workload.query }}"
          spec:
            timeout: { connect: 10, read: 30 }
            policy:
              rules:
                - when: "{{ outcome.status == 'error' and outcome.http.status in [429,500,502,503,504] }}"
                  then: { do: retry, attempts: 8, backoff: exponential, delay: 2.0 }
                - when: "{{ outcome.status == 'error' and outcome.http.status in [401,403] }}"
                  then: { do: fail }
                - when: "{{ outcome.status == 'error' }}"
                  then: { do: fail }
                - else:
                    then: { do: continue }
            result:
              store:
                kind: auto
                scope: execution
                ttl: "2h"
                compression: gzip
              inline_max_bytes: 8192
              preview_max_bytes: 2048
              select:
                - path: "$.choices[0].message.content"
                  as: raw_content
                - path: "$.usage.total_tokens"
                  as: tokens_used

      - log_openai_query_event:
          kind: postgres
          auth: pg_k8s
          query: |
            INSERT INTO amadeus_ai_events (execution_id, event_type, payload_ref, payload_meta)
            VALUES (
              '{{ execution_id }}',
              'openai.translate_query',
              '{{ openai_translate_query.__ref__ | tojson }}'::jsonb,
              jsonb_build_object(
                'tokens_used', '{{ openai_translate_query.tokens_used | default(0) }}',
                'content_preview', '{{ openai_translate_query.raw_content | default('') | replace('"','\"') }}'
              )
            );
          spec:
            policy:
              rules:
                - when: "{{ outcome.status == 'error' and outcome.pg.code in ['40001','40P01'] }}"
                  then: { do: retry, attempts: 5, backoff: exponential, delay: 2.0 }
                - when: "{{ outcome.status == 'error' }}"
                  then: { do: fail }
                - else:
                    then: { do: continue }

      - build_amadeus_query:
          kind: python
          args:
            raw: "{{ openai_translate_query.raw_content }}"
          code: |
            import json
            raw = raw or "{}"
            try:
                obj = json.loads(raw)
            except Exception:
                obj = {"query": raw}
            amadeus_query = obj.get("query") or obj.get("params") or obj
            result = {
                "amadeus_query": json.dumps(amadeus_query) if not isinstance(amadeus_query, str) else amadeus_query
            }
          spec:
            policy:
              rules:
                - when: "{{ outcome.status == 'error' }}"
                  then: { do: fail }
                - else:
                    then: { do: continue }
            result:
              inline_max_bytes: 8192

      # --- 2) OAuth + Call Amadeus (reference-first, but keep enough inline for immediate transform) ---
      - amadeus_oauth_token:
          kind: http
          method: POST
          url: "{{ workload.api_url }}/v1/security/oauth2/token"
          headers:
            Content-Type: "application/x-www-form-urlencoded"
          form:
            grant_type: "client_credentials"
            client_id: "{{ keychain.amadeus_key.value }}"
            client_secret: "{{ keychain.amadeus_secret.value }}"
          spec:
            timeout: { connect: 10, read: 30 }
            policy:
              rules:
                - when: "{{ outcome.status == 'error' and outcome.http.status in [429,500,502,503,504] }}"
                  then: { do: retry, attempts: 8, backoff: exponential, delay: 2.0 }
                - when: "{{ outcome.status == 'error' and outcome.http.status in [401,403] }}"
                  then: { do: fail }
                - when: "{{ outcome.status == 'error' }}"
                  then: { do: fail }
                - else:
                    then: { do: continue }
            result:
              store: { kind: auto, scope: execution, ttl: "2h", compression: gzip }
              inline_max_bytes: 8192
              select:
                - path: "$.access_token"
                  as: access_token
                - path: "$.expires_in"
                  as: expires_in

      - amadeus_search:
          kind: http
          method: POST
          url: "{{ workload.api_url }}/v2/shopping/flight-offers"
          headers:
            Authorization: "Bearer {{ amadeus_oauth_token.access_token }}"
            Content-Type: "application/json"
          body: "{{ build_amadeus_query.amadeus_query }}"
          spec:
            timeout: { connect: 10, read: 60 }
            policy:
              rules:
                - when: "{{ outcome.status == 'error' and outcome.http.status in [429,500,502,503,504] }}"
                  then: { do: retry, attempts: 10, backoff: exponential, delay: 2.0 }
                - when: "{{ outcome.status == 'error' and outcome.http.status in [401,403] }}"
                  then: { do: fail }
                - when: "{{ outcome.status == 'error' }}"
                  then: { do: fail }
                - else:
                    then: { do: continue }
            result:
              store:
                kind: auto
                scope: execution
                ttl: "2h"
                compression: gzip
              inline_max_bytes: 262144
              preview_max_bytes: 4096
              select:
                - path: "$.meta.count"
                  as: offer_count
                - path: "$.errors[0].code"
                  as: first_error_code

      - log_amadeus_event:
          kind: postgres
          auth: pg_k8s
          query: |
            INSERT INTO amadeus_ai_events (execution_id, event_type, payload_ref, payload_meta)
            VALUES (
              '{{ execution_id }}',
              'amadeus.search',
              '{{ amadeus_search.__ref__ | tojson }}'::jsonb,
              jsonb_build_object(
                'offer_count', '{{ amadeus_search.offer_count | default(0) }}',
                'first_error_code', '{{ amadeus_search.first_error_code | default('') }}'
              )
            );
          spec:
            policy:
              rules:
                - when: "{{ outcome.status == 'error' and outcome.pg.code in ['40001','40P01'] }}"
                  then: { do: retry, attempts: 5, backoff: exponential, delay: 2.0 }
                - when: "{{ outcome.status == 'error' }}"
                  then: { do: fail }
                - else:
                    then: { do: continue }

      # --- 3) Transform to compact payload and translate/format via OpenAI ---
      - compact_amadeus_payload:
          kind: python
          args:
            amadeus: "{{ amadeus_search }}"
          code: |
            data = {}
            if isinstance(amadeus, dict):
                data = amadeus.get("data") or amadeus
            offers = data.get("data") if isinstance(data, dict) else None
            if not isinstance(offers, list):
                offers = []
            compact = []
            for o in offers[:10]:
                try:
                    price = (o.get("price") or {}).get("total")
                    itineraries = o.get("itineraries") or []
                    compact.append({
                        "id": o.get("id"),
                        "price_total": price,
                        "itineraries_count": len(itineraries),
                    })
                except Exception:
                    continue
            result = {
                "offers_preview": compact,
                "offers_total": len(offers),
            }
          spec:
            policy:
              rules:
                - when: "{{ outcome.status == 'error' }}"
                  then: { do: fail }
                - else:
                    then: { do: continue }
            result:
              inline_max_bytes: 65536

      - openai_translate_response:
          kind: http
          method: POST
          url: "https://api.openai.com/v1/chat/completions"
          headers:
            Authorization: "Bearer {{ keychain.openai_token.api_key }}"
            Content-Type: "application/json"
          body:
            model: "gpt-4o-mini"
            messages:
              - role: system
                content: |
                  You are a travel assistant. Summarize flight offers and return user-friendly text.
                  Use the provided compact JSON. If offers_total==0, explain no offers found.
              - role: user
                content: "{{ compact_amadeus_payload | tojson }}"
          spec:
            timeout: { connect: 10, read: 60 }
            policy:
              rules:
                - when: "{{ outcome.status == 'error' and outcome.http.status in [429,500,502,503,504] }}"
                  then: { do: retry, attempts: 6, backoff: exponential, delay: 2.0 }
                - when: "{{ outcome.status == 'error' and outcome.http.status in [401,403] }}"
                  then: { do: fail }
                - when: "{{ outcome.status == 'error' }}"
                  then: { do: fail }
                - else:
                    then: { do: continue }
            result:
              store: { kind: auto, scope: execution, ttl: "2h", compression: gzip }
              inline_max_bytes: 8192
              select:
                - path: "$.choices[0].message.content"
                  as: summary_text

      - log_openai_response_event:
          kind: postgres
          auth: pg_k8s
          query: |
            INSERT INTO amadeus_ai_events (execution_id, event_type, payload_ref, payload_meta)
            VALUES (
              '{{ execution_id }}',
              'openai.translate_response',
              '{{ openai_translate_response.__ref__ | tojson }}'::jsonb,
              jsonb_build_object('summary_preview', '{{ openai_translate_response.summary_text | default('') | replace('"','\"') }}')
            );
          spec:
            policy:
              rules:
                - when: "{{ outcome.status == 'error' and outcome.pg.code in ['40001','40P01'] }}"
                  then: { do: retry, attempts: 5, backoff: exponential, delay: 2.0 }
                - when: "{{ outcome.status == 'error' }}"
                  then: { do: fail }
                - else:
                    then: { do: continue }

      # --- 4) Persist final result (refs only + summary text) ---
      - persist_result:
          kind: postgres
          auth: pg_k8s
          query: |
            INSERT INTO amadeus_ai_results (
              execution_id,
              query_text,
              amadeus_query,
              openai_query_ref,
              amadeus_ref,
              openai_response_ref,
              summary_text
            )
            VALUES (
              '{{ execution_id }}',
              '{{ workload.query | replace("'", "''") }}',
              '{{ build_amadeus_query.amadeus_query | replace("'", "''") }}',
              '{{ openai_translate_query.__ref__ | tojson }}'::jsonb,
              '{{ amadeus_search.__ref__ | tojson }}'::jsonb,
              '{{ openai_translate_response.__ref__ | tojson }}'::jsonb,
              '{{ openai_translate_response.summary_text | default('') | replace("'", "''") }}'
            );
          spec:
            policy:
              rules:
                - when: "{{ outcome.status == 'error' and outcome.pg.code in ['40001','40P01'] }}"
                  then: { do: retry, attempts: 5, backoff: exponential, delay: 2.0 }
                - when: "{{ outcome.status == 'error' }}"
                  then: { do: fail }
                - else:
                    then: { do: continue }

      # --- 5) Optional callback (skip if request_id/callback_url missing) ---
      - callback_if_requested:
          kind: http
          method: POST
          url: "{{ workload.callback_url }}"
          headers:
            Authorization: "Bearer {{ keychain.callback_secret.value }}"
            Content-Type: "application/json"
          body:
            request_id: "{{ workload.request_id }}"
            execution_id: "{{ execution_id }}"
            summary: "{{ openai_translate_response.summary_text | default('') }}"
            result_ref: "{{ openai_translate_response.__ref__ | tojson }}"
          spec:
            policy:
              rules:
                - when: "{{ workload.request_id == '' }}"
                  then: { do: skip }
                - when: "{{ workload.callback_url == '' }}"
                  then: { do: skip }
                - when: "{{ outcome.status == 'error' and outcome.http.status in [429,500,502,503,504] }}"
                  then: { do: retry, attempts: 6, backoff: exponential, delay: 2.0 }
                - when: "{{ outcome.status == 'error' }}"
                  then: { do: fail }
                - else:
                    then: { do: continue }

    next:
      spec: { mode: exclusive }
      arcs:
        - step: end

  - step: end
    desc: Finished
    tool:
      - done:
          kind: noop
