apiVersion: noetl.io/v2
kind: Playbook
metadata:
  name: check_playbook_access
  path: api_integration/auth0/check_playbook_access
  description: |
    Check if user has permission to access a playbook.

    Input:
      - session_token: NoETL session token
      - playbook_path: Path to playbook
      - action: Action type (execute, view, modify)

    Output:
      - allowed: Boolean
  tags:
    - auth0
    - authorization

workload:
  session_token: "{{ session_token }}"
  playbook_path: "{{ playbook_path }}"
  action: "{{ action | default('execute') }}"
  db_credential: pg_auth
  callback_subject: ""  # Legacy - kept for compatibility
  request_id: ""
  # Gateway URL for HTTP callbacks (use K8s service name in cluster)
  gateway_url: "http://gateway.gateway.svc.cluster.local:8090"

workflow:
  - step: start
    desc: Begin access check
    tool:
      kind: python
      code: |
        print(f"DEBUG: request_id = {context.get('request_id', '')}")
        result = {"status": "initialized"}
    case:
      - when: "{{ event.name == 'call.done' }}"
        then:
          - next:
              - step: get_user_from_session

  - step: get_user_from_session
    desc: Get user from session
    spec:
      case_mode: exclusive  # First matching case wins
    tool:
      kind: postgres
      auth: "{{ workload.db_credential }}"
      command: |
        SELECT s.user_id, u.email, u.display_name
        FROM auth.sessions s
        JOIN auth.users u ON s.user_id = u.user_id
        WHERE s.session_token = '{{ workload.session_token }}'
          AND s.is_active = true
          AND s.expires_at > NOW()
          AND u.is_active = true;
    case:
      - when: "{{ event.name == 'call.done' and result.command_0 is defined and result.command_0.rows | length > 0 }}"
        then:
          - next:
              - step: check_permission
      - when: "{{ event.name == 'call.done' }}"
        then:
          - next:
              - step: access_denied

  - step: check_permission
    desc: Check permissions
    spec:
      case_mode: exclusive  # First matching case wins
    tool:
      kind: postgres
      auth: "{{ workload.db_credential }}"
      command: |
        SELECT
          COUNT(*) > 0 as has_permission
        FROM auth.user_roles ur
        JOIN auth.roles r ON ur.role_id = r.role_id
        JOIN auth.playbook_permissions pp ON r.role_id = pp.role_id
        WHERE ur.user_id = {{ get_user_from_session.command_0.rows[0].user_id }}
          AND (ur.expires_at IS NULL OR ur.expires_at > NOW())
          AND (
            pp.playbook_path = '{{ workload.playbook_path }}'
            OR (pp.allow_pattern IS NOT NULL AND '{{ workload.playbook_path }}' LIKE pp.allow_pattern)
          )
          AND (pp.deny_pattern IS NULL OR '{{ workload.playbook_path }}' NOT LIKE pp.deny_pattern)
          AND (
            ('{{ workload.action }}' = 'execute' AND pp.can_execute = true)
            OR ('{{ workload.action }}' = 'view' AND pp.can_view = true)
            OR ('{{ workload.action }}' = 'modify' AND pp.can_modify = true)
          );
    case:
      - when: "{{ event.name == 'call.done' and result.command_0 is defined and result.command_0.rows | length > 0 and result.command_0.rows[0].has_permission }}"
        then:
          - next:
              - step: access_granted
      - when: "{{ event.name == 'call.done' }}"
        then:
          - next:
              - step: access_denied

  - step: access_granted
    desc: Return allowed
    spec:
      case_mode: exclusive  # First matching case wins
    tool:
      kind: python
      args:
        playbook_path: "{{ workload.playbook_path }}"
        action: "{{ workload.action }}"
        user_id: "{{ get_user_from_session.command_0.rows[0].user_id }}"
        email: "{{ get_user_from_session.command_0.rows[0].email }}"
        display_name: "{{ get_user_from_session.command_0.rows[0].display_name }}"
      code: |
        result = {
            "allowed": True,
            "playbook_path": playbook_path,
            "action": action,
            "user": {"user_id": user_id, "email": email, "display_name": display_name},
            "message": f"Access granted to {action} playbook"
        }
    case:
      # If request_id is set, send callback to gateway via HTTP
      - when: "{{ event.name == 'call.done' and request_id }}"
        then:
          - sink:
              tool:
                kind: http
                method: POST
                url: "{{ gateway_url }}/api/internal/callback"
                headers:
                  Content-Type: application/json
                data:
                  request_id: "{{ request_id }}"
                  status: "success"
                  data:
                    allowed: true
                    playbook_path: "{{ result.playbook_path }}"
                    permission_type: "{{ result.action }}"
                    user:
                      user_id: "{{ get_user_from_session.command_0.rows[0].user_id }}"
                      email: "{{ get_user_from_session.command_0.rows[0].email }}"
                      display_name: "{{ get_user_from_session.command_0.rows[0].display_name }}"
                    message: "{{ result.message }}"
          - next:
              - step: end
      - when: "{{ event.name == 'call.done' }}"
        then:
          - next:
              - step: end

  - step: access_denied
    desc: Return denied
    spec:
      case_mode: exclusive  # First matching case wins
    tool:
      kind: python
      args:
        playbook_path: "{{ workload.playbook_path }}"
        action: "{{ workload.action }}"
      code: |
        result = {
            "allowed": False,
            "playbook_path": playbook_path,
            "action": action,
            "message": "Access denied"
        }
    case:
      # If request_id is set, send callback to gateway via HTTP
      - when: "{{ event.name == 'call.done' and request_id }}"
        then:
          - sink:
              tool:
                kind: http
                method: POST
                url: "{{ gateway_url }}/api/internal/callback"
                headers:
                  Content-Type: application/json
                data:
                  request_id: "{{ request_id }}"
                  status: "success"
                  data:
                    allowed: false
                    playbook_path: "{{ result.playbook_path }}"
                    permission_type: "{{ result.action }}"
                    message: "{{ result.message }}"
          - next:
              - step: end
      - when: "{{ event.name == 'call.done' }}"
        then:
          - next:
              - step: end

  - step: end
    desc: Complete
    tool:
      kind: python
      code: |
        result = {"status": "complete"}
