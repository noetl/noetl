apiVersion: noetl.io/v2
kind: Playbook
metadata:
  name: check_playbook_access
  path: api_integration/auth0/check_playbook_access
  description: |
    Check if user has permission to access a playbook.

    Input:
      - session_token: NoETL session token
      - playbook_path: Path to playbook
      - action: Action type (execute, view, modify)

    Output:
      - allowed: Boolean
  tags:
    - auth0
    - authorization

workload:
  # Input parameters - provided by execution request
  session_token: ""
  playbook_path: ""
  action: "execute"
  # Configuration
  db_credential: pg_auth
  callback_subject: ""  # Legacy - kept for compatibility
  request_id: ""
  # Gateway URL for HTTP callbacks (use K8s service name in cluster)
  gateway_url: "http://gateway.gateway.svc.cluster.local"

workflow:
  - step: start
    desc: Begin access check
    tool:
      kind: python
      code: |
        print(f"DEBUG: request_id = {context.get('request_id', '')}")
        result = {"status": "initialized"}
    next:
      spec:
        mode: exclusive
      arcs:
        - step: get_user_from_session

  - step: get_user_from_session
    desc: Get user from session
    tool:
      kind: postgres
      auth: "{{ db_credential }}"
      command: |
        SELECT s.user_id, u.email, u.display_name
        FROM auth.sessions s
        JOIN auth.users u ON s.user_id = u.user_id
        WHERE s.session_token = '{{ session_token }}'
          AND s.is_active = true
          AND s.expires_at > NOW()
          AND u.is_active = true;
    next:
      spec:
        mode: exclusive
      arcs:
        - step: check_permission
          when: "{{ get_user_from_session.command_0 is defined and get_user_from_session.command_0.rows | length > 0 }}"
        - step: access_denied
          when: "{{ get_user_from_session.command_0 is not defined or get_user_from_session.command_0.rows | length == 0 }}"

  - step: check_permission
    desc: Check permissions
    tool:
      kind: postgres
      auth: "{{ db_credential }}"
      command: |
        SELECT
          COUNT(*) > 0 as has_permission
        FROM auth.user_roles ur
        JOIN auth.roles r ON ur.role_id = r.role_id
        JOIN auth.playbook_permissions pp ON r.role_id = pp.role_id
        WHERE ur.user_id = {{ get_user_from_session.command_0.rows[0].user_id }}
          AND (ur.expires_at IS NULL OR ur.expires_at > NOW())
          AND (
            pp.playbook_path = '{{ playbook_path }}'
            OR (pp.allow_pattern IS NOT NULL AND '{{ playbook_path }}' LIKE pp.allow_pattern)
          )
          AND (pp.deny_pattern IS NULL OR '{{ playbook_path }}' NOT LIKE pp.deny_pattern)
          AND (
            ('{{ action }}' = 'execute' AND pp.can_execute = true)
            OR ('{{ action }}' = 'view' AND pp.can_view = true)
            OR ('{{ action }}' = 'modify' AND pp.can_modify = true)
          );
    next:
      spec:
        mode: exclusive
      arcs:
        - step: access_granted
          when: "{{ check_permission.command_0 is defined and check_permission.command_0.rows | length > 0 and check_permission.command_0.rows[0].has_permission }}"
        - step: access_denied
          when: "{{ check_permission.command_0 is not defined or check_permission.command_0.rows | length == 0 or not check_permission.command_0.rows[0].has_permission }}"

  - step: access_granted
    desc: Return allowed
    tool:
      kind: python
      args:
        playbook_path: "{{ playbook_path }}"
        action: "{{ action }}"
        user_id: "{{ get_user_from_session.command_0.rows[0].user_id }}"
        email: "{{ get_user_from_session.command_0.rows[0].email }}"
        display_name: "{{ get_user_from_session.command_0.rows[0].display_name }}"
      code: |
        result = {
            "allowed": True,
            "playbook_path": playbook_path,
            "action": action,
            "user": {"user_id": user_id, "email": email, "display_name": display_name},
            "message": f"Access granted to {action} playbook"
        }
    next:
      spec:
        mode: exclusive
      arcs:
        - step: send_granted_callback
          when: "{{ request_id }}"
        - step: end
          when: "{{ not request_id }}"

  - step: send_granted_callback
    desc: Send access granted callback to gateway
    tool:
      kind: http
      method: POST
      url: "{{ gateway_url }}/api/internal/callback"
      headers:
        Content-Type: application/json
      data:
        request_id: "{{ request_id }}"
        status: "success"
        data:
          allowed: true
          playbook_path: "{{ access_granted.playbook_path }}"
          permission_type: "{{ access_granted.action }}"
          user:
            user_id: "{{ get_user_from_session.command_0.rows[0].user_id }}"
            email: "{{ get_user_from_session.command_0.rows[0].email }}"
            display_name: "{{ get_user_from_session.command_0.rows[0].display_name }}"
          message: "{{ access_granted.message }}"
    next:
      spec:
        mode: exclusive
      arcs:
        - step: end

  - step: access_denied
    desc: Return denied
    tool:
      kind: python
      args:
        playbook_path: "{{ playbook_path }}"
        action: "{{ action }}"
      code: |
        result = {
            "allowed": False,
            "playbook_path": playbook_path,
            "action": action,
            "message": "Access denied"
        }
    next:
      spec:
        mode: exclusive
      arcs:
        - step: send_denied_callback
          when: "{{ request_id }}"
        - step: end
          when: "{{ not request_id }}"

  - step: send_denied_callback
    desc: Send access denied callback to gateway
    tool:
      kind: http
      method: POST
      url: "{{ gateway_url }}/api/internal/callback"
      headers:
        Content-Type: application/json
      data:
        request_id: "{{ request_id }}"
        status: "success"
        data:
          allowed: false
          playbook_path: "{{ access_denied.playbook_path }}"
          permission_type: "{{ access_denied.action }}"
          message: "{{ access_denied.message }}"
    next:
      spec:
        mode: exclusive
      arcs:
        - step: end

  - step: end
    desc: Complete
    tool:
      kind: python
      code: |
        result = {"status": "complete"}
