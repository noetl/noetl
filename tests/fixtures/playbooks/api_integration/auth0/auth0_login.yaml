apiVersion: noetl.io/v2
kind: Playbook
metadata:
  name: auth0_login
  path: api_integration/auth0/auth0_login
  description: |
    Authenticate user with Auth0 and create NoETL session.

    Input:
      - auth0_token: Auth0 ID token (JWT)
      - client_ip: Client IP (optional, defaults to 0.0.0.0)

    Output:
      - session_token: NoETL session token
      - user_id: Internal user ID
  tags:
    - auth0
    - authentication

workload:
  auth0_token: ""
  client_ip: "0.0.0.0"
  auth0_domain: "mestumre-development.us.auth0.com"
  db_credential: pg_auth
  callback_subject: ""
  request_id: ""

workflow:
  - step: start
    desc: Begin Auth0 login
    tool:
      kind: python
      libs:
        json: json
      code: |
        print(f"DEBUG: workload = {json.dumps(context.get('workload', {}), indent=2)}")
        result = {
            "status": "initialized",
            "auth0_token_present": bool(context.get('workload', {}).get('auth0_token')),
            "client_ip_present": bool(context.get('workload', {}).get('client_ip'))
        }
    case:
      - when: "{{ event.name == 'call.done' }}"
        then:
          - next:
              next:
                - step: validate_token

  - step: validate_token
    desc: Decode Auth0 ID token (JWT)
    tool:
      kind: python
      libs:
        base64: base64
        json: json
      code: |
        token = context.get('workload', {}).get('auth0_token', '')
        try:
            parts = token.split('.')
            if len(parts) != 3:
                raise ValueError("Invalid JWT format")
            payload = parts[1]
            padding = 4 - (len(payload) % 4)
            if padding != 4:
                payload += '=' * padding
            decoded_bytes = base64.urlsafe_b64decode(payload)
            decoded = json.loads(decoded_bytes)
            result = {
                "sub": decoded.get("sub"),
                "email": decoded.get("email"),
                "name": decoded.get("name", decoded.get("email")),
                "email_verified": decoded.get("email_verified", False)
            }
        except Exception as e:
            result = {"error": str(e)}
    spec:
      case_mode: inclusive
    case:
      # On error with callback_subject, send error callback
      - when: "{{ event.name == 'call.done' and result.error is defined and workload.callback_subject }}"
        then:
          - send_error_callback:
              tool:
                kind: gateway
                action: callback
                data:
                  request_id: "{{ workload.request_id }}"
                  status: "error"
                  error: "{{ result.error }}"
                  message: "Token validation failed"
          - next:
              next:
                - step: end
      # On error without callback, just end
      - when: "{{ event.name == 'call.done' and result.error is defined }}"
        then:
          - next:
              next:
                - step: end
      # On success, proceed to upsert_user
      - when: "{{ event.name == 'call.done' and result.sub is defined }}"
        then:
          - next:
              next:
                - step: upsert_user

  - step: upsert_user
    desc: Create or update user
    tool:
      kind: postgres
      auth: "{{ workload.db_credential }}"
      command: |
        INSERT INTO auth.users (auth0_id, email, display_name, last_login_at)
        VALUES ('{{ validate_token.sub }}', '{{ validate_token.email }}', '{{ validate_token.name }}', NOW())
        ON CONFLICT (auth0_id)
        DO UPDATE SET
          email = EXCLUDED.email,
          display_name = EXCLUDED.display_name,
          last_login_at = NOW()
        RETURNING user_id, email, display_name, is_active;
    case:
      - when: "{{ event.name == 'call.done' and result.command_0 is defined }}"
        then:
          - next:
              next:
                - step: create_session

  - step: create_session
    desc: Create session
    tool:
      kind: postgres
      auth: "{{ workload.db_credential }}"
      command: |
        INSERT INTO auth.sessions (
          user_id,
          session_token,
          auth0_token,
          expires_at,
          ip_address
        )
        VALUES (
          {{ upsert_user.command_0.rows[0].user_id }},
          replace(gen_random_uuid()::text, '-', ''),
          '{{ workload.auth0_token }}',
          NOW() + INTERVAL '24 hours',
          '{{ workload.client_ip }}'::inet
        )
        RETURNING session_token, user_id, expires_at;
    case:
      - when: "{{ event.name == 'call.done' and result.command_0 is defined }}"
        then:
          - next:
              next:
                - step: success

  - step: success
    desc: Return session token and optionally send callback
    tool:
      kind: python
      args:
        session_token: "{{ create_session.command_0.rows[0].session_token }}"
        user_id: "{{ create_session.command_0.rows[0].user_id }}"
        expires_at: "{{ create_session.command_0.rows[0].expires_at }}"
        email: "{{ upsert_user.command_0.rows[0].email }}"
      code: |
        result = {
            "status": "authenticated",
            "session_token": session_token,
            "user": {"user_id": user_id, "email": email},
            "expires_at": str(expires_at)
        }
    spec:
      case_mode: inclusive
    case:
      # If callback_subject is set, send callback to gateway (same worker)
      - when: "{{ event.name == 'call.done' and workload.callback_subject }}"
        then:
          - send_callback:
              tool:
                kind: gateway
                action: callback
                data:
                  status: "{{ result.status }}"
                  session_token: "{{ result.session_token }}"
                  user: "{{ result.user }}"
                  expires_at: "{{ result.expires_at }}"
      # Always transition to end (next: acts as break)
      - when: "{{ event.name == 'call.done' }}"
        then:
          - next:
              next:
                - step: end

  - step: end
    desc: Complete
    tool:
      kind: python
      code: |
        result = {"status": "complete"}
