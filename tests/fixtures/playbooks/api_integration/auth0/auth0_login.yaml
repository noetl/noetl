apiVersion: noetl.io/v2
kind: Playbook
metadata:
  name: auth0_login
  path: api_integration/auth0/auth0_login
  description: |
    Authenticate user with Auth0 and create NoETL session.

    OPTIMIZED v2: Reduced from 5 steps to 4 steps for faster execution (~200ms).
    - Merged start + validate_token into single step
    - Uses connection pooling for postgres
    - Uses CTE for combined user upsert + session creation
    - Uses inline task lists for callbacks

    Flow:
      1. start: Validate JWT token (merged with entry point)
      2. create_user_session: Upsert user + create session (pooled postgres CTE)
      3. cache_and_callback: Cache session + send callback (inline tasks)
      4. end: Complete

    Gateway Integration:
      - Gateway calls this playbook when user authenticates via Auth0
      - After completion, gateway can fetch session directly from NATS K/V
      - NATS K/V acts as session cache; Postgres is source of truth

    Input:
      - auth0_token: Auth0 ID token (JWT)
      - client_ip: Client IP (optional, defaults to 0.0.0.0)
      - request_id: Gateway request ID for callback

    Output (via callback):
      - session_token: NoETL session token
      - user: User details (user_id, email, display_name)
      - expires_at: Session expiration timestamp
  tags:
    - auth0
    - authentication
    - nats
    - gateway
    - optimized

workload:
  auth0_token: ""
  client_ip: "0.0.0.0"
  auth0_domain: "mestumre-development.us.auth0.com"
  db_credential: pg_auth
  nats_credential: nats_credential
  session_bucket: sessions
  callback_subject: ""
  request_id: ""
  gateway_url: "http://gateway.gateway.svc.cluster.local:8090"

workflow:
  # Step 1: Entry point + JWT validation (merged)
  - step: start
    desc: Validate Auth0 ID token (JWT) - entry point
    spec:
      case_mode: exclusive
    tool:
      kind: python
      libs:
        base64: base64
        json: json
      code: |
        token = context.get('auth0_token', '')
        try:
            parts = token.split('.')
            if len(parts) != 3:
                raise ValueError("Invalid JWT format")
            payload = parts[1]
            padding = 4 - (len(payload) % 4)
            if padding != 4:
                payload += '=' * padding
            decoded_bytes = base64.urlsafe_b64decode(payload)
            decoded = json.loads(decoded_bytes)
            result = {
                "sub": decoded.get("sub"),
                "email": decoded.get("email"),
                "name": decoded.get("name", decoded.get("email")),
                "email_verified": decoded.get("email_verified", False)
            }
        except Exception as e:
            result = {"error": str(e)}
    case:
      # Error with callback - send error and end (inline task)
      - when: "{{ (event.name == 'call.error' or (event.name == 'call.done' and result.error is defined)) and request_id }}"
        then:
          - send_error_callback:
              tool:
                kind: http
                method: POST
                url: "{{ gateway_url }}/api/internal/callback"
                headers:
                  Content-Type: application/json
                data:
                  request_id: "{{ request_id }}"
                  status: "error"
                  data:
                    error: "{{ result.error | default(event.error) | default('Token validation failed') }}"
                    message: "Token validation failed"
          - next:
              - step: end
      # Error without callback - just end
      - when: "{{ event.name == 'call.error' or (event.name == 'call.done' and result.error is defined) }}"
        then:
          - next:
              - step: end
      # Success - proceed to create user session
      - when: "{{ event.name == 'call.done' and result.sub is defined }}"
        then:
          - next:
              - step: create_user_session

  # Step 2: Combined upsert user + create session (pooled postgres CTE)
  - step: create_user_session
    desc: Upsert user and create session in single transaction
    tool:
      kind: postgres
      auth: "{{ db_credential }}"
      pool: {}
      command: |
        WITH upserted_user AS (
          INSERT INTO auth.users (auth0_id, email, display_name, last_login_at)
          VALUES ('{{ start.sub }}', '{{ start.email }}', '{{ start.name }}', NOW())
          ON CONFLICT (auth0_id)
          DO UPDATE SET
            email = EXCLUDED.email,
            display_name = EXCLUDED.display_name,
            last_login_at = NOW()
          RETURNING user_id, email, display_name, is_active
        )
        INSERT INTO auth.sessions (user_id, session_token, auth0_token, expires_at, ip_address)
        SELECT
          u.user_id,
          replace(gen_random_uuid()::text, '-', ''),
          '{{ auth0_token }}',
          NOW() + INTERVAL '24 hours',
          '{{ client_ip }}'::inet
        FROM upserted_user u
        RETURNING
          session_token,
          user_id,
          expires_at,
          (SELECT email FROM upserted_user) as email,
          (SELECT display_name FROM upserted_user) as display_name;
    case:
      - when: "{{ event.name == 'call.done' and result.command_0 is defined }}"
        then:
          - next:
              - step: cache_and_callback
      # On error with callback
      - when: "{{ event.name == 'call.error' and request_id }}"
        then:
          - send_error_callback:
              tool:
                kind: http
                method: POST
                url: "{{ gateway_url }}/api/internal/callback"
                headers:
                  Content-Type: application/json
                data:
                  request_id: "{{ request_id }}"
                  status: "error"
                  data:
                    error: "{{ event.error | default('Database error') }}"
                    message: "Failed to create session"
          - next:
              - step: end
      # On error without callback
      - when: "{{ event.name == 'call.error' }}"
        then:
          - next:
              - step: end

  # Step 3: Cache session in NATS and send callback
  - step: cache_and_callback
    desc: Cache session in NATS K/V and send callback to gateway
    spec:
      case_mode: exclusive
    tool:
      kind: nats
      auth: "{{ nats_credential }}"
      operation: kv_put
      bucket: "{{ session_bucket }}"
      key: "{{ create_user_session.command_0.rows[0].session_token }}"
      value:
        session_token: "{{ create_user_session.command_0.rows[0].session_token }}"
        user_id: "{{ create_user_session.command_0.rows[0].user_id }}"
        email: "{{ create_user_session.command_0.rows[0].email }}"
        display_name: "{{ create_user_session.command_0.rows[0].display_name }}"
        expires_at: "{{ create_user_session.command_0.rows[0].expires_at }}"
        is_active: true
    case:
      # Success with callback - send callback inline (no extra step)
      - when: "{{ event.name == 'call.done' and request_id }}"
        then:
          - send_success_callback:
              tool:
                kind: http
                method: POST
                url: "{{ gateway_url }}/api/internal/callback"
                headers:
                  Content-Type: application/json
                data:
                  request_id: "{{ request_id }}"
                  status: "success"
                  data:
                    status: "authenticated"
                    session_token: "{{ create_user_session.command_0.rows[0].session_token }}"
                    user:
                      user_id: "{{ create_user_session.command_0.rows[0].user_id }}"
                      email: "{{ create_user_session.command_0.rows[0].email }}"
                      display_name: "{{ create_user_session.command_0.rows[0].display_name }}"
                    expires_at: "{{ create_user_session.command_0.rows[0].expires_at }}"
          - next:
              - step: end
      # Success without callback
      - when: "{{ event.name == 'call.done' }}"
        then:
          - next:
              - step: end
      # NATS cache failed but still send callback (Postgres is source of truth)
      - when: "{{ event.name == 'call.error' and request_id }}"
        then:
          - send_success_callback:
              tool:
                kind: http
                method: POST
                url: "{{ gateway_url }}/api/internal/callback"
                headers:
                  Content-Type: application/json
                data:
                  request_id: "{{ request_id }}"
                  status: "success"
                  data:
                    status: "authenticated"
                    session_token: "{{ create_user_session.command_0.rows[0].session_token }}"
                    user:
                      user_id: "{{ create_user_session.command_0.rows[0].user_id }}"
                      email: "{{ create_user_session.command_0.rows[0].email }}"
                      display_name: "{{ create_user_session.command_0.rows[0].display_name }}"
                    expires_at: "{{ create_user_session.command_0.rows[0].expires_at }}"
          - next:
              - step: end
      # NATS failed without callback - still end successfully
      - when: "{{ event.name == 'call.error' }}"
        then:
          - next:
              - step: end

  - step: end
    desc: Complete
    tool:
      kind: python
      code: |
        result = {"status": "complete"}
