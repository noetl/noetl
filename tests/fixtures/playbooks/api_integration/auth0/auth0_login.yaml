apiVersion: noetl.io/v2
kind: Playbook
metadata:
  name: auth0_login
  path: api_integration/auth0/auth0_login
  description: |
    Authenticate user with Auth0 and create NoETL session.

    OPTIMIZED v2: Reduced from 5 steps to 4 steps for faster execution (~200ms).
    - Merged start + validate_token into single step
    - Uses connection pooling for postgres
    - Uses CTE for combined user upsert + session creation
    - Uses inline task lists for callbacks

    Flow:
      1. start: Validate JWT token (merged with entry point)
      2. create_user_session: Upsert user + create session (pooled postgres CTE)
      3. cache_and_callback: Cache session + send callback (inline tasks)
      4. end: Complete

    Gateway Integration:
      - Gateway calls this playbook when user authenticates via Auth0
      - After completion, gateway can fetch session directly from NATS K/V
      - NATS K/V acts as session cache; Postgres is source of truth

    Input:
      - auth0_token: Auth0 ID token (JWT)
      - client_ip: Client IP (optional, defaults to 0.0.0.0)
      - request_id: Gateway request ID for callback

    Output (via callback):
      - session_token: NoETL session token
      - user: User details (user_id, email, display_name)
      - expires_at: Session expiration timestamp
  tags:
    - auth0
    - authentication
    - nats
    - gateway
    - optimized

workload:
  auth0_token: ""
  client_ip: "0.0.0.0"
  auth0_domain: "mestumre-development.us.auth0.com"
  db_credential: pg_auth
  nats_credential: nats_credential
  session_bucket: sessions
  callback_subject: ""
  request_id: ""
  gateway_url: "http://gateway.gateway.svc.cluster.local:8090"

workflow:
  # Step 1: Entry point + JWT validation (merged)
  - step: start
    desc: Validate Auth0 ID token (JWT) - entry point
    tool:
      kind: python
      libs:
        base64: base64
        json: json
      code: |
        token = context.get('auth0_token', '')
        try:
            parts = token.split('.')
            if len(parts) != 3:
                raise ValueError("Invalid JWT format")
            payload = parts[1]
            padding = 4 - (len(payload) % 4)
            if padding != 4:
                payload += '=' * padding
            decoded_bytes = base64.urlsafe_b64decode(payload)
            decoded = json.loads(decoded_bytes)
            result = {
                "sub": decoded.get("sub"),
                "email": decoded.get("email"),
                "name": decoded.get("name", decoded.get("email")),
                "email_verified": decoded.get("email_verified", False)
            }
        except Exception as e:
            result = {"error": str(e)}
      eval:
        - expr: "{{ outcome.status == 'error' }}"
          do: continue
        - else:
            do: continue
    next:
      - step: send_token_error_callback
        when: "{{ (result.error is defined) and request_id }}"
      - step: end
        when: "{{ result.error is defined and not request_id }}"
      - step: create_user_session
        when: "{{ result.sub is defined }}"

  - step: send_token_error_callback
    desc: Send token error callback to gateway
    tool:
      kind: http
      method: POST
      url: "{{ gateway_url }}/api/internal/callback"
      headers:
        Content-Type: application/json
      data:
        request_id: "{{ request_id }}"
        status: "error"
        data:
          error: "{{ start.error | default('Token validation failed') }}"
          message: "Token validation failed"
    next:
      - step: end

  # Step 2: Combined upsert user + create session (pooled postgres CTE)
  - step: create_user_session
    desc: Upsert user and create session in single transaction
    tool:
      kind: postgres
      auth: "{{ db_credential }}"
      pool: {}
      command: |
        WITH upserted_user AS (
          INSERT INTO auth.users (auth0_id, email, display_name, last_login_at)
          VALUES ('{{ start.sub }}', '{{ start.email }}', '{{ start.name }}', NOW())
          ON CONFLICT (auth0_id)
          DO UPDATE SET
            email = EXCLUDED.email,
            display_name = EXCLUDED.display_name,
            last_login_at = NOW()
          RETURNING user_id, email, display_name, is_active
        )
        INSERT INTO auth.sessions (user_id, session_token, auth0_token, expires_at, ip_address)
        SELECT
          u.user_id,
          replace(gen_random_uuid()::text, '-', ''),
          '{{ auth0_token }}',
          NOW() + INTERVAL '24 hours',
          '{{ client_ip }}'::inet
        FROM upserted_user u
        RETURNING
          session_token,
          user_id,
          expires_at,
          (SELECT email FROM upserted_user) as email,
          (SELECT display_name FROM upserted_user) as display_name;
      eval:
        - expr: "{{ outcome.status == 'error' }}"
          do: continue
        - else:
            do: continue
    next:
      - step: cache_and_callback
        when: "{{ result.command_0 is defined }}"
      - step: send_db_error_callback
        when: "{{ result.command_0 is not defined and request_id }}"
      - step: end
        when: "{{ result.command_0 is not defined and not request_id }}"

  - step: send_db_error_callback
    desc: Send database error callback to gateway
    tool:
      kind: http
      method: POST
      url: "{{ gateway_url }}/api/internal/callback"
      headers:
        Content-Type: application/json
      data:
        request_id: "{{ request_id }}"
        status: "error"
        data:
          error: "Database error"
          message: "Failed to create session"
    next:
      - step: end

  # Step 3: Cache session in NATS and send callback
  - step: cache_and_callback
    desc: Cache session in NATS K/V and send callback to gateway
    tool:
      kind: nats
      auth: "{{ nats_credential }}"
      operation: kv_put
      bucket: "{{ session_bucket }}"
      key: "{{ create_user_session.command_0.rows[0].session_token }}"
      value:
        session_token: "{{ create_user_session.command_0.rows[0].session_token }}"
        user_id: "{{ create_user_session.command_0.rows[0].user_id }}"
        email: "{{ create_user_session.command_0.rows[0].email }}"
        display_name: "{{ create_user_session.command_0.rows[0].display_name }}"
        expires_at: "{{ create_user_session.command_0.rows[0].expires_at }}"
        is_active: true
      eval:
        - expr: "{{ outcome.status == 'error' }}"
          do: continue
        - else:
            do: continue
    next:
      - step: send_success_callback
        when: "{{ request_id }}"
      - step: end
        when: "{{ not request_id }}"

  - step: send_success_callback
    desc: Send success callback to gateway
    tool:
      kind: http
      method: POST
      url: "{{ gateway_url }}/api/internal/callback"
      headers:
        Content-Type: application/json
      data:
        request_id: "{{ request_id }}"
        status: "success"
        data:
          status: "authenticated"
          session_token: "{{ create_user_session.command_0.rows[0].session_token }}"
          user:
            user_id: "{{ create_user_session.command_0.rows[0].user_id }}"
            email: "{{ create_user_session.command_0.rows[0].email }}"
            display_name: "{{ create_user_session.command_0.rows[0].display_name }}"
          expires_at: "{{ create_user_session.command_0.rows[0].expires_at }}"
    next:
      - step: end

  - step: end
    desc: Complete
    tool:
      kind: python
      code: |
        result = {"status": "complete"}
