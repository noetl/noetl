apiVersion: noetl.io/v2
kind: Playbook
metadata:
  name: auth0_login
  path: api_integration/auth0/auth0_login
  description: |
    Authenticate user with Auth0 and create NoETL session.
    
    Input:
      - auth0_token: Auth0 ID token (JWT)
      - client_ip: Client IP (optional, defaults to 0.0.0.0)
    
    Output:
      - session_token: NoETL session token
      - user_id: Internal user ID
  tags:
    - auth0
    - authentication

workload:
  auth0_token: ""
  client_ip: "0.0.0.0"
  auth0_domain: "mestumre-development.us.auth0.com"
  db_credential: pg_auth

workflow:
  - step: start
    desc: Begin Auth0 login
    tool:
      kind: python
      auth: {}
      libs:
        json: json
      args: {}
      code: |
        # Debug: log what we received
        print(f"DEBUG: Full context keys: {list(context.keys())}")
        print(f"DEBUG: workload = {json.dumps(context.get('workload', {}), indent=2)}")
        result = {
            "status": "initialized",
            "auth0_token_present": bool(context.get('workload', {}).get('auth0_token')),
            "client_ip_present": bool(context.get('workload', {}).get('client_ip'))
        }
    case:
      - when: "{{ event.name == 'step.exit' }}"
        then:
          next:
            - step: validate_token

  - step: validate_token
    desc: Decode Auth0 ID token (JWT) without external libraries
    tool:
      kind: python
      libs:
        base64: base64
        json: json
      code: |
        # Decode the ID token (JWT format: header.payload.signature)
        token = context.get('workload', {}).get('auth0_token', '')
        
        try:
            # Split JWT and get payload (middle part)
            parts = token.split('.')
            if len(parts) != 3:
                raise ValueError("Invalid JWT format")
            
            # Decode base64 payload (add padding if needed)
            payload = parts[1]
            padding = 4 - (len(payload) % 4)
            if padding != 4:
                payload += '=' * padding
            
            decoded_bytes = base64.urlsafe_b64decode(payload)
            decoded = json.loads(decoded_bytes)
            
            result = {
                "sub": decoded.get("sub"),
                "email": decoded.get("email"),
                "name": decoded.get("name", decoded.get("email")),
                "email_verified": decoded.get("email_verified", False)
            }
        except Exception as e:
            result = {"error": str(e)}
    case:
      - when: "{{ event.name == 'step.exit' and result.sub is defined }}"
        then:
          next:
            - step: upsert_user

  - step: upsert_user
    desc: Create or update user
    tool:
      kind: postgres
      auth: "{{ workload.db_credential }}"
      command: |
        INSERT INTO auth.users (auth0_id, email, display_name, last_login_at)
        VALUES ('{{ validate_token.sub }}', '{{ validate_token.email }}', '{{ validate_token.name }}', NOW())
        ON CONFLICT (auth0_id) 
        DO UPDATE SET
          email = EXCLUDED.email,
          display_name = EXCLUDED.display_name,
          last_login_at = NOW()
        RETURNING user_id, email, display_name, is_active;
    case:
      - when: "{{ event.name == 'step.exit' and result.command_0 is defined }}"
        then:
          next:
            - step: create_session

  - step: create_session
    desc: Create session
    tool:
      kind: postgres
      auth: "{{ workload.db_credential }}"
      command: |
        INSERT INTO auth.sessions (
          user_id,
          session_token,
          auth0_token,
          expires_at,
          ip_address
        )
        VALUES (
          {{ upsert_user.command_0.rows[0].user_id }},
          replace(gen_random_uuid()::text, '-', ''),
          '{{ workload.auth0_token }}',
          NOW() + INTERVAL '24 hours',
          '{{ workload.client_ip }}'::inet
        )
        RETURNING session_token, user_id, expires_at;
    case:
      - when: "{{ event.name == 'step.exit' and result.command_0 is defined }}"
        then:
          next:
            - step: success

  - step: success
    desc: Return session token
    tool:
      kind: python
      auth: {}
      libs: {}
      args:
        session_token: "{{ create_session.command_0.rows[0].session_token }}"
        user_id: "{{ create_session.command_0.rows[0].user_id }}"
        expires_at: "{{ create_session.command_0.rows[0].expires_at }}"
        email: "{{ upsert_user.command_0.rows[0].email }}"
      code: |
        # Arguments injected: session_token, user_id, expires_at, email
        result = {
            "status": "authenticated",
            "session_token": session_token,
            "user": {
                "user_id": user_id,
                "email": email
            },
            "expires_at": str(expires_at)
        }
    case:
      - when: "{{ event.name == 'step.exit' }}"
        then:
          next:
            - step: end

  - step: end
    desc: Complete
    tool:
      kind: python
      auth: {}
      libs: {}
      args: {}
      code: |
        result = {"status": "complete"}
