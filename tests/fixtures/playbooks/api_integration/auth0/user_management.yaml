apiVersion: noetl.io/v2
kind: Playbook
metadata:
  name: user_management
  path: api_integration/auth0/user_management
  description: |
    User management backend for the admin dashboard.
    Handles all user and role operations via a single endpoint.

    Actions:
      - list_users: Get all users with their assigned roles
      - list_roles: Get all available roles
      - update_user_roles: Update roles for a specific user
      - get_user: Get details for a specific user

    Input:
      - action: Operation to perform (required)
      - user_id: User ID (required for update_user_roles, get_user)
      - role_names: Array of role names (required for update_user_roles)
      - granted_by: User ID of admin making change (optional)
      - request_id: Callback request ID (injected by gateway)
      - gateway_url: Gateway URL for callbacks (injected by gateway)

    Output: Sends callback via gateway with action result
  tags:
    - auth0
    - admin
    - users
    - roles

workload:
  db_credential: pg_k8s
  action: "list_users"
  user_id: null
  role_names: []
  granted_by: null
  request_id: ""
  gateway_url: "http://gateway.gateway.svc.cluster.local:8090"

workflow:
  - step: start
    desc: Route to appropriate action
    tool:
      kind: python
      code: |
        action = context['workload'].get('action', 'list_users')
        result = {"action": action}
    case:
      - when: "{{ event.name == 'call.done' and workload.action == 'list_users' }}"
        then:
          - next:
              - step: list_users

      - when: "{{ event.name == 'call.done' and workload.action == 'list_roles' }}"
        then:
          - next:
              - step: list_roles

      - when: "{{ event.name == 'call.done' and workload.action == 'update_user_roles' }}"
        then:
          - next:
              - step: delete_user_roles

      - when: "{{ event.name == 'call.done' and workload.action == 'get_user' }}"
        then:
          - next:
              - step: get_user

      - when: "{{ event.name == 'call.done' }}"
        then:
          - next:
              - step: error_invalid_action

  # ============================================================================
  # LIST USERS - Get all users with their roles
  # ============================================================================
  - step: list_users
    desc: Query all users with their assigned roles
    tool:
      kind: postgres
      auth: "{{ workload.db_credential }}"
      command: |
        SELECT
          u.user_id,
          u.auth0_id,
          u.email,
          u.display_name,
          u.last_login_at,
          u.is_active,
          u.created_at,
          COALESCE(
            json_agg(
              json_build_object(
                'role_id', r.role_id,
                'role_name', r.role_name
              )
            ) FILTER (WHERE r.role_id IS NOT NULL),
            '[]'
          ) as roles
        FROM auth.users u
        LEFT JOIN auth.user_roles ur ON u.user_id = ur.user_id
          AND (ur.expires_at IS NULL OR ur.expires_at > NOW())
        LEFT JOIN auth.roles r ON ur.role_id = r.role_id
        GROUP BY u.user_id, u.auth0_id, u.email, u.display_name,
                 u.last_login_at, u.is_active, u.created_at
        ORDER BY u.user_id;
    case:
      - when: "{{ event.name == 'call.done' }}"
        then:
          - next:
              - step: return_users

  - step: return_users
    desc: Format and send users list callback
    spec:
      case_mode: exclusive
    tool:
      kind: python
      code: |
        rows = context.get('list_users', {}).get('command_0', {}).get('rows', [])
        result = {
            "success": True,
            "action": "list_users",
            "users": rows,
            "count": len(rows)
        }
    case:
      - when: "{{ event.name == 'call.done' and workload.request_id }}"
        then:
          - send_callback:
              tool:
                kind: http
                method: POST
                url: "{{ workload.gateway_url }}/api/internal/callback/async"
                headers:
                  Content-Type: application/json
                data:
                  request_id: "{{ workload.request_id }}"
                  status: "COMPLETED"
                  data: "{{ return_users }}"
          - next:
              - step: end
      - when: "{{ event.name == 'call.done' }}"
        then:
          - next:
              - step: end

  # ============================================================================
  # LIST ROLES - Get all available roles
  # ============================================================================
  - step: list_roles
    desc: Query all available roles
    tool:
      kind: postgres
      auth: "{{ workload.db_credential }}"
      command: |
        SELECT
          role_id,
          role_name,
          description,
          is_system_role,
          created_at
        FROM auth.roles
        ORDER BY role_id;
    case:
      - when: "{{ event.name == 'call.done' }}"
        then:
          - next:
              - step: return_roles

  - step: return_roles
    desc: Format and send roles list callback
    spec:
      case_mode: exclusive
    tool:
      kind: python
      code: |
        rows = context.get('list_roles', {}).get('command_0', {}).get('rows', [])
        result = {
            "success": True,
            "action": "list_roles",
            "roles": rows,
            "count": len(rows)
        }
    case:
      - when: "{{ event.name == 'call.done' and workload.request_id }}"
        then:
          - send_callback:
              tool:
                kind: http
                method: POST
                url: "{{ workload.gateway_url }}/api/internal/callback/async"
                headers:
                  Content-Type: application/json
                data:
                  request_id: "{{ workload.request_id }}"
                  status: "COMPLETED"
                  data: "{{ return_roles }}"
          - next:
              - step: end
      - when: "{{ event.name == 'call.done' }}"
        then:
          - next:
              - step: end

  # ============================================================================
  # GET USER - Get single user details
  # ============================================================================
  - step: get_user
    desc: Query single user with roles
    tool:
      kind: postgres
      auth: "{{ workload.db_credential }}"
      command: |
        SELECT
          u.user_id,
          u.auth0_id,
          u.email,
          u.display_name,
          u.last_login_at,
          u.is_active,
          u.created_at,
          COALESCE(
            json_agg(
              json_build_object(
                'role_id', r.role_id,
                'role_name', r.role_name
              )
            ) FILTER (WHERE r.role_id IS NOT NULL),
            '[]'
          ) as roles
        FROM auth.users u
        LEFT JOIN auth.user_roles ur ON u.user_id = ur.user_id
          AND (ur.expires_at IS NULL OR ur.expires_at > NOW())
        LEFT JOIN auth.roles r ON ur.role_id = r.role_id
        WHERE u.user_id = {{ workload.user_id }}
        GROUP BY u.user_id, u.auth0_id, u.email, u.display_name,
                 u.last_login_at, u.is_active, u.created_at;
    case:
      - when: "{{ event.name == 'call.done' }}"
        then:
          - next:
              - step: return_user

  - step: return_user
    desc: Format and send user details callback
    spec:
      case_mode: exclusive
    tool:
      kind: python
      code: |
        rows = context.get('get_user', {}).get('command_0', {}).get('rows', [])
        if rows:
            result = {
                "success": True,
                "action": "get_user",
                "user": rows[0]
            }
        else:
            result = {
                "success": False,
                "action": "get_user",
                "error": "User not found"
            }
    case:
      - when: "{{ event.name == 'call.done' and workload.request_id }}"
        then:
          - send_callback:
              tool:
                kind: http
                method: POST
                url: "{{ workload.gateway_url }}/api/internal/callback/async"
                headers:
                  Content-Type: application/json
                data:
                  request_id: "{{ workload.request_id }}"
                  status: "COMPLETED"
                  data: "{{ return_user }}"
          - next:
              - step: end
      - when: "{{ event.name == 'call.done' }}"
        then:
          - next:
              - step: end

  # ============================================================================
  # UPDATE USER ROLES - Replace user's roles
  # ============================================================================
  - step: delete_user_roles
    desc: Remove existing roles for user
    tool:
      kind: postgres
      auth: "{{ workload.db_credential }}"
      command: |
        DELETE FROM auth.user_roles WHERE user_id = {{ workload.user_id }};
    case:
      - when: "{{ event.name == 'call.done' }}"
        then:
          - next:
              - step: insert_user_roles

  - step: insert_user_roles
    desc: Insert new roles for user
    tool:
      kind: postgres
      auth: "{{ workload.db_credential }}"
      command: |
        INSERT INTO auth.user_roles (user_id, role_id, granted_by)
        SELECT
          {{ workload.user_id }},
          r.role_id,
          {% if workload.granted_by %}{{ workload.granted_by }}{% else %}NULL{% endif %}
        FROM auth.roles r
        WHERE r.role_name = ANY(ARRAY[{% for name in workload.role_names %}'{{ name }}'{% if not loop.last %},{% endif %}{% endfor %}])
        ON CONFLICT (user_id, role_id) DO NOTHING
        RETURNING role_id;
    case:
      - when: "{{ event.name == 'call.done' }}"
        then:
          - next:
              - step: get_updated_roles

  - step: get_updated_roles
    desc: Fetch updated roles for confirmation
    tool:
      kind: postgres
      auth: "{{ workload.db_credential }}"
      command: |
        SELECT r.role_id, r.role_name
        FROM auth.user_roles ur
        JOIN auth.roles r ON ur.role_id = r.role_id
        WHERE ur.user_id = {{ workload.user_id }}
        ORDER BY r.role_name;
    case:
      - when: "{{ event.name == 'call.done' }}"
        then:
          - next:
              - step: return_updated_roles

  - step: return_updated_roles
    desc: Return update result callback
    spec:
      case_mode: exclusive
    tool:
      kind: python
      code: |
        rows = context.get('get_updated_roles', {}).get('command_0', {}).get('rows', [])
        result = {
            "success": True,
            "action": "update_user_roles",
            "user_id": context['workload']['user_id'],
            "roles": rows,
            "message": f"Updated {len(rows)} roles for user {context['workload']['user_id']}"
        }
    case:
      - when: "{{ event.name == 'call.done' and workload.request_id }}"
        then:
          - send_callback:
              tool:
                kind: http
                method: POST
                url: "{{ workload.gateway_url }}/api/internal/callback/async"
                headers:
                  Content-Type: application/json
                data:
                  request_id: "{{ workload.request_id }}"
                  status: "COMPLETED"
                  data: "{{ return_updated_roles }}"
          - next:
              - step: end
      - when: "{{ event.name == 'call.done' }}"
        then:
          - next:
              - step: end

  # ============================================================================
  # ERROR HANDLING
  # ============================================================================
  - step: error_invalid_action
    desc: Return error callback for invalid action
    spec:
      case_mode: exclusive
    tool:
      kind: python
      code: |
        result = {
            "success": False,
            "error": f"Invalid action: {context['workload'].get('action')}",
            "valid_actions": ["list_users", "list_roles", "update_user_roles", "get_user"]
        }
    case:
      - when: "{{ event.name == 'call.done' and workload.request_id }}"
        then:
          - send_callback:
              tool:
                kind: http
                method: POST
                url: "{{ workload.gateway_url }}/api/internal/callback/async"
                headers:
                  Content-Type: application/json
                data:
                  request_id: "{{ workload.request_id }}"
                  status: "FAILED"
                  error:
                    message: "{{ error_invalid_action.error }}"
          - next:
              - step: end
      - when: "{{ event.name == 'call.done' }}"
        then:
          - next:
              - step: end

  - step: end
    desc: Complete
    tool:
      kind: python
      code: |
        result = {"status": "complete"}
