apiVersion: noetl.io/v10
kind: Playbook
metadata:
  name: provision_auth_schema
  path: api_integration/auth0/provision_auth_schema
  description: |
    Provision authentication schema and tables in demo_noetl database.

    Creates auth schema with tables: users, roles, permissions, sessions, audit_log, etc.

    Prerequisites:
    - PostgreSQL database accessible
    - Admin credentials registered as 'pg_k8s'
  tags:
    - auth0
    - database
    - provisioning

ctx:
  db_credential: pg_auth

workflow:
  - step: start
    desc: Begin auth schema provisioning
    tool:
      kind: python
      code: |
        result = {"status": "initialized"}
    next:
      spec:
        mode: exclusive
      arcs:
        - step: provision_schema

  - step: provision_schema
    desc: Execute SQL to create auth schema and tables
    tool:
      kind: postgres
      auth: "{{ ctx.db_credential }}"
      command: |
        -- Create auth schema
        CREATE SCHEMA IF NOT EXISTS auth;

        -- Create users table
        CREATE TABLE IF NOT EXISTS auth.users (
          user_id SERIAL PRIMARY KEY,
          auth0_id VARCHAR(255) UNIQUE NOT NULL,
          email VARCHAR(255) NOT NULL,
          display_name VARCHAR(255),
          profile_data JSONB,
          is_active BOOLEAN DEFAULT true,
          created_at TIMESTAMP DEFAULT NOW(),
          updated_at TIMESTAMP DEFAULT NOW(),
          last_login_at TIMESTAMP
        );

        -- Create roles table
        CREATE TABLE IF NOT EXISTS auth.roles (
          role_id SERIAL PRIMARY KEY,
          role_name VARCHAR(100) UNIQUE NOT NULL,
          description TEXT,
          created_at TIMESTAMP DEFAULT NOW()
        );

        -- Create permissions table
        CREATE TABLE IF NOT EXISTS auth.permissions (
          permission_id SERIAL PRIMARY KEY,
          permission_name VARCHAR(100) UNIQUE NOT NULL,
          description TEXT,
          created_at TIMESTAMP DEFAULT NOW()
        );

        -- Create user_roles junction table
        CREATE TABLE IF NOT EXISTS auth.user_roles (
          user_role_id SERIAL PRIMARY KEY,
          user_id INTEGER REFERENCES auth.users(user_id) ON DELETE CASCADE,
          role_id INTEGER REFERENCES auth.roles(role_id) ON DELETE CASCADE,
          assigned_at TIMESTAMP DEFAULT NOW(),
          expires_at TIMESTAMP,
          UNIQUE(user_id, role_id)
        );

        -- Create role_permissions junction table
        CREATE TABLE IF NOT EXISTS auth.role_permissions (
          role_permission_id SERIAL PRIMARY KEY,
          role_id INTEGER REFERENCES auth.roles(role_id) ON DELETE CASCADE,
          permission_id INTEGER REFERENCES auth.permissions(permission_id) ON DELETE CASCADE,
          UNIQUE(role_id, permission_id)
        );

        -- Create sessions table
        CREATE TABLE IF NOT EXISTS auth.sessions (
          session_id SERIAL PRIMARY KEY,
          user_id INTEGER REFERENCES auth.users(user_id) ON DELETE CASCADE,
          session_token VARCHAR(255) UNIQUE NOT NULL,
          auth0_token TEXT,
          auth0_refresh_token TEXT,
          created_at TIMESTAMP DEFAULT NOW(),
          expires_at TIMESTAMP NOT NULL,
          last_activity_at TIMESTAMP DEFAULT NOW(),
          is_active BOOLEAN DEFAULT true,
          ip_address INET,
          user_agent TEXT
        );

        -- Create audit_log table
        CREATE TABLE IF NOT EXISTS auth.audit_log (
          log_id SERIAL PRIMARY KEY,
          user_id INTEGER REFERENCES auth.users(user_id) ON DELETE SET NULL,
          session_id INTEGER REFERENCES auth.sessions(session_id) ON DELETE SET NULL,
          event_type VARCHAR(100) NOT NULL,
          event_status VARCHAR(50),
          resource_type VARCHAR(100),
          resource_id VARCHAR(255),
          event_details JSONB,
          ip_address INET,
          user_agent TEXT,
          created_at TIMESTAMP DEFAULT NOW()
        );

        -- Create playbook_permissions table
        CREATE TABLE IF NOT EXISTS auth.playbook_permissions (
          permission_id SERIAL PRIMARY KEY,
          role_id INTEGER REFERENCES auth.roles(role_id) ON DELETE CASCADE,
          playbook_path VARCHAR(500),
          allow_pattern VARCHAR(500),
          deny_pattern VARCHAR(500),
          can_execute BOOLEAN DEFAULT false,
          can_view BOOLEAN DEFAULT false,
          can_modify BOOLEAN DEFAULT false,
          created_at TIMESTAMP DEFAULT NOW(),
          CONSTRAINT path_or_pattern_required CHECK (
            playbook_path IS NOT NULL OR allow_pattern IS NOT NULL
          )
        );

        -- Create indexes
        CREATE INDEX IF NOT EXISTS idx_users_auth0_id ON auth.users(auth0_id);
        CREATE INDEX IF NOT EXISTS idx_users_email ON auth.users(email);
        CREATE INDEX IF NOT EXISTS idx_sessions_token ON auth.sessions(session_token);
        CREATE INDEX IF NOT EXISTS idx_sessions_user_id ON auth.sessions(user_id);
        CREATE INDEX IF NOT EXISTS idx_audit_log_user_id ON auth.audit_log(user_id);
        CREATE INDEX IF NOT EXISTS idx_audit_log_created_at ON auth.audit_log(created_at);

        -- Seed default roles
        INSERT INTO auth.roles (role_name, description) VALUES
          ('admin', 'Administrator with full access'),
          ('developer', 'Developer with playbook execution rights'),
          ('analyst', 'Analyst with read-only access'),
          ('viewer', 'Viewer with limited read access')
        ON CONFLICT (role_name) DO NOTHING;

        -- Seed default permissions
        INSERT INTO auth.permissions (permission_name, description) VALUES
          ('playbook:execute', 'Execute playbooks'),
          ('playbook:view', 'View playbook definitions'),
          ('playbook:modify', 'Create/modify playbooks'),
          ('catalog:read', 'Read catalog entries'),
          ('catalog:write', 'Write catalog entries'),
          ('credential:read', 'Read credentials'),
          ('credential:write', 'Manage credentials')
        ON CONFLICT (permission_name) DO NOTHING;

        -- Grant permissions to roles
        INSERT INTO auth.role_permissions (role_id, permission_id)
        SELECT r.role_id, p.permission_id
        FROM auth.roles r
        CROSS JOIN auth.permissions p
        WHERE r.role_name = 'admin'
        ON CONFLICT DO NOTHING;

        INSERT INTO auth.role_permissions (role_id, permission_id)
        SELECT r.role_id, p.permission_id
        FROM auth.roles r
        CROSS JOIN auth.permissions p
        WHERE r.role_name = 'developer'
          AND p.permission_name IN ('playbook:execute', 'playbook:view', 'catalog:read')
        ON CONFLICT DO NOTHING;

        SELECT 'Auth schema provisioned successfully' as result;
    next:
      spec:
        mode: exclusive
      arcs:
        - step: verify_schema

  - step: verify_schema
    desc: Verify auth schema was created successfully
    tool:
      kind: postgres
      auth: "{{ ctx.db_credential }}"
      command: |
        SELECT
          (SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'auth') as table_count,
          (SELECT COUNT(*) FROM auth.roles) as role_count,
          (SELECT COUNT(*) FROM auth.permissions) as permission_count;
    next:
      spec:
        mode: exclusive
      arcs:
        - step: success

  - step: success
    desc: Schema provisioned successfully
    tool:
      kind: python
      args:
        verification: "{{ verify_schema.command_0.rows[0] }}"
      code: |
        result = {
            "status": "success",
            "message": "Auth schema provisioned successfully",
            "details": verification
        }
    next:
      spec:
        mode: exclusive
      arcs:
        - step: end

  - step: end
    desc: Complete provisioning workflow
    tool:
      kind: python
      code: |
        result = {"status": "complete"}
