apiVersion: noetl.io/v2
kind: Playbook
metadata:
  name: auth0_login_optimized
  path: api_integration/auth0/auth0_login_optimized
  description: |
    OPTIMIZED Auth0 login - reduced from 7 steps to 3 steps for faster execution.

    Uses inline task lists to execute multiple actions on the same worker,
    reducing server-worker round trips from ~30 HTTP calls to ~12.

    Flow:
      1. validate_token: Decode JWT
      2. create_user_session: Upsert user + create session (combined postgres)
      3. complete: Cache session + send callback (inline tasks)

    Expected execution time: ~1 second (down from ~3 seconds)
  tags:
    - auth0
    - authentication
    - optimized
    - gateway

workload:
  auth0_token: ""
  client_ip: "0.0.0.0"
  auth0_domain: "mestumre-development.us.auth0.com"
  db_credential: pg_auth
  nats_credential: nats_credential
  session_bucket: sessions
  request_id: ""
  gateway_url: "http://gateway.gateway.svc.cluster.local:8090"

workflow:
  # Step 0: Entry point (required)
  - step: start
    desc: Entry point - immediately validate token
    tool:
      kind: python
      code: |
        result = {"status": "started"}
    case:
      - when: "{{ event.name == 'call.done' }}"
        then:
          - next:
              - step: validate_token

  # Step 1: Validate JWT token
  - step: validate_token
    desc: Decode Auth0 ID token (JWT)
    spec:
      case_mode: exclusive
    tool:
      kind: python
      libs:
        base64: base64
        json: json
      code: |
        token = context.get('auth0_token', '')
        try:
            parts = token.split('.')
            if len(parts) != 3:
                raise ValueError("Invalid JWT format")
            payload = parts[1]
            padding = 4 - (len(payload) % 4)
            if padding != 4:
                payload += '=' * padding
            decoded_bytes = base64.urlsafe_b64decode(payload)
            decoded = json.loads(decoded_bytes)
            result = {
                "sub": decoded.get("sub"),
                "email": decoded.get("email"),
                "name": decoded.get("name", decoded.get("email")),
                "email_verified": decoded.get("email_verified", False)
            }
        except Exception as e:
            result = {"error": str(e)}
    case:
      # Error with callback - send error and end (inline tasks)
      - when: "{{ (event.name == 'call.error' or (event.name == 'call.done' and result.error is defined)) and request_id }}"
        then:
          - send_error_callback:
              tool:
                kind: http
                method: POST
                url: "{{ gateway_url }}/api/internal/callback"
                headers:
                  Content-Type: application/json
                data:
                  request_id: "{{ request_id }}"
                  status: "error"
                  data:
                    error: "{{ result.error | default(event.error) | default('Token validation failed') }}"
                    message: "Token validation failed"
          - next:
              - step: end
      # Error without callback - just end
      - when: "{{ event.name == 'call.error' or (event.name == 'call.done' and result.error is defined) }}"
        then:
          - next:
              - step: end
      # Success - proceed to create user session
      - when: "{{ event.name == 'call.done' and result.sub is defined }}"
        then:
          - next:
              - step: create_user_session

  # Step 2: Combined upsert user + create session (single postgres connection)
  - step: create_user_session
    desc: Upsert user and create session in single transaction
    tool:
      kind: postgres
      auth: "{{ db_credential }}"
      # Multiple commands in single connection - uses CTEs for efficiency
      command: |
        WITH upserted_user AS (
          INSERT INTO auth.users (auth0_id, email, display_name, last_login_at)
          VALUES ('{{ validate_token.sub }}', '{{ validate_token.email }}', '{{ validate_token.name }}', NOW())
          ON CONFLICT (auth0_id)
          DO UPDATE SET
            email = EXCLUDED.email,
            display_name = EXCLUDED.display_name,
            last_login_at = NOW()
          RETURNING user_id, email, display_name, is_active
        )
        INSERT INTO auth.sessions (user_id, session_token, auth0_token, expires_at, ip_address)
        SELECT
          u.user_id,
          replace(gen_random_uuid()::text, '-', ''),
          '{{ auth0_token }}',
          NOW() + INTERVAL '24 hours',
          '{{ client_ip }}'::inet
        FROM upserted_user u
        RETURNING
          session_token,
          user_id,
          expires_at,
          (SELECT email FROM upserted_user) as email,
          (SELECT display_name FROM upserted_user) as display_name;
    case:
      - when: "{{ event.name == 'call.done' and result.command_0 is defined }}"
        then:
          - next:
              - step: complete
      # On error with callback
      - when: "{{ event.name == 'call.error' and request_id }}"
        then:
          - send_error_callback:
              tool:
                kind: http
                method: POST
                url: "{{ gateway_url }}/api/internal/callback"
                headers:
                  Content-Type: application/json
                data:
                  request_id: "{{ request_id }}"
                  status: "error"
                  data:
                    error: "{{ event.error | default('Database error') }}"
                    message: "Failed to create session"
          - next:
              - step: end

  # Step 3: Cache session and send callback (inline tasks - no separate steps)
  - step: complete
    desc: Cache session in NATS and send callback
    spec:
      case_mode: exclusive
    tool:
      kind: nats
      auth: "{{ nats_credential }}"
      operation: kv_put
      bucket: "{{ session_bucket }}"
      key: "{{ create_user_session.command_0.rows[0].session_token }}"
      value:
        session_token: "{{ create_user_session.command_0.rows[0].session_token }}"
        user_id: "{{ create_user_session.command_0.rows[0].user_id }}"
        email: "{{ create_user_session.command_0.rows[0].email }}"
        display_name: "{{ create_user_session.command_0.rows[0].display_name }}"
        expires_at: "{{ create_user_session.command_0.rows[0].expires_at }}"
        is_active: true
    case:
      # Success with callback - send callback inline (no extra step)
      - when: "{{ event.name == 'call.done' and request_id }}"
        then:
          - send_success_callback:
              tool:
                kind: http
                method: POST
                url: "{{ gateway_url }}/api/internal/callback"
                headers:
                  Content-Type: application/json
                data:
                  request_id: "{{ request_id }}"
                  status: "success"
                  data:
                    status: "authenticated"
                    session_token: "{{ create_user_session.command_0.rows[0].session_token }}"
                    user:
                      user_id: "{{ create_user_session.command_0.rows[0].user_id }}"
                      email: "{{ create_user_session.command_0.rows[0].email }}"
                      display_name: "{{ create_user_session.command_0.rows[0].display_name }}"
                    expires_at: "{{ create_user_session.command_0.rows[0].expires_at }}"
          - next:
              - step: end
      # Success without callback
      - when: "{{ event.name == 'call.done' }}"
        then:
          - next:
              - step: end
      # NATS cache failed but still send callback (Postgres is source of truth)
      - when: "{{ event.name == 'call.error' and request_id }}"
        then:
          - send_success_callback:
              tool:
                kind: http
                method: POST
                url: "{{ gateway_url }}/api/internal/callback"
                headers:
                  Content-Type: application/json
                data:
                  request_id: "{{ request_id }}"
                  status: "success"
                  data:
                    status: "authenticated"
                    session_token: "{{ create_user_session.command_0.rows[0].session_token }}"
                    user:
                      user_id: "{{ create_user_session.command_0.rows[0].user_id }}"
                      email: "{{ create_user_session.command_0.rows[0].email }}"
                      display_name: "{{ create_user_session.command_0.rows[0].display_name }}"
                    expires_at: "{{ create_user_session.command_0.rows[0].expires_at }}"
          - next:
              - step: end
      # NATS failed without callback
      - when: "{{ event.name == 'call.error' }}"
        then:
          - next:
              - step: end

  - step: end
    desc: Complete
    tool:
      kind: python
      code: |
        result = {"status": "complete"}
