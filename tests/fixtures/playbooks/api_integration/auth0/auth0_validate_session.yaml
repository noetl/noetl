apiVersion: noetl.io/v2
kind: Playbook
metadata:
  name: auth0_validate_session
  path: api_integration/auth0/auth0_validate_session
  description: |
    Validate NoETL session token and refresh NATS cache.

    Flow:
      1. Validates session in Postgres (source of truth)
      2. If valid, caches/refreshes session in NATS K/V
      3. Sends callback to gateway with validation result

    Gateway Integration:
      - Gateway first checks NATS K/V for cached session
      - If cache miss, gateway calls this playbook
      - Playbook validates from Postgres and repopulates NATS cache
      - Gateway can then fetch session from NATS K/V

    Input:
      - session_token: NoETL session token
      - request_id: Gateway request ID for callback

    Output (via callback):
      - valid: Boolean (true if session is valid)
      - user: User details (user_id, email, display_name)
      - expires_at: Session expiration timestamp
      - message: Validation result message
  tags:
    - auth0
    - validation
    - nats
    - gateway

workload:
  session_token: "{{ session_token }}"
  db_credential: pg_auth
  nats_credential: nats_credential
  # NATS K/V bucket for session cache
  session_bucket: sessions
  request_id: ""
  gateway_url: "http://gateway.gateway.svc.cluster.local:8090"

workflow:
  - step: start
    desc: Lookup and validate session from Postgres (source of truth)
    spec:
      case_mode: exclusive  # First matching case wins
    tool:
      kind: postgres
      auth: "{{ workload.db_credential }}"
      command: |
        SELECT
          s.session_id,
          s.session_token,
          s.user_id,
          s.expires_at,
          s.is_active,
          u.email,
          u.display_name,
          u.is_active as user_is_active,
          CASE
            WHEN s.expires_at < NOW() THEN false
            WHEN NOT s.is_active THEN false
            WHEN NOT u.is_active THEN false
            ELSE true
          END as session_valid
        FROM auth.sessions s
        JOIN auth.users u ON s.user_id = u.user_id
        WHERE s.session_token = '{{ workload.session_token }}';
    case:
      # Valid session - cache in NATS and send success callback
      - when: "{{ event.name == 'call.done' and result.command_0.rows | length > 0 and result.command_0.rows[0].session_valid }}"
        then:
          - next:
              - step: cache_session

      # Invalid session (expired, inactive, or not found) - send failure callback
      - when: "{{ event.name == 'call.done' and request_id }}"
        then:
          - send_invalid:
              tool:
                kind: http
                method: POST
                url: "{{ gateway_url }}/api/internal/callback"
                headers:
                  Content-Type: application/json
                data:
                  request_id: "{{ request_id }}"
                  status: "success"
                  data:
                    valid: false
                    message: "Session not found or expired"
          - next:
              - step: end

      # No callback requested
      - when: "{{ event.name == 'call.done' }}"
        then:
          - next:
              - step: end

  - step: cache_session
    desc: Cache valid session in NATS K/V for fast gateway lookups
    tool:
      kind: nats
      auth: "{{ nats_credential }}"
      operation: kv_put
      bucket: "{{ session_bucket }}"
      key: "{{ start.command_0.rows[0].session_token }}"
      value:
        session_token: "{{ start.command_0.rows[0].session_token }}"
        user_id: "{{ start.command_0.rows[0].user_id }}"
        email: "{{ start.command_0.rows[0].email }}"
        display_name: "{{ start.command_0.rows[0].display_name }}"
        expires_at: "{{ start.command_0.rows[0].expires_at }}"
        is_active: true
    case:
      # Cache success or failure - both proceed to send callback
      - when: "{{ event.name == 'call.done' or event.name == 'call.error' }}"
        then:
          - next:
              - step: send_success_callback

  - step: send_success_callback
    desc: Send success callback to gateway
    spec:
      case_mode: exclusive
    tool:
      kind: python
      code: |
        result = {"status": "callback_ready"}
    case:
      # Send callback if request_id is set
      - when: "{{ event.name == 'call.done' and request_id }}"
        then:
          - send_callback:
              tool:
                kind: http
                method: POST
                url: "{{ gateway_url }}/api/internal/callback"
                headers:
                  Content-Type: application/json
                data:
                  request_id: "{{ request_id }}"
                  status: "success"
                  data:
                    valid: true
                    user:
                      user_id: "{{ start.command_0.rows[0].user_id }}"
                      email: "{{ start.command_0.rows[0].email }}"
                      display_name: "{{ start.command_0.rows[0].display_name }}"
                    expires_at: "{{ start.command_0.rows[0].expires_at }}"
                    message: "Session is valid"
          - next:
              - step: end
      # No callback requested
      - when: "{{ event.name == 'call.done' }}"
        then:
          - next:
              - step: end

  - step: end
    desc: Complete
    tool:
      kind: python
      code: |
        result = {"status": "complete"}
