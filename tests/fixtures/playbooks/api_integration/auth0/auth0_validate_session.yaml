apiVersion: noetl.io/v2
kind: Playbook
metadata:
  name: auth0_validate_session
  path: api_integration/auth0/auth0_validate_session
  description: |
    Validate NoETL session token.
    
    Input:
      - session_token: NoETL session token
    
    Output:
      - valid: Boolean
      - user: User details
  tags:
    - auth0
    - validation

workload:
  session_token: "{{ session_token }}"
  db_credential: pg_k8s

workflow:
  - step: start
    desc: Begin validation
    tool:
      kind: python
      auth: {}
      libs: {}
      args: {}
      code: |
        result = {"status": "initialized"}
    case:
      - when: "{{ event.name == 'step.exit' }}"
        then:
          next:
            - step: lookup_session

  - step: lookup_session
    desc: Lookup session
    tool:
      kind: postgres
      auth: "{{ workload.db_credential }}"
      command: |
        SELECT 
          s.session_id,
          s.user_id,
          s.expires_at,
          s.is_active,
          u.email,
          u.display_name,
          u.is_active as user_is_active,
          CASE 
            WHEN s.expires_at < NOW() THEN false
            WHEN NOT s.is_active THEN false
            WHEN NOT u.is_active THEN false
            ELSE true
          END as session_valid
        FROM auth.sessions s
        JOIN auth.users u ON s.user_id = u.user_id
        WHERE s.session_token = '{{ workload.session_token }}';
    case:
      - when: "{{ event.name == 'step.exit' and response is defined and (response | length) > 0 and response[0].session_valid }}"
        then:
          next:
            - step: update_activity
      - when: "{{ event.name == 'step.exit' }}"
        then:
          next:
            - step: validation_failed

  - step: update_activity
    desc: Update last activity
    tool:
      kind: postgres
      auth: "{{ workload.db_credential }}"
      command: |
        UPDATE auth.sessions
        SET last_activity_at = NOW()
        WHERE session_id = {{ lookup_session[0].session_id }};
    case:
      - when: "{{ event.name == 'step.exit' }}"
        then:
          next:
            - step: get_roles

  - step: get_roles
    desc: Get user roles
    tool:
      kind: postgres
      auth: "{{ workload.db_credential }}"
      command: |
        SELECT r.role_name
        FROM auth.user_roles ur
        JOIN auth.roles r ON ur.role_id = r.role_id
        WHERE ur.user_id = {{ lookup_session[0].user_id }}
          AND (ur.expires_at IS NULL OR ur.expires_at > NOW());
    case:
      - when: "{{ event.name == 'step.exit' }}"
        then:
          next:
            - step: success

  - step: success
    desc: Return valid session
    tool:
      kind: python
      auth: {}
      libs: {}
      args:
        user_id: "{{ lookup_session[0].user_id }}"
        email: "{{ lookup_session[0].email }}"
        display_name: "{{ lookup_session[0].display_name }}"
        roles: "{{ get_roles }}"
      code: |
        # Arguments injected: user_id, email, display_name, roles
        result = {
            "valid": True,
            "user": {
                "user_id": user_id,
                "email": email,
                "display_name": display_name,
                "roles": [r["role_name"] for r in roles] if roles else []
            },
            "message": "Session is valid"
        }
    case:
      - when: "{{ event.name == 'step.exit' }}"
        then:
          next:
            - step: end

  - step: validation_failed
    desc: Return invalid
    tool:
      kind: python
      auth: {}
      libs: {}
      args: {}
      code: |
        result = {
            "valid": False,
            "message": "Session not found or expired"
        }
    case:
      - when: "{{ event.name == 'step.exit' }}"
        then:
          next:
            - step: end

  - step: end
    desc: Complete
    tool:
      kind: python
      auth: {}
      libs: {}
      args: {}
      code: |
        result = {"status": "complete"}
