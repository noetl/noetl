apiVersion: noetl.io/v2
kind: Playbook
metadata:
  name: http_iterator_save_postgres
  path: tests/fixtures/playbooks/data_transfer/http_iterator_save_postgres
  description: "Test HTTP calls in iterator with save to Postgres - validates loop execution with storage"

workload:
  pg_auth: pg_k8s
  test_cities:
    - name: "London"
      lat: 51.5074
      lon: -0.1278
    - name: "Paris"
      lat: 48.8566
      lon: 2.3522
    - name: "Berlin"
      lat: 52.5200
      lon: 13.4050

workflow:
  - step: start
    desc: Start HTTP iterator save test
    tool:
      kind: python
      auth: {}
      libs: {}
      args: {}
      code: |
        result = {"status": "initialized"}
    next:
      - step: create_table

  - step: create_table
    desc: Create table for HTTP iterator results
    tool:
      kind: postgres
      auth: "{{ workload.pg_auth }}"
      command: |
        CREATE TABLE IF NOT EXISTS public.http_iterator_save_test (
          id TEXT PRIMARY KEY,
          execution_id TEXT NOT NULL,
          city_name TEXT NOT NULL,
          temperature NUMERIC,
          latitude NUMERIC,
          longitude NUMERIC,
          http_status INTEGER,
          created_at TIMESTAMPTZ DEFAULT NOW()
        );

        -- Clean up any previous test data for this execution
        DELETE FROM public.http_iterator_save_test
        WHERE execution_id = '{{ execution_id }}';
    next:
      - step: fetch_weather_data

  - step: fetch_weather_data
    desc: Fetch weather data for multiple cities using iterator with HTTP and save
    tool:
      kind: http
      method: GET
      url: "https://api.open-meteo.com/v1/forecast"
      headers:
        Accept: application/json
      params:
        latitude: "{{ city.lat }}"
        longitude: "{{ city.lon }}"
        current: temperature_2m
    loop:
      in: "{{ workload.test_cities }}"
      iterator: city
      mode: sequential
    case:
      - when: "{{ event.name in ['step.exit', 'call.done'] and response is defined and response.metadata.status_code == 200 and response.data is defined }}"
        then:
          sink:
            tool:
              kind: postgres
              auth: "{{ workload.pg_auth }}"
              table: public.http_iterator_save_test
              mode: upsert
              key: id
              args:
                id: "{{ execution_id }}:{{ city.name }}"
                execution_id: "{{ execution_id }}"
                city_name: "{{ city.name }}"
                temperature: "{{ response.data.current.temperature_2m | float }}"
                latitude: "{{ city.lat | float }}"
                longitude: "{{ city.lon | float }}"
                http_status: "{{ response.metadata.status_code | int }}"
      - when: "{{ event.name == 'step.exit' and (response is not defined or response.metadata.status_code != 200) }}"
        then:
          log: "fetch_weather_data skipped for {{ city.name }}: status={{ response.metadata.status_code if response is defined else 'n/a' }}"
    next:
      - step: verify_results

  - step: verify_results
    desc: Verify all records were saved
    tool:
      kind: postgres
      auth: "{{ workload.pg_auth }}"
      command: |
        SELECT
          COUNT(*) as total_records,
          COUNT(DISTINCT city_name) as unique_cities,
          AVG(temperature) as avg_temperature,
          MIN(created_at) as first_insert,
          MAX(created_at) as last_insert
        FROM public.http_iterator_save_test
        WHERE execution_id = '{{ execution_id }}';
    vars:
      verify_results: "{{ result }}"
    next:
      - step: show_details

  - step: show_details
    desc: Show detailed results
    tool:
      kind: postgres
      auth: "{{ workload.pg_auth }}"
      command: |
        SELECT
          city_name,
          temperature,
          latitude,
          longitude,
          http_status,
          created_at
        FROM public.http_iterator_save_test
        WHERE execution_id = '{{ execution_id }}'
        ORDER BY city_name;
    next:
      - step: validate_data

  - step: validate_data
    desc: Validate that all cities have data
    tool:
      kind: python
      auth: {}
      libs: {}
      args:
        verify_results: "{{ vars.verify_results }}"
      code: |
        """Validate that all expected cities have data saved."""
        # Get verification results - verify_results is already the dict with command_0
        verify_result = verify_results.get('command_0', {}).get('rows', [{}])[0]
        total_records = verify_result.get('total_records', 0)
        unique_cities = verify_result.get('unique_cities', 0)

        # Expected counts
        expected_cities = 3

        # Validation checks
        checks = {
            'total_records_match': total_records == expected_cities,
            'unique_cities_match': unique_cities == expected_cities,
            'all_cities_saved': total_records >= expected_cities
        }

        all_valid = all(checks.values())

        result = {
            'status': 'success' if all_valid else 'failed',
            'validation': checks,
            'counts': {
                'expected': expected_cities,
                'actual_total': total_records,
                'actual_unique': unique_cities
            },
            'message': f'Validation {"passed" if all_valid else "FAILED"}: {total_records} records saved for {unique_cities} cities'
        }
        
        # Raise exception on validation failure so execution reports FAILED
        if not all_valid:
            raise ValueError(f"Validation FAILED: {total_records} records saved for {unique_cities} cities (expected {expected_cities})")
    next:
      - step: end

  - step: end
    desc: Test completed
    tool:
      kind: python
      auth: {}
      libs: {}
      args: {}
      code: |
        result = {"status": "completed"}
