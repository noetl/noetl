apiVersion: noetl.io/v2
kind: Playbook

metadata:
  name: playbook_composition
  path: tests/fixtures/playbooks/playbook_composition/playbook_composition

workload:
  pg_auth: pg_local
  message: "Playbook composition with iterator validation"
  users:
    - name: "Alice"
      age: 28
      department: "Engineering"
      years_experience: 5
      performance_rating: 4.2
    - name: "Bob"
      age: 34
      department: "Marketing"
      years_experience: 8
      performance_rating: 3.8
    - name: "Charlie"
      age: 29
      department: "Engineering"
      years_experience: 3
      performance_rating: 4.5
    - name: "Diana"
      age: 42
      department: "Management"
      years_experience: 15
      performance_rating: 4.0

workflow:
  - step: start
    desc: "Initialize user profile processing"
    tool:
      kind: python
      auth: {}
      libs: {}
      args: {}
      code: |
        result = {"status": "initialized"}
    
    case:
      - when: "{{ event.name == 'call.done' }}"
        then:
          next:
            - step: setup_storage

  - step: setup_storage
    desc: "Ensure results table exists"
    tool:
      kind: postgres
      auth: "{{ workload.pg_auth }}"
      command: |
        CREATE TABLE IF NOT EXISTS public.user_profile_results (
          id TEXT PRIMARY KEY,
          execution_id TEXT,
          user_name TEXT,
          profile_score DOUBLE PRECISION,
          score_category TEXT,
          processed_at TIMESTAMPTZ DEFAULT now()
        );
    
    case:
      - when: "{{ event.name == 'call.done' }}"
        then:
          next:
            - step: process_users

  - step: process_users
    desc: "Process each user through profile scoring sub-playbook"
    loop:
      in: "{{ workload.users }}"
      iterator: user
      mode: sequential
    tool:
      kind: playbook
      # Provide an explicit task identifier so nested playbook propagates correct parent_step
      task: process_users
      path: tests/fixtures/playbooks/playbook_composition/user_profile_scorer
      return_step: finalize_result
      args:
        user_data: "{{ user }}"
        execution_context: "{{ execution_id }}"
    
    case:
      - when: "{{ event.name == 'call.done' }}"
        then:
          - sink:
              tool:
                kind: postgres
                auth: "{{ workload.pg_auth }}"
                statement: |
                  INSERT INTO public.user_profile_results (id, execution_id, user_name, profile_score, score_category)
                  VALUES (
                    '{{ execution_id }}:{{ user.name }}',
                    '{{ execution_id }}',
                    '{{ user.name }}',
                    {{ response.profile_score | default(0.0) }},
                    '{{ response.score_category | default("unknown") }}'
                  )
                  ON CONFLICT (id) DO UPDATE SET
                    user_name = EXCLUDED.user_name,
                    profile_score = EXCLUDED.profile_score,
                    score_category = EXCLUDED.score_category,
                    processed_at = now();
          - next:
              - step: validate_results

  - step: validate_results
    desc: "Validate all profile scores are within expected range and categories are correct"
    tool:
      kind: python
      auth: {}
      libs: {}
      args:
        user_results: "{{ process_users.data }}"
        expected_min_score: 0.0
        expected_max_score: 100.0
        valid_categories: ["Junior", "Mid-Level", "Senior", "Executive"]
      code: |
        # Be tolerant of early execution before loop aggregation completes.
        # If we did not receive a list of final results yet, return a tracking status
        # instead of raising an error to avoid polluting event logs.
        if not isinstance(user_results, list):
            size = 0
            try:
                size = len(user_results)  # may be 0 for non-sized types
            except Exception:
                size = 0
            result = {
                "status": "tracking",
                "all_valid": None,
                "total_users": size,
                "valid_users": 0,
                "validation_details": [],
                "summary": "Awaiting loop aggregation of process_users results"
            }
        else:
            validation_results = []
            all_valid = True
            
            for i, res in enumerate(user_results):
                if not isinstance(res, dict):
                    validation_results.append({
                        "index": i,
                        "valid": False,
                        "message": f"Result {i} is not a dict: {type(res)}"
                    })
                    all_valid = False
                    continue
                
                # Check if result has required fields
                profile_score = res.get('profile_score')
                score_category = res.get('score_category')
                user_name = res.get('user_name', f'user_{i}')
                
                validation = {
                    "index": i,
                    "user_name": user_name,
                    "profile_score": profile_score,
                    "score_category": score_category,
                    "valid": True,
                    "issues": []
                }
                
                # Validate profile score
                if profile_score is None:
                    validation["issues"].append("Missing profile_score")
                    validation["valid"] = False
                elif not isinstance(profile_score, (int, float)):
                    validation["issues"].append(f"profile_score must be numeric, got {type(profile_score)}")
                    validation["valid"] = False
                elif not (expected_min_score <= profile_score <= expected_max_score):
                    validation["issues"].append(f"profile_score {profile_score} not in range [{expected_min_score}, {expected_max_score}]")
                    validation["valid"] = False
                
                # Validate score category
                if score_category is None:
                    validation["issues"].append("Missing score_category")
                    validation["valid"] = False
                elif score_category not in valid_categories:
                    validation["issues"].append(f"score_category '{score_category}' not in valid categories {valid_categories}")
                    validation["valid"] = False
                
                if not validation["valid"]:
                    all_valid = False
                
                validation_results.append(validation)
            
            result = {
                "status": "success" if all_valid else "validation_failed",
                "all_valid": all_valid,
                "total_users": len(user_results),
                "valid_users": sum(1 for v in validation_results if v["valid"]),
                "validation_details": validation_results,
                "summary": f"Processed {len(user_results)} users, {sum(1 for v in validation_results if v['valid'])} valid"
            }
    
    case:
      - when: "{{ event.name == 'call.done' }}"
        then:
          next:
            - step: end

  - step: end
    desc: "Complete profile processing pipeline"
    tool:
      kind: python
      auth: {}
      libs: {}
      args:
        validation_result: "{{ validate_results.data }}"
        user_count: "{{ workload.users | length }}"
      code: |
        # Be robust to unexpected types (e.g., during early tracking states)
        if not isinstance(validation_result, dict):
            try:
                summary = str(validation_result)
            except Exception:
                summary = 'N/A'
            validation_result = {
                'status': 'unknown',
                'all_valid': False,
                'summary': summary
            }
        print(f"Pipeline completed successfully!")
        print(f"Users processed: {user_count}")
        print(f"Validation status: {validation_result.get('status', 'unknown')}")
        print(f"All valid: {validation_result.get('all_valid', False)}")
        print(f"Summary: {validation_result.get('summary', 'No summary available')}")
        
        result = {
            "pipeline_status": "completed",
            "users_processed": user_count,
            "validation_passed": validation_result.get('all_valid', False),
            "message": "Playbook composition test completed successfully"
        }