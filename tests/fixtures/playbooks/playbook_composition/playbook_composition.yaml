apiVersion: noetl.io/v2
kind: Playbook

metadata:
  name: playbook_composition
  path: tests/fixtures/playbooks/playbook_composition/playbook_composition

workload:
  pg_auth: pg_local
  message: "Playbook composition with iterator validation"
  users:
    - name: "Alice"
      age: 28
      department: "Engineering"
      years_experience: 5
      performance_rating: 4.2
    - name: "Bob"
      age: 34
      department: "Marketing"
      years_experience: 8
      performance_rating: 3.8
    - name: "Charlie"
      age: 29
      department: "Engineering"
      years_experience: 3
      performance_rating: 4.5
    - name: "Diana"
      age: 42
      department: "Management"
      years_experience: 15
      performance_rating: 4.0

workflow:
  - step: start
    desc: "Initialize user profile processing"
    tool:
      kind: python
      code: |
        def main():
            return {"status": "initialized"}
    
    case:
      - when: "{{ event.name == 'step.exit' }}"
        then:
          next:
            - step: setup_storage

  - step: setup_storage
    desc: "Ensure results table exists"
    tool:
      kind: postgres
      auth: "{{ workload.pg_auth }}"
      command: |
        CREATE TABLE IF NOT EXISTS public.user_profile_results (
          id TEXT PRIMARY KEY,
          execution_id TEXT,
          user_name TEXT,
          profile_score DOUBLE PRECISION,
          score_category TEXT,
          processed_at TIMESTAMPTZ DEFAULT now()
        );
    
    case:
      - when: "{{ event.name == 'call.done' and response is defined }}"
        then:
          next:
            - step: process_users

  - step: process_users
    desc: "Process each user through profile scoring sub-playbook"
    tool:
      kind: playbook
      loop:
        in: "{{ workload.users }}"
        iterator: user
        mode: sequential
      # Provide an explicit task identifier so nested playbook propagates correct parent_step
      task: process_users
      path: tests/fixtures/playbooks/playbook_composition/user_profile_scorer
      return_step: finalize_result
      args:
        user_data: "{{ user }}"
        execution_context: "{{ execution_id }}"
    
    case:
      - when: "{{ event.name == 'call.done' and response is defined }}"
        then:
          sink:
            args:
              id: "{{ execution_id }}:{{ user.name }}"
              execution_id: "{{ execution_id }}"
              user_name: "{{ user.name }}"
              profile_score: "{{ response.profile_score or 0.0 }}"
              score_category: "{{ response.score_category or 'unknown' }}"
            tool: postgres
            auth: "{{ workload.pg_auth }}"
            table: public.user_profile_results
            mode: upsert
            key: id
          next:
            - step: validate_results

  - step: validate_results
    desc: "Validate all profile scores are within expected range and categories are correct"
    tool:
      kind: python
      args:
        user_results: "{{ process_users.data }}"
        expected_min_score: 0.0
        expected_max_score: 100.0
        valid_categories: ["Junior", "Mid-Level", "Senior", "Executive"]
      code: |
        def main(user_results, expected_min_score, expected_max_score, valid_categories):
          # Be tolerant of early execution before loop aggregation completes.
          # If we did not receive a list of final results yet, return a tracking status
          # instead of raising an error to avoid polluting event logs.
          if not isinstance(user_results, list):
              size = 0
              try:
                  size = len(user_results)  # may be 0 for non-sized types
              except Exception:
                  size = 0
              return {
                  "status": "tracking",
                  "all_valid": None,
                  "total_users": size,
                  "valid_users": 0,
                  "validation_details": [],
                  "summary": "Awaiting loop aggregation of process_users results"
              }
          
          validation_results = []
          all_valid = True
          
          for i, result in enumerate(user_results):
              if not isinstance(result, dict):
                  validation_results.append({
                      "index": i,
                      "valid": False,
                      "message": f"Result {i} is not a dict: {type(result)}"
                  })
                  all_valid = False
                  continue
              
              # Check if result has required fields
              profile_score = result.get('profile_score')
              score_category = result.get('score_category')
              user_name = result.get('user_name', f'user_{i}')
              
              validation = {
                  "index": i,
                  "user_name": user_name,
                  "profile_score": profile_score,
                  "score_category": score_category,
                  "valid": True,
                  "issues": []
              }
              
              # Validate profile score
              if profile_score is None:
                  validation["issues"].append("Missing profile_score")
                  validation["valid"] = False
              elif not isinstance(profile_score, (int, float)):
                  validation["issues"].append(f"profile_score must be numeric, got {type(profile_score)}")
                  validation["valid"] = False
              elif not (expected_min_score <= profile_score <= expected_max_score):
                  validation["issues"].append(f"profile_score {profile_score} not in range [{expected_min_score}, {expected_max_score}]")
                  validation["valid"] = False
              
              # Validate score category
              if score_category is None:
                  validation["issues"].append("Missing score_category")
                  validation["valid"] = False
              elif score_category not in valid_categories:
                  validation["issues"].append(f"score_category '{score_category}' not in valid categories {valid_categories}")
                  validation["valid"] = False
              
              if not validation["valid"]:
                  all_valid = False
              
              validation_results.append(validation)
          
          return {
              "status": "success" if all_valid else "validation_failed",
              "all_valid": all_valid,
              "total_users": len(user_results),
              "valid_users": sum(1 for v in validation_results if v["valid"]),
              "validation_details": validation_results,
              "summary": f"Processed {len(user_results)} users, {sum(1 for v in validation_results if v['valid'])} valid"
          }
    
    case:
      - when: "{{ event.name == 'call.done' and response is defined }}"
        then:
          next:
            - step: end

  - step: end
    desc: "Complete profile processing pipeline"
    tool:
      kind: python
      args:
        validation_result: "{{ validate_results.data }}"
        user_count: "{{ workload.users | length }}"
      code: |
        def main(validation_result, user_count):
            # Be robust to unexpected types (e.g., during early tracking states)
            if not isinstance(validation_result, dict):
                try:
                    summary = str(validation_result)
                except Exception:
                    summary = 'N/A'
                validation_result = {
                    'status': 'unknown',
                    'all_valid': False,
                    'summary': summary
                }
            print(f"Pipeline completed successfully!")
            print(f"Users processed: {user_count}")
            print(f"Validation status: {validation_result.get('status', 'unknown')}")
            print(f"All valid: {validation_result.get('all_valid', False)}")
            print(f"Summary: {validation_result.get('summary', 'No summary available')}")
            
            return {
                "pipeline_status": "completed",
                "users_processed": user_count,
                "validation_passed": validation_result.get('all_valid', False),
                "message": "Playbook composition test completed successfully"
            }