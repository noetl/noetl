apiVersion: noetl.io/v2
kind: Playbook
metadata:
  name: test_storage_tiers
  path: tests/storage_tiers_test
  description: 'Test all storage tier auto-selection based on result size.


    Storage Tiers:

    - Inline: < 64KB (no externalization)

    - NATS KV: 64KB - 1MB

    - NATS Object Store: 1MB - 10MB

    - S3/GCS: > 10MB (fallback to Object Store if not configured)

    '
workload:
  inline_items: 100
  inline_item_size: 50
  kv_items: 500
  kv_item_size: 200
  object_items: 2000
  object_item_size: 1000
  large_items: 5000
  large_item_size: 3000
workflow:
- step: start
  tool:
  - name: generate_inline
    kind: python
    args:
      count: '{{ inline_items }}'
      size: '{{ inline_item_size }}'
    code: "items = [{\"id\": i, \"data\": \"x\" * size} for i in range(count)]\nresult\
      \ = {\n    \"status\": \"ok\",\n    \"tier\": \"inline\",\n    \"count\": len(items),\n\
      \    \"total_bytes\": count * size,\n    \"items\": items\n}\n"
  result:
    output_select:
    - status
    - tier
    - count
    - total_bytes
  next:
    spec:
      mode: exclusive
    arcs:
    - step: test_nats_kv
- step: test_nats_kv
  tool:
  - name: generate_kv
    kind: python
    args:
      count: '{{ kv_items }}'
      size: '{{ kv_item_size }}'
    code: "items = [{\"id\": i, \"data\": \"K\" * size, \"active\": True} for i in\
      \ range(count)]\nresult = {\n    \"status\": \"ok\",\n    \"tier\": \"kv_expected\"\
      ,\n    \"count\": len(items),\n    \"total_bytes\": count * size,\n    \"items\"\
      : items\n}\n"
  result:
    output_select:
    - status
    - tier
    - count
    - total_bytes
  next:
    spec:
      mode: exclusive
    arcs:
    - step: test_nats_object
- step: test_nats_object
  tool:
  - name: generate_object
    kind: python
    args:
      count: '{{ object_items }}'
      size: '{{ object_item_size }}'
    code: "items = [{\"id\": i, \"data\": \"O\" * size, \"active\": True} for i in\
      \ range(count)]\nresult = {\n    \"status\": \"ok\",\n    \"tier\": \"object_expected\"\
      ,\n    \"count\": len(items),\n    \"total_bytes\": count * size,\n    \"items\"\
      : items\n}\n"
  result:
    output_select:
    - status
    - tier
    - count
    - total_bytes
  next:
    spec:
      mode: exclusive
    arcs:
    - step: test_large_storage
- step: test_large_storage
  tool:
  - name: generate_large
    kind: python
    args:
      count: '{{ large_items }}'
      size: '{{ large_item_size }}'
    code: "items = [{\"id\": i, \"data\": \"L\" * size, \"active\": True} for i in\
      \ range(count)]\nresult = {\n    \"status\": \"ok\",\n    \"tier\": \"s3_or_object_expected\"\
      ,\n    \"count\": len(items),\n    \"total_bytes\": count * size,\n    \"items\"\
      : items\n}\n"
  result:
    output_select:
    - status
    - tier
    - count
    - total_bytes
  next:
    spec:
      mode: exclusive
    arcs:
    - step: verify_storage_tiers
- step: verify_storage_tiers
  tool:
  - name: verify_tiers
    kind: python
    args:
      inline_has_ref: '{{ start._ref is defined }}'
      inline_status: '{{ start.status }}'
      inline_bytes: '{{ start.total_bytes }}'
      kv_has_ref: '{{ test_nats_kv._ref is defined }}'
      kv_store: '{{ test_nats_kv._store | default(''none'') }}'
      kv_status: '{{ test_nats_kv.status }}'
      kv_bytes: '{{ test_nats_kv.total_bytes }}'
      object_has_ref: '{{ test_nats_object._ref is defined }}'
      object_store: '{{ test_nats_object._store | default(''none'') }}'
      object_status: '{{ test_nats_object.status }}'
      object_bytes: '{{ test_nats_object.total_bytes }}'
      large_has_ref: '{{ test_large_storage._ref is defined }}'
      large_store: '{{ test_large_storage._store | default(''none'') }}'
      large_status: '{{ test_large_storage.status }}'
      large_bytes: '{{ test_large_storage.total_bytes }}'
    code: "results = {\n    \"inline\": {\n        \"externalized\": inline_has_ref,\n\
      \        \"expected_externalized\": False,  # Under 64KB threshold\n       \
      \ \"status\": inline_status,\n        \"bytes\": inline_bytes,\n        \"correct\"\
      : not inline_has_ref  # Should NOT be externalized\n    },\n    \"nats_kv\"\
      : {\n        \"externalized\": kv_has_ref,\n        \"store\": kv_store,\n \
      \       \"expected_store\": \"kv\",\n        \"status\": kv_status,\n      \
      \  \"bytes\": kv_bytes,\n        \"correct\": kv_has_ref and kv_store == \"\
      kv\"\n    },\n    \"nats_object\": {\n        \"externalized\": object_has_ref,\n\
      \        \"store\": object_store,\n        \"expected_store\": \"object\",\n\
      \        \"status\": object_status,\n        \"bytes\": object_bytes,\n    \
      \    \"correct\": object_has_ref and object_store == \"object\"\n    },\n  \
      \  \"large_storage\": {\n        \"externalized\": large_has_ref,\n        \"\
      store\": large_store,\n        \"expected_store\": \"s3 or object (fallback)\"\
      ,\n        \"status\": large_status,\n        \"bytes\": large_bytes,\n    \
      \    \"correct\": large_has_ref and large_store in (\"s3\", \"object\", \"gcs\"\
      )\n    }\n}\n\nall_correct = all(r[\"correct\"] for r in results.values())\n\
      \nresult = {\n    \"test_result\": \"PASSED\" if all_correct else \"FAILED\"\
      ,\n    \"all_tiers_correct\": all_correct,\n    \"tier_results\": results,\n\
      \    \"summary\": {\n        \"inline_correct\": results[\"inline\"][\"correct\"\
      ],\n        \"kv_correct\": results[\"nats_kv\"][\"correct\"],\n        \"object_correct\"\
      : results[\"nats_object\"][\"correct\"],\n        \"large_correct\": results[\"\
      large_storage\"][\"correct\"]\n    }\n}\n"
  next:
    spec:
      mode: exclusive
    arcs:
    - step: load_kv_data
- step: load_kv_data
  tool:
  - name: load_kv
    kind: artifact
    action: get
    args:
      result_ref: '{{ test_nats_kv._ref }}'
  next:
    spec:
      mode: exclusive
    arcs:
    - step: load_object_data
- step: load_object_data
  tool:
  - name: load_object
    kind: artifact
    action: get
    args:
      result_ref: '{{ test_nats_object._ref }}'
  next:
    spec:
      mode: exclusive
    arcs:
    - step: load_large_data
- step: load_large_data
  tool:
  - name: load_large
    kind: artifact
    action: get
    args:
      result_ref: '{{ test_large_storage._ref }}'
  next:
    spec:
      mode: exclusive
    arcs:
    - step: final_summary
- step: final_summary
  tool:
  - name: summarize
    kind: python
    args:
      tier_results: '{{ verify_storage_tiers.tier_results }}'
      kv_loaded_count: '{{ load_kv_data.count | default(0) }}'
      object_loaded_count: '{{ load_object_data.count | default(0) }}'
      large_loaded_count: '{{ load_large_data.count | default(0) }}'
    code: "load_results = {\n    \"kv_loaded\": kv_loaded_count == 500,\n    \"kv_count\"\
      : kv_loaded_count,\n    \"object_loaded\": object_loaded_count == 2000,\n  \
      \  \"object_count\": object_loaded_count,\n    \"large_loaded\": large_loaded_count\
      \ == 5000,\n    \"large_count\": large_loaded_count\n}\n\nall_loaded = all([\n\
      \    load_results[\"kv_loaded\"],\n    load_results[\"object_loaded\"],\n  \
      \  load_results[\"large_loaded\"]\n])\n\nall_tiers_correct = all(r[\"correct\"\
      ] for r in tier_results.values())\n\nresult = {\n    \"test_result\": \"PASSED\"\
      \ if (all_loaded and all_tiers_correct) else \"FAILED\",\n    \"storage_tier_selection\"\
      : \"PASSED\" if all_tiers_correct else \"FAILED\",\n    \"lazy_loading\": \"\
      PASSED\" if all_loaded else \"FAILED\",\n    \"tier_details\": tier_results,\n\
      \    \"load_details\": load_results,\n    \"message\": \"All storage tiers working\
      \ correctly\" if (all_loaded and all_tiers_correct) else \"Some tests failed\"\
      \n}\n"
