apiVersion: v1
kind: ConfigMap
metadata:
  name: postgres-config-files
  namespace: postgres
  labels:
    app: postgres
data:
  init_database.sh: |
    #!/bin/bash
    set -e

    POSTGRES="psql -d ${POSTGRES_DB} --username ${POSTGRES_USER}"

    echo "Creating database schemas in $POSTGRES_DB"

    echo "Creating database schema ${POSTGRES_SCHEMA}"

    $POSTGRES <<-ESQL
    \connect ${POSTGRES_DB};
    SET SESSION AUTHORIZATION ${POSTGRES_USER};
    CREATE SCHEMA IF NOT EXISTS ${POSTGRES_SCHEMA};
    CREATE EXTENSION IF NOT EXISTS plpython3u;
    ESQL

    echo "Database schema ${POSTGRES_SCHEMA} created"

    # Create noetl user and schema
    echo "Creating noetl user and schema"

    $POSTGRES <<-ESQL
    \connect ${POSTGRES_DB};
    SET SESSION AUTHORIZATION ${POSTGRES_USER};

    -- Create noetl user if it doesn't exist
    DO \$\$
    BEGIN
      IF NOT EXISTS (SELECT FROM pg_catalog.pg_roles WHERE rolname = '${NOETL_USER}') THEN
        CREATE USER ${NOETL_USER} WITH PASSWORD '${NOETL_PASSWORD}' CREATEDB LOGIN;
      END IF;
    END
    \$\$;

    -- Create noetl schema if it doesn't exist
    CREATE SCHEMA IF NOT EXISTS ${NOETL_SCHEMA};

    -- Grant privileges to noetl user
    GRANT ALL PRIVILEGES ON SCHEMA ${NOETL_SCHEMA} TO ${NOETL_USER};
    GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA ${NOETL_SCHEMA} TO ${NOETL_USER};
    GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA ${NOETL_SCHEMA} TO ${NOETL_USER};
    ALTER DEFAULT PRIVILEGES IN SCHEMA ${NOETL_SCHEMA} GRANT ALL ON TABLES TO ${NOETL_USER};
    ALTER DEFAULT PRIVILEGES IN SCHEMA ${NOETL_SCHEMA} GRANT ALL ON SEQUENCES TO ${NOETL_USER};
    ESQL

    echo "Noetl user and schema created"

    # Apply canonical schema DDL
    $POSTGRES -v ON_ERROR_STOP=1 -f /schema_ddl.sql --echo-all

    echo "Database schema objects created"

  schema_ddl.sql: |
    -- Canonical Schema DDL for NoETL (single source of truth)
    -- Ensures noetl owns all objects to avoid owner-only DDL failures

    CREATE SCHEMA IF NOT EXISTS noetl;
    ALTER SCHEMA noetl OWNER TO noetl;
    ALTER DEFAULT PRIVILEGES IN SCHEMA noetl GRANT ALL ON TABLES TO noetl;
    ALTER DEFAULT PRIVILEGES IN SCHEMA noetl GRANT ALL ON SEQUENCES TO noetl;

    -- Resource
    CREATE TABLE IF NOT EXISTS noetl.resource (
        name TEXT PRIMARY KEY
    );
    ALTER TABLE noetl.resource OWNER TO noetl;

    -- Catalog
    CREATE TABLE IF NOT EXISTS noetl.catalog (
        resource_path     TEXT     NOT NULL,
        resource_type     TEXT     NOT NULL REFERENCES noetl.resource(name),
        resource_version  TEXT     NOT NULL,
        source            TEXT     NOT NULL DEFAULT 'inline',
        resource_location TEXT,
        content           TEXT,
        payload           JSONB    NOT NULL,
        meta              JSONB,
        template          TEXT,
        timestamp         TIMESTAMPTZ NOT NULL DEFAULT now(),
        PRIMARY KEY (resource_path, resource_version)
    );
    ALTER TABLE noetl.catalog OWNER TO noetl;

    -- Workload
    CREATE TABLE IF NOT EXISTS noetl.workload (
        execution_id BIGINT,
        timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        data TEXT,
        PRIMARY KEY (execution_id)
    );
    ALTER TABLE noetl.workload OWNER TO noetl;

    -- Event log
    CREATE TABLE IF NOT EXISTS noetl.event_log (
        execution_id BIGINT,
        event_id BIGINT,
        parent_event_id BIGINT,
        parent_execution_id BIGINT,
        timestamp TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
        event_type VARCHAR,
        node_id VARCHAR,
        node_name VARCHAR,
        node_type VARCHAR,
        status VARCHAR,
        duration DOUBLE PRECISION,
        context TEXT,
        result TEXT,
        metadata TEXT,
        error TEXT,
        loop_id VARCHAR,
        loop_name VARCHAR,
        iterator VARCHAR,
        items TEXT,
        current_index INTEGER,
        current_item TEXT,
        worker_id VARCHAR,
        distributed_state VARCHAR,
        context_key VARCHAR,
        context_value TEXT,
        trace_component JSONB,
        PRIMARY KEY (execution_id, event_id)
    );
    ALTER TABLE noetl.event_log OWNER TO noetl;
    ALTER TABLE noetl.event_log ADD COLUMN IF NOT EXISTS trace_component JSONB;
    ALTER TABLE noetl.event_log ADD COLUMN IF NOT EXISTS parent_execution_id BIGINT;
    -- Ensure timestamp column has a default
    DO \$\$ BEGIN
        ALTER TABLE noetl.event_log ALTER COLUMN timestamp SET DEFAULT CURRENT_TIMESTAMP;
    EXCEPTION WHEN others THEN NULL; END \$\$;

    -- Workflow/workbook/transition
    CREATE TABLE IF NOT EXISTS noetl.workflow (
        execution_id BIGINT,
        step_id VARCHAR,
        step_name VARCHAR,
        step_type VARCHAR,
        description TEXT,
        raw_config TEXT,
        PRIMARY KEY (execution_id, step_id)
    );
    ALTER TABLE noetl.workflow OWNER TO noetl;

    CREATE TABLE IF NOT EXISTS noetl.workbook (
        execution_id BIGINT,
        task_id VARCHAR,
        task_name VARCHAR,
        task_type VARCHAR,
        raw_config TEXT,
        PRIMARY KEY (execution_id, task_id)
    );
    ALTER TABLE noetl.workbook OWNER TO noetl;

    CREATE TABLE IF NOT EXISTS noetl.transition (
        execution_id BIGINT,
        from_step VARCHAR,
        to_step VARCHAR,
        condition TEXT,
        with_params TEXT,
        PRIMARY KEY (execution_id, from_step, to_step, condition)
    );
    ALTER TABLE noetl.transition OWNER TO noetl;

    -- Error log
    CREATE TABLE IF NOT EXISTS noetl.error_log (
        error_id BIGINT PRIMARY KEY,
        timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        error_type VARCHAR(50),
        error_message TEXT,
        execution_id BIGINT,
        step_id VARCHAR,
        step_name VARCHAR,
        template_string TEXT,
        context_data JSONB,
        stack_trace TEXT,
        input_data JSONB,
        output_data JSONB,
        severity VARCHAR(20) DEFAULT 'error',
        resolved BOOLEAN DEFAULT FALSE,
        resolution_notes TEXT,
        resolution_timestamp TIMESTAMP
    );
    ALTER TABLE noetl.error_log OWNER TO noetl;
    CREATE INDEX IF NOT EXISTS idx_error_log_timestamp ON noetl.error_log (timestamp);
    CREATE INDEX IF NOT EXISTS idx_error_log_error_type ON noetl.error_log (error_type);
    CREATE INDEX IF NOT EXISTS idx_error_log_execution_id ON noetl.error_log (execution_id);
    CREATE INDEX IF NOT EXISTS idx_error_log_resolved ON noetl.error_log (resolved);

    -- Credential
    CREATE TABLE IF NOT EXISTS noetl.credential (
        id SERIAL PRIMARY KEY,
        name TEXT NOT NULL UNIQUE,
        type TEXT NOT NULL,
        data_encrypted TEXT NOT NULL,
        meta JSONB,
        tags TEXT[],
        description TEXT,
        created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
        updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
    );
    ALTER TABLE noetl.credential OWNER TO noetl;
    CREATE INDEX IF NOT EXISTS idx_credential_type ON noetl.credential (type);
    ALTER TABLE noetl.catalog ADD COLUMN IF NOT EXISTS credential_id INTEGER;

    -- Runtime
    CREATE TABLE IF NOT EXISTS noetl.runtime (
        runtime_id BIGINT PRIMARY KEY,
        name TEXT NOT NULL,
        component_type TEXT NOT NULL CHECK (component_type IN ('worker_pool','server_api','broker')),
        base_url TEXT,
        status TEXT NOT NULL,
        labels JSONB,
        capabilities JSONB,
        capacity INTEGER,
        runtime JSONB,
        last_heartbeat TIMESTAMPTZ NOT NULL DEFAULT now(),
        created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
        updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
    );
    ALTER TABLE noetl.runtime OWNER TO noetl;
    CREATE UNIQUE INDEX IF NOT EXISTS idx_runtime_component_name ON noetl.runtime (component_type, name);
    CREATE INDEX IF NOT EXISTS idx_runtime_type ON noetl.runtime (component_type);
    CREATE INDEX IF NOT EXISTS idx_runtime_status ON noetl.runtime (status);
    CREATE INDEX IF NOT EXISTS idx_runtime_runtime_type ON noetl.runtime ((runtime->>'type'));

    -- Queue
    CREATE TABLE IF NOT EXISTS noetl.queue (
        id BIGSERIAL PRIMARY KEY,
        execution_id BIGINT NOT NULL,
        node_id VARCHAR NOT NULL,
        action TEXT NOT NULL,
        context JSONB,
        status TEXT NOT NULL DEFAULT 'queued',
        priority INTEGER NOT NULL DEFAULT 0,
        attempts INTEGER NOT NULL DEFAULT 0,
        max_attempts INTEGER NOT NULL DEFAULT 5,
        available_at TIMESTAMPTZ NOT NULL DEFAULT now(),
        lease_until TIMESTAMPTZ,
        worker_id TEXT,
        last_heartbeat TIMESTAMPTZ NOT NULL DEFAULT now(),
        created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
        updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
    );
    ALTER TABLE noetl.queue OWNER TO noetl;
    CREATE INDEX IF NOT EXISTS idx_queue_status ON noetl.queue (status);
    CREATE INDEX IF NOT EXISTS idx_queue_priority ON noetl.queue (priority);
    CREATE INDEX IF NOT EXISTS idx_queue_available_at ON noetl.queue (available_at);
    CREATE INDEX IF NOT EXISTS idx_queue_worker ON noetl.queue (worker_id);
    -- Prevent duplicate jobs for the same execution and node
    DO $$ BEGIN
        CREATE UNIQUE INDEX IF NOT EXISTS idx_queue_exec_node ON noetl.queue (execution_id, node_id);
    EXCEPTION WHEN others THEN NULL; END $$;

    -- Schedule
    CREATE TABLE IF NOT EXISTS noetl.schedule (
        schedule_id BIGSERIAL PRIMARY KEY,
        playbook_path TEXT NOT NULL,
        playbook_version TEXT,
        cron TEXT,
        interval_seconds INTEGER,
        enabled BOOLEAN NOT NULL DEFAULT TRUE,
        timezone TEXT DEFAULT 'UTC',
        next_run_at TIMESTAMPTZ,
        last_run_at TIMESTAMPTZ,
        last_status TEXT,
        input_payload JSONB,
        created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
        updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
        meta JSONB
    );
    ALTER TABLE noetl.schedule OWNER TO noetl;
    CREATE INDEX IF NOT EXISTS idx_schedule_next_run ON noetl.schedule (next_run_at) WHERE enabled = TRUE;
    CREATE INDEX IF NOT EXISTS idx_schedule_playbook ON noetl.schedule (playbook_path);

    -- Identity & collaboration tables
    CREATE TABLE IF NOT EXISTS noetl.role (
        id BIGINT PRIMARY KEY,
        name TEXT UNIQUE NOT NULL,
        description TEXT
    );
    ALTER TABLE noetl.role OWNER TO noetl;

    CREATE TABLE IF NOT EXISTS noetl.profile (
        id BIGINT PRIMARY KEY,
        username TEXT UNIQUE NOT NULL,
        email TEXT UNIQUE,
        password_hash TEXT,
        role_id BIGINT REFERENCES noetl.role(id),
        type TEXT NOT NULL CHECK (type IN ('user','bot')),
        created_at TIMESTAMPTZ DEFAULT now()
    );
    ALTER TABLE noetl.profile OWNER TO noetl;

    CREATE TABLE IF NOT EXISTS noetl.session (
        id BIGINT PRIMARY KEY,
        profile_id BIGINT REFERENCES noetl.profile(id),
        session_type TEXT NOT NULL CHECK (session_type IN ('user','bot','ai')),
        connected_at TIMESTAMPTZ DEFAULT now(),
        disconnected_at TIMESTAMPTZ,
        metadata JSONB
    );
    ALTER TABLE noetl.session OWNER TO noetl;

    CREATE TABLE IF NOT EXISTS noetl.label (
        id BIGINT PRIMARY KEY,
        parent_id BIGINT REFERENCES noetl.label(id) ON DELETE CASCADE,
        name TEXT NOT NULL,
        owner_id BIGINT REFERENCES noetl.profile(id),
        created_at TIMESTAMPTZ DEFAULT now()
    );
    ALTER TABLE noetl.label OWNER TO noetl;

    CREATE TABLE IF NOT EXISTS noetl.chat (
        id BIGINT PRIMARY KEY,
        label_id BIGINT REFERENCES noetl.label(id) ON DELETE CASCADE,
        name TEXT NOT NULL,
        owner_id BIGINT REFERENCES noetl.profile(id),
        created_at TIMESTAMPTZ DEFAULT now()
    );
    ALTER TABLE noetl.chat OWNER TO noetl;

    CREATE TABLE IF NOT EXISTS noetl.member (
        id BIGINT PRIMARY KEY,
        chat_id BIGINT REFERENCES noetl.chat(id) ON DELETE CASCADE,
        profile_id BIGINT REFERENCES noetl.profile(id) ON DELETE CASCADE,
        role TEXT NOT NULL CHECK (role IN ('owner','admin','member')),
        joined_at TIMESTAMPTZ DEFAULT now(),
        UNIQUE(chat_id, profile_id)
    );
    ALTER TABLE noetl.member OWNER TO noetl;

    CREATE TABLE IF NOT EXISTS noetl.message (
        id BIGINT PRIMARY KEY,
        chat_id BIGINT REFERENCES noetl.chat(id) ON DELETE CASCADE,
        sender_type TEXT NOT NULL CHECK (sender_type IN ('user','bot','ai','system')),
        sender_id BIGINT,
        role TEXT,
        content TEXT NOT NULL,
        metadata JSONB,
        created_at TIMESTAMPTZ DEFAULT now()
    );
    ALTER TABLE noetl.message OWNER TO noetl;

    CREATE TABLE IF NOT EXISTS noetl.attachment (
        id BIGINT PRIMARY KEY,
        label_id BIGINT REFERENCES noetl.label(id) ON DELETE CASCADE,
        chat_id BIGINT REFERENCES noetl.chat(id) ON DELETE CASCADE,
        filename TEXT NOT NULL,
        filepath TEXT NOT NULL,
        uploaded_by BIGINT REFERENCES noetl.profile(id),
        created_at TIMESTAMPTZ DEFAULT now()
    );
    ALTER TABLE noetl.attachment OWNER TO noetl;
    CREATE INDEX IF NOT EXISTS idx_label_parent ON noetl.label(parent_id);
    CREATE UNIQUE INDEX IF NOT EXISTS idx_label_parent_name ON noetl.label(parent_id, name);
    CREATE INDEX IF NOT EXISTS idx_chat_label ON noetl.chat(label_id);
    CREATE INDEX IF NOT EXISTS idx_message_chat_created ON noetl.message(chat_id, created_at);
    CREATE INDEX IF NOT EXISTS idx_attachment_chat_created ON noetl.attachment(chat_id, created_at);

    -- Snowflake-like id helpers
    CREATE SEQUENCE IF NOT EXISTS noetl.snowflake_seq;
    ALTER SEQUENCE noetl.snowflake_seq OWNER TO noetl;
    CREATE OR REPLACE FUNCTION noetl.snowflake_id() RETURNS BIGINT AS $$
    DECLARE
        our_epoch BIGINT := 1704067200000;
        seq_id BIGINT;
        now_ms BIGINT;
        shard_id INT := 1;
    BEGIN
        SELECT nextval('noetl.snowflake_seq') % 1024 INTO seq_id;
        now_ms := (EXTRACT(EPOCH FROM clock_timestamp()) * 1000)::BIGINT;
        RETURN ((now_ms - our_epoch) << 23) |
               ((shard_id & 31) << 18) |
               (seq_id & 262143);
    END;
    $$ LANGUAGE plpgsql;
    ALTER FUNCTION noetl.snowflake_id() OWNER TO noetl;
    ALTER TABLE noetl.role ALTER COLUMN id SET DEFAULT noetl.snowflake_id();
    ALTER TABLE noetl.profile ALTER COLUMN id SET DEFAULT noetl.snowflake_id();
    ALTER TABLE noetl.session ALTER COLUMN id SET DEFAULT noetl.snowflake_id();
    ALTER TABLE noetl.label ALTER COLUMN id SET DEFAULT noetl.snowflake_id();
    ALTER TABLE noetl.chat ALTER COLUMN id SET DEFAULT noetl.snowflake_id();
    ALTER TABLE noetl.member ALTER COLUMN id SET DEFAULT noetl.snowflake_id();
    ALTER TABLE noetl.message ALTER COLUMN id SET DEFAULT noetl.snowflake_id();
    ALTER TABLE noetl.attachment ALTER COLUMN id SET DEFAULT noetl.snowflake_id();

    -- Seed sample roles (ids via function)
    INSERT INTO noetl.role(id, name, description) VALUES (noetl.snowflake_id(), 'admin', 'Administrator') ON CONFLICT (name) DO NOTHING;
    INSERT INTO noetl.role(id, name, description) VALUES (noetl.snowflake_id(), 'user', 'Standard user') ON CONFLICT (name) DO NOTHING;
    INSERT INTO noetl.role(id, name, description) VALUES (noetl.snowflake_id(), 'bot', 'Automation bot') ON CONFLICT (name) DO NOTHING;

  postgresql.conf: |
    # PostgreSQL configuration file
    # -----------------------------
    #
    # This file consists of lines of the form:
    #
    #   name = value
    #
    # (The "=" is optional.)  Whitespace may be used.  Comments are introduced with
    # "#" anywhere on a line.  The complete list of parameter names and allowed
    # values can be found in the PostgreSQL documentation.
    #
    # The commented-out settings shown in this file represent the default values.
    # Re-commenting a setting is NOT sufficient to revert it to the default value;
    # you need to reload the server.
    #
    # This file is read on server startup and when the server receives a SIGHUP
    # signal.  If you edit the file on a running system, you have to SIGHUP the
    # server for the changes to take effect, run "pg_ctl reload", or execute
    # "SELECT pg_reload_conf()".  Some parameters, which are marked below,
    # require a server shutdown and restart to take effect.
    #
    # Any parameter can also be given as a command-line option to the server, e.g.,
    # "postgres -c log_connections=on".  Some parameters can be changed at run time
    # with the "SET" SQL command.
    #
    # Memory units:  B  = bytes            Time units:  us  = microseconds
    #                kB = kilobytes                     ms  = milliseconds
    #                MB = megabytes                     s   = seconds
    #                GB = gigabytes                     min = minutes
    #                TB = terabytes                     h   = hours
    #                                                   d   = days

    # File Locations
    data_directory = '/var/lib/postgresql/data'
    hba_file = '/var/lib/postgresql/data/pg_hba.conf'
    ident_file = '/var/lib/postgresql/data/pg_ident.conf'

    # Connections and Authentication
    listen_addresses = '*'
    port = 5432
    max_connections = 100
    
    # Memory
    shared_buffers = 128MB
    
    # Logging
    log_destination = 'stderr'
    logging_collector = on
    log_directory = 'log'
    log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
    log_truncate_on_rotation = off
    log_rotation_age = 1d
    log_rotation_size = 10MB
    
    # Locale and Formatting
    datestyle = 'iso, mdy'
    timezone = 'UTC'
    lc_messages = 'en_US.utf8'
    lc_monetary = 'en_US.utf8'
    lc_numeric = 'en_US.utf8'
    lc_time = 'en_US.utf8'
    
    # Miscellaneous
    dynamic_shared_memory_type = posix
